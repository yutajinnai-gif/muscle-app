<!DOCTYPE html>
<html lang="ja" class="bg-slate-100">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>筋トレメモ | BUILD_TAG=FIX-20251001-REGRESSION</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha384-Jl0nO9r2yZS3AuNEqFOtPiou0IZ6Tn6PvxI6Bfq5lHppZArYrusS4x+h0/pk3jfb" crossorigin="anonymous"></script>
  <style>
    body { font-size: 16px; min-height: 100vh; }
    .scroll-lock { overflow: hidden; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.45); display: flex; align-items: center; justify-content: center; padding: 1.5rem; backdrop-filter: blur(2px); }
    .modal-card { max-width: 22rem; width: 100%; background: white; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 25px 50px -12px rgba(15, 23, 42, 0.25); }
    .error-banner { position: fixed; inset-inline: 0; top: 0; z-index: 50; }
    .tab-nav { position: fixed; bottom: 0; inset-inline: 0; background: white; border-top: 1px solid rgba(51, 65, 85, 0.2); padding: 0.5rem 0; display: flex; justify-content: space-around; }
    .main-content { padding-bottom: 4.5rem; padding-top: 4.5rem; }
    .btn-primary { background-color: #1f2937; color: white; }
    .btn-primary:hover { background-color: #111827; }
    .btn-muted { background-color: white; color: #1f2937; border: 1px solid rgba(30,41,59,0.3); }
    .input-base { border: 1px solid rgba(51,65,85,0.35); border-radius: 0.75rem; padding: 0.6rem 0.75rem; font-size: 1rem; width: 100%; background-color: white; color: #111827; }
    .input-base:focus { outline: 2px solid rgba(30, 64, 175, 0.6); outline-offset: 2px; }
  </style>
</head>
<body class="text-slate-900 overflow-x-hidden">
  <div id="error-root" class="error-banner hidden"></div>
  <main id="app" class="max-w-3xl mx-auto main-content px-4 sm:px-6"></main>
  <nav class="tab-nav">
    <button data-route="home" class="tab-button flex-1 text-sm font-semibold text-slate-800">ホーム</button>
    <button data-route="history" class="tab-button flex-1 text-sm font-semibold text-slate-800">履歴</button>
    <button data-route="workout" class="tab-button flex-1 text-sm font-semibold text-slate-800">記録</button>
    <button data-route="settings" class="tab-button flex-1 text-sm font-semibold text-slate-800">設定</button>
  </nav>
  <script>
  (function(){
    'use strict';

    /*** utils ***/
    const ROUTES = Object.freeze({
      HOME: 'home',
      HISTORY: 'history',
      SETTINGS: 'settings',
      WORKOUT: 'workout'
    });
    const ROUTE_VALUES = new Set(Object.values(ROUTES));

    const createElem = (tag, opts = {}) => {
      const el = document.createElement(tag);
      if (opts.className) el.className = opts.className;
      if (opts.textContent !== undefined) el.textContent = opts.textContent;
      if (opts.html !== undefined) el.innerHTML = opts.html;
      if (opts.attrs) Object.entries(opts.attrs).forEach(([k, v]) => el.setAttribute(k, v));
      if (opts.value !== undefined) el.value = opts.value;
      if (opts.children) opts.children.forEach(child => el.appendChild(child));
      return el;
    };

    const createInfoIcon = (tooltip) => {
      return createElem('span', {
        className: 'inline-flex items-center justify-center w-5 h-5 rounded-full border border-blue-600 text-[0.625rem] font-bold text-blue-700 cursor-help',
        textContent: 'i',
        attrs: { title: tooltip, 'aria-label': tooltip }
      });
    };

    const createFieldWrapper = (labelText, tooltip, description, inputEl) => {
      const wrapper = createElem('label', { className: 'flex flex-col gap-2 text-sm font-semibold text-slate-900' });
      const header = createElem('div', { className: 'flex items-center gap-2' });
      header.append(
        createElem('span', { textContent: labelText }),
        createInfoIcon(tooltip)
      );
      wrapper.append(header);
      if (description) {
        wrapper.append(createElem('span', { className: 'text-xs font-normal text-slate-800', textContent: description }));
      }
      wrapper.append(inputEl);
      return wrapper;
    };

    const getTodayDateValue = () => {
      const now = new Date();
      const offset = now.getTimezoneOffset();
      const local = new Date(now.getTime() - offset * 60000);
      return local.toISOString().slice(0, 10);
    };

    const registerLongPress = (element, handler, delay = 600) => {
      let timerId = null;
      const cancel = () => {
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
      };
      const start = (event) => {
        if (event.type === 'touchstart' && event.touches.length > 1) return;
        if (event.target.closest('input, textarea, select, button')) return;
        cancel();
        timerId = setTimeout(() => {
          handler();
          cancel();
        }, delay);
      };
      element.addEventListener('touchstart', start, { passive: true });
      element.addEventListener('mousedown', (event) => {
        if (event.button !== 0) return;
        start(event);
      });
      ['touchend', 'touchcancel', 'touchmove', 'mouseup', 'mouseleave'].forEach((type) => {
        element.addEventListener(type, cancel);
      });
    };

    const formatDate = (value) => {
      try {
        return new Intl.DateTimeFormat('ja-JP', { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));
      } catch (err) {
        return '';
      }
    };

    const safeNumber = (value) => {
      if (value === null || value === undefined) return null;
      if (typeof value === 'string' && value.trim() === '') return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };

    const cloneDeep = (obj) => structuredClone(obj);

    /*** error banner ***/
    const errorRoot = document.getElementById('error-root');
    const errorState = { logs: [], expanded: false };

    const renderErrorBanner = () => {
      if (!errorRoot) return;
      if (!errorState.logs.length) {
        errorRoot.classList.add('hidden');
        errorRoot.replaceChildren();
        return;
      }
      errorRoot.classList.remove('hidden');
      const container = createElem('div', { className: 'bg-red-900/90 text-red-50 px-4 py-3 shadow-lg border-b border-red-300' });
      const header = createElem('div', { className: 'flex items-center justify-between gap-2' });
      const toggleBtn = createElem('button', {
        className: 'text-sm underline decoration-dotted',
        textContent: errorState.expanded ? '閉じる' : '詳細',
        attrs: { type: 'button' }
      });
      header.append(
        createElem('div', { className: 'font-semibold', textContent: 'アプリでエラーが発生しました' }),
        toggleBtn
      );
      const logList = createElem('pre', { className: 'mt-2 text-xs bg-red-950/40 rounded-lg p-2 overflow-x-auto whitespace-pre-wrap' });
      logList.textContent = errorState.logs.map((log, idx) => `#${idx + 1}\n${log}`).join('\n\n');
      if (!errorState.expanded) logList.classList.add('hidden');
      toggleBtn.addEventListener('click', () => {
        errorState.expanded = !errorState.expanded;
        renderErrorBanner();
      });
      container.append(header, logList);
      errorRoot.replaceChildren(container);
    };

    const pushError = (message) => {
      errorState.logs.push(message);
      renderErrorBanner();
    };

    window.addEventListener('error', (event) => {
      pushError(`${event.message}\n${event.filename || ''}:${event.lineno || ''}`);
    });
    window.addEventListener('unhandledrejection', (event) => {
      pushError(`Promiseエラー: ${event.reason}`);
    });

    /*** storage ***/
    const SCHEMA_VERSION = 1;
    const STORAGE_NAMESPACE = 'muscle-app-core';
    class NamespacedStorage {
      constructor(namespace, version) {
        this.namespace = namespace;
        this.version = version;
      }
      _key(key) {
        return `${this.namespace}:${key}`;
      }
      _safeParse(raw) {
        try {
          return JSON.parse(raw);
        } catch (err) {
          return null;
        }
      }
      load(key, fallback) {
        const raw = localStorage.getItem(this._key(key));
        if (!raw) return cloneDeep(fallback);
        const parsed = this._safeParse(raw);
        if (!parsed || parsed.schema !== this.version) return cloneDeep(fallback);
        return parsed.data;
      }
      save(key, data) {
        const payload = JSON.stringify({ schema: this.version, data });
        localStorage.setItem(this._key(key), payload);
      }
      clearNamespace() {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (k && k.startsWith(`${this.namespace}:`)) keys.push(k);
        }
        keys.forEach((k) => localStorage.removeItem(k));
      }
    }

    const storage = new NamespacedStorage(STORAGE_NAMESPACE, SCHEMA_VERSION);

    /*** modal api ***/
    const modalState = { locked: false };

    const closeModal = (backdrop, outerResolve, value) => {
      if (!backdrop) return;
      backdrop.classList.add('opacity-0');
      setTimeout(() => {
        backdrop.remove();
        document.body.classList.remove('scroll-lock');
        modalState.locked = false;
        outerResolve(value);
      }, 120);
    };

    const openModal = (buildContent) => {
      if (modalState.locked) return Promise.resolve(null);
      modalState.locked = true;
      document.body.classList.add('scroll-lock');
      const backdrop = createElem('div', { className: 'modal-backdrop' });
      const card = createElem('div', { className: 'modal-card' });
      backdrop.append(card);
      document.body.append(backdrop);
      return new Promise((outerResolve) => {
        const finish = (value) => {
          document.removeEventListener('keydown', keyHandler);
          closeModal(backdrop, outerResolve, value);
        };
        const keyHandler = (event) => {
          if (event.key === 'Escape') finish(null);
        };
        document.addEventListener('keydown', keyHandler);
        backdrop.addEventListener('click', (event) => {
          if (event.target === backdrop) finish(null);
        });
        const { content, focus } = buildContent(finish);
        card.append(content);
        if (typeof focus === 'function') focus();
      });
    };

    const confirmAction = (message) => {
      return openModal((finish) => {
        const text = createElem('p', { className: 'text-sm text-slate-800 mb-4', textContent: message });
        const btnWrap = createElem('div', { className: 'flex justify-end gap-2' });
        const cancelBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const okBtn = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'OK', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', () => finish(false));
        okBtn.addEventListener('click', () => finish(true));
        btnWrap.append(cancelBtn, okBtn);
        return { content: createElem('div', { children: [text, btnWrap] }), focus: () => okBtn.focus() };
      }).then((value) => Boolean(value));
    };

    const pickFromList = (title, options) => {
      return openModal((finish) => {
        const header = createElem('div', { className: 'mb-3' });
        header.append(createElem('p', { className: 'text-sm font-semibold text-slate-800', textContent: title }));
        const list = createElem('div', { className: 'max-h-64 overflow-y-auto space-y-2' });
        options.forEach((opt) => {
          const btn = createElem('button', { className: 'w-full text-left px-3 py-2 rounded-lg border border-slate-200 hover:border-slate-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500', textContent: opt, attrs: { type: 'button' } });
          btn.addEventListener('click', () => finish(opt));
          list.append(btn);
        });
        const cancel = createElem('button', { className: 'mt-4 btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        cancel.addEventListener('click', () => finish(null));
        const firstButton = () => list.querySelector('button');
        const content = createElem('div', { children: [header, list, cancel] });
        return { content, focus: () => { const btn = firstButton(); if (btn) btn.focus(); else cancel.focus(); } };
      });
    };

    const promptText = (title) => {
      return openModal((finish) => {
        const label = createElem('label', { className: 'flex flex-col gap-2' });
        label.append(
          createElem('span', { className: 'text-sm font-semibold text-slate-800', textContent: title }),
          createElem('input', { className: 'input-base', attrs: { type: 'text' } })
        );
        const actions = createElem('div', { className: 'flex justify-end gap-2 mt-4' });
        const cancel = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const ok = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: '決定', attrs: { type: 'button' } });
        cancel.addEventListener('click', () => finish(null));
        const input = label.querySelector('input');
        ok.addEventListener('click', () => finish(input.value.trim() || null));
        actions.append(cancel, ok);
        const content = createElem('div', { children: [label, actions] });
        return { content, focus: () => input.focus() };
      });
    };

    /*** data model ***/
    const STORAGE_KEYS = Object.freeze({
      DATA: 'data'
    });

    const createInitialData = () => ({
      workouts: [],
      currentWorkout: {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: []
      },
      settings: {
        unit: 'kg',
        exerciseCatalog: ['ベンチプレス', 'スクワット', 'デッドリフト']
      },
      historyView: {
        exerciseName: null
      }
    });

    const loadData = () => {
      const stored = storage.load(STORAGE_KEYS.DATA, createInitialData());
      const base = createInitialData();
      return { ...base, ...stored };
    };

    let appData = loadData();

    const persist = () => {
      storage.save(STORAGE_KEYS.DATA, appData);
    };

    const resetData = () => {
      appData = createInitialData();
      oneRmMemo.clear();
      persist();
    };

    /*** 1RM memoization ***/
    const oneRmMemo = new Map();
    const compute1RM = (weight, reps) => {
      const w = safeNumber(weight);
      const r = safeNumber(reps);
      if (w === null || r === null || r <= 0 || w <= 0) return null;
      return Number((w * (1 + r / 30)).toFixed(2));
    };

    const getExerciseKey = (workoutId, exerciseId) => `${workoutId}:${exerciseId}`;

    const recomputeExercise = (workoutId, exercise) => {
      const key = getExerciseKey(workoutId, exercise.id);
      const signature = exercise.sets.map((set) => `${set.weight ?? ''}|${set.reps ?? ''}`).join('::');
      const cached = oneRmMemo.get(key);
      if (cached && cached.signature === signature) {
        cached.values.forEach((val, idx) => {
          exercise.sets[idx].oneRM = val;
        });
        return;
      }
      const values = exercise.sets.map((set) => compute1RM(set.weight, set.reps));
      values.forEach((val, idx) => {
        exercise.sets[idx].oneRM = val;
      });
      oneRmMemo.set(key, { signature, values });
    };

    const recomputeAll = () => {
      appData.workouts.forEach((workout) => {
        workout.exercises.forEach((exercise) => recomputeExercise(workout.id, exercise));
      });
      appData.currentWorkout.exercises.forEach((exercise) => recomputeExercise(appData.currentWorkout.id, exercise));
    };
    recomputeAll();

    /*** router ***/
    let currentRoute = ROUTES.HOME;

    const parseHash = (hash) => {
      const normalized = (hash || '').replace(/^#/, '').trim().toLowerCase();
      if (!normalized) return ROUTES.HOME;
      if (!ROUTE_VALUES.has(normalized)) return ROUTES.HOME;
      return normalized;
    };

    const navigate = (route) => {
      currentRoute = route;
      renderRoute();
      updateTabState();
    };

    window.addEventListener('hashchange', () => {
      const route = parseHash(location.hash);
      navigate(route);
    });

    /*** chart manager ***/
    const createChartManager = (canvas) => {
      const chart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: '推定1RM',
            data: [],
            borderColor: '#1d4ed8',
            backgroundColor: 'rgba(29, 78, 216, 0.15)',
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { color: '#1f2937' } },
            y: {
              ticks: { color: '#1f2937' },
              beginAtZero: true
            }
          },
          plugins: {
            legend: { labels: { color: '#1f2937', font: { weight: '600' } } }
          }
        }
      });
      return {
        update(labels, values) {
          chart.data.labels = labels;
          chart.data.datasets[0].data = values;
          chart.update();
        }
      };
    };

    let historyChartCanvas = null;
    let historyChartManager = null;

    /*** render helpers ***/
    const appRoot = document.getElementById('app');

    const updateTabState = () => {
      document.querySelectorAll('.tab-button').forEach((tab) => {
        const route = tab.getAttribute('data-route');
        if (route === currentRoute) {
          tab.classList.add('text-blue-600', 'font-bold');
          tab.classList.remove('text-slate-800');
        } else {
          tab.classList.remove('text-blue-600', 'font-bold');
          tab.classList.add('text-slate-800');
        }
      });
    };

    const setHash = (route) => {
      if (location.hash.replace('#', '') !== route) {
        location.hash = route;
      } else {
        navigate(route);
      }
    };

    const bindTabs = () => {
      document.querySelectorAll('.tab-button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const route = btn.getAttribute('data-route');
          if (ROUTE_VALUES.has(route)) setHash(route);
        });
      });
    };

    const renderRoute = () => {
      if (!appRoot) return;
      appRoot.replaceChildren();
      const heading = createElem('h1', { className: 'mb-6 text-2xl font-bold text-slate-900', textContent: '筋トレメモ' });
      appRoot.append(heading);
      if (currentRoute === ROUTES.HOME) renderHome();
      else if (currentRoute === ROUTES.HISTORY) renderHistory();
      else if (currentRoute === ROUTES.SETTINGS) renderSettings();
      else if (currentRoute === ROUTES.WORKOUT) renderWorkout();
      else renderHome();
    };

    const createCard = (titleText, body) => {
      return createElem('section', {
        className: 'bg-white rounded-2xl shadow-sm border border-slate-200/70 p-5 mb-6',
        children: [
          createElem('header', { className: 'flex items-center justify-between mb-4', children: [
            createElem('h2', { className: 'text-lg font-bold text-slate-800', textContent: titleText })
          ] }),
          body
        ]
      });
    };

    /*** actions ***/
    const ensureExerciseCatalog = (name) => {
      if (!name) return;
      if (!appData.settings.exerciseCatalog.includes(name)) {
        appData.settings.exerciseCatalog.push(name);
      }
    };

    const addExercise = async () => {
      const catalog = [...appData.settings.exerciseCatalog];
      catalog.sort((a, b) => a.localeCompare(b, 'ja'));
      const choice = await pickFromList('種目を選択', [...catalog, '新規追加']);
      if (!choice) return;
      let exerciseName = choice;
      if (choice === '新規追加') {
        exerciseName = await promptText('新しい種目名');
        if (!exerciseName) return;
      }
      ensureExerciseCatalog(exerciseName);
      const newExercise = {
        id: `ex-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`,
        name: exerciseName,
        equipment: '',
        attachment: '',
        angle: null,
        position: '',
        performedOn: getTodayDateValue(),
        intervalSeconds: null,
        sets: [createEmptySet()]
      };
      appData.currentWorkout.exercises.push(newExercise);
      recomputeExercise(appData.currentWorkout.id, newExercise);
      persist();
      renderRoute();
    };

    const createEmptySet = () => ({ weight: null, reps: null, oneRM: null, note: '' });

    const addSet = (exerciseId) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      exercise.sets.push(createEmptySet());
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
      renderRoute();
    };

    const updateSetField = (exerciseId, setIndex, field, value) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      const set = exercise.sets[setIndex];
      if (!set) return;
      if (field === 'weight' || field === 'reps') {
        const num = safeNumber(value);
        set[field] = num === null ? null : num;
      } else if (field === 'note') {
        set[field] = value;
      }
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
    };

    const updateExerciseField = (exerciseId, field, value) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      if (field === 'angle' || field === 'intervalSeconds') {
        if (value === '' || value === null || value === undefined) {
          exercise[field] = null;
        } else {
          const num = safeNumber(value);
          exercise[field] = num === null ? null : num;
        }
      } else if (field === 'performedOn') {
        exercise[field] = value || '';
      } else {
        exercise[field] = value;
      }
      persist();
    };

    const duplicateSet = (exerciseId, setIndex) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      const baseSet = exercise.sets[setIndex];
      if (!baseSet) return;
      const cloned = createEmptySet();
      cloned.weight = baseSet.weight;
      cloned.reps = baseSet.reps;
      cloned.note = baseSet.note;
      exercise.sets.splice(setIndex + 1, 0, cloned);
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
      renderRoute();
    };

    const deleteExercise = async (exerciseId) => {
      if (!(await confirmAction('この種目を削除しますか？'))) return;
      appData.currentWorkout.exercises = appData.currentWorkout.exercises.filter((ex) => ex.id !== exerciseId);
      persist();
      renderRoute();
    };

    const finishWorkout = async () => {
      if (!appData.currentWorkout.exercises.length) return;
      const confirmed = await confirmAction('現在のワークアウトを完了として保存しますか？');
      if (!confirmed) return;
      const workoutCopy = cloneDeep(appData.currentWorkout);
      workoutCopy.id = `wo-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`;
      workoutCopy.completedAt = Date.now();
      workoutCopy.exercises.forEach((exercise) => recomputeExercise(workoutCopy.id, exercise));
      appData.workouts.unshift(workoutCopy);
      appData.currentWorkout = {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: []
      };
      persist();
      renderRoute();
    };

    const deleteWorkout = async (workoutId) => {
      const ok = await confirmAction('選択した履歴を削除しますか？');
      if (!ok) return;
      appData.workouts = appData.workouts.filter((wk) => wk.id !== workoutId);
      persist();
      renderRoute();
    };

    const clearAllData = async () => {
      const ok = await confirmAction('すべてのデータを初期化します。よろしいですか？');
      if (!ok) return;
      storage.clearNamespace();
      resetData();
      renderRoute();
    };

    const changeUnit = (unit) => {
      appData.settings.unit = unit;
      persist();
      renderRoute();
    };

    const exportData = () => {
      const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = createElem('a', { attrs: { href: url, download: 'muscle-app-backup.json' } });
      document.body.append(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    };

    const importData = async (file) => {
      if (!file) return;
      const text = await file.text();
      try {
        const parsed = JSON.parse(text);
        if (!parsed || typeof parsed !== 'object') throw new Error('形式が正しくありません');
        appData = { ...createInitialData(), ...parsed };
        recomputeAll();
        persist();
        renderRoute();
      } catch (err) {
        pushError(`読み込みに失敗しました: ${err.message}`);
      }
    };

    /*** route renderers ***/
    const renderHome = () => {
      const workout = appData.currentWorkout;
      const cardBody = createElem('div', { className: 'space-y-6' });
      const headerInfo = createElem('p', {
        className: 'rounded-xl border border-slate-300 bg-slate-50 px-4 py-3 text-sm text-slate-800',
        textContent: `開始: ${formatDate(workout.startedAt)}`
      });
      cardBody.append(headerInfo);
      if (!workout.exercises.length) {
        cardBody.append(createElem('p', { className: 'text-sm leading-relaxed text-slate-800', textContent: '種目を追加して記録を開始しましょう。' }));
      } else {
        workout.exercises.forEach((exercise) => {
          const exCard = createElem('section', { className: 'space-y-5 rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
          const exHeader = createElem('div', { className: 'flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between' });
          exHeader.append(createElem('h3', { className: 'text-lg font-bold text-slate-900', textContent: exercise.name }));
          const deleteBtn = createElem('button', { className: 'self-start text-sm font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500', textContent: '削除', attrs: { type: 'button' } });
          deleteBtn.addEventListener('click', () => deleteExercise(exercise.id));
          exHeader.append(deleteBtn);
          exCard.append(exHeader);

          const metaPanel = createElem('div', { className: 'space-y-4 rounded-xl border border-slate-200 bg-slate-50 p-4' });
          const equipmentRow = createElem('div', { className: 'grid grid-cols-1 gap-4 sm:grid-cols-2' });
          const equipmentInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'text', autocomplete: 'off', placeholder: '例: バーベル' }, value: exercise.equipment ?? '' });
          equipmentInput.addEventListener('input', (event) => updateExerciseField(exercise.id, 'equipment', event.target.value));
          const equipmentField = createFieldWrapper('器具', '使用した器具を入力します。', '使用した器具の種類を記録しましょう。', equipmentInput);
          const attachmentInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'text', autocomplete: 'off', placeholder: '例: ワイドグリップ' }, value: exercise.attachment ?? '' });
          attachmentInput.addEventListener('input', (event) => updateExerciseField(exercise.id, 'attachment', event.target.value));
          const attachmentField = createFieldWrapper('アタッチメント', '利用したアタッチメントを記録します。', 'ケーブルハンドルなどをメモできます。', attachmentInput);
          equipmentRow.append(equipmentField, attachmentField);
          metaPanel.append(equipmentRow);

          const angleRow = createElem('div', { className: 'grid grid-cols-1 gap-4 sm:grid-cols-2' });
          const angleInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'decimal', min: '0', max: '180', step: '1', placeholder: '例: 30' }, value: exercise.angle ?? '' });
          angleInput.addEventListener('input', (event) => updateExerciseField(exercise.id, 'angle', event.target.value));
          const angleField = createFieldWrapper('角度 (°)', 'ベンチやマシンの角度を記録します。', '角度の変化を記録してフォームを比較。', angleInput);
          const positionInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'text', autocomplete: 'off', placeholder: '例: ナロー・スタンス' }, value: exercise.position ?? '' });
          positionInput.addEventListener('input', (event) => updateExerciseField(exercise.id, 'position', event.target.value));
          const positionField = createFieldWrapper('スタンス / ポジション', '足幅やグリップ幅などを記録します。', 'スタンスやポジションの工夫を書き残しましょう。', positionInput);
          angleRow.append(angleField, positionField);
          metaPanel.append(angleRow);

          const scheduleRow = createElem('div', { className: 'grid grid-cols-1 gap-4 sm:grid-cols-2' });
          const performedOnInput = createElem('input', { className: 'input-base text-slate-900', attrs: { type: 'date', min: '2000-01-01', max: '2099-12-31', step: '1' }, value: exercise.performedOn ?? '' });
          performedOnInput.addEventListener('input', (event) => updateExerciseField(exercise.id, 'performedOn', event.target.value));
          const performedOnField = createFieldWrapper('実施日', 'トレーニングを行った日付です。', '後から見返すために日付を残せます。', performedOnInput);
          const intervalInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'numeric', min: '0', max: '600', step: '5', placeholder: '例: 90' }, value: exercise.intervalSeconds ?? '' });
          intervalInput.addEventListener('input', (event) => updateExerciseField(exercise.id, 'intervalSeconds', event.target.value));
          const intervalField = createFieldWrapper('インターバル (秒)', 'セット間の休憩秒数を記録します。', 'タイマーで計測した秒数を入力。', intervalInput);
          scheduleRow.append(performedOnField, intervalField);
          metaPanel.append(scheduleRow);
          exCard.append(metaPanel);

          const table = createElem('div', { className: 'space-y-4' });
          exercise.sets.forEach((set, index) => {
            const row = createElem('div', { className: 'grid grid-cols-1 sm:grid-cols-4 gap-4 items-start rounded-xl border border-slate-200 bg-white p-4 shadow-sm', attrs: { title: '長押しでこのセットを複製できます' } });
            registerLongPress(row, () => duplicateSet(exercise.id, index));
            const weightInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'decimal', min: '0', step: '0.5' }, value: set.weight ?? '' });
            weightInput.addEventListener('input', (event) => {
              updateSetField(exercise.id, index, 'weight', event.target.value);
              renderRoute();
            });
            const weightField = createFieldWrapper(`重量 (${appData.settings.unit})`, 'このセットで扱った重量です。', '小数点も入力できます。', weightInput);
            const repsInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'numeric', min: '0', step: '1' }, value: set.reps ?? '' });
            repsInput.addEventListener('input', (event) => {
              updateSetField(exercise.id, index, 'reps', event.target.value);
              renderRoute();
            });
            const repsField = createFieldWrapper('回数', '完了した反復回数を入力します。', '失敗した場合は実際の回数を。', repsInput);
            const noteInput = createElem('textarea', { className: 'input-base min-h-[3rem] text-slate-900 placeholder-slate-400', attrs: { rows: '2', placeholder: 'フォームや感覚をメモ' }, textContent: set.note || '' });
            noteInput.addEventListener('input', (event) => {
              updateSetField(exercise.id, index, 'note', event.target.value);
            });
            const noteField = createFieldWrapper('セットメモ', '気づいたことや次回の課題を記録します。', 'フォームやRPEを自由に入力。', noteInput);
            noteField.classList.add('sm:col-span-2');
            const oneRmLabel = createElem('p', { className: 'sm:col-span-4 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-sm font-medium text-slate-800', textContent: set.oneRM ? `推定1RM: ${set.oneRM} ${appData.settings.unit}` : '推定1RM: -' });
            row.append(weightField, repsField, noteField, oneRmLabel);
            table.append(row);
          });
          const addSetBtn = createElem('button', { className: 'btn-muted mt-2 inline-flex items-center justify-center rounded-lg border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100', textContent: 'セットを追加', attrs: { type: 'button' } });
          addSetBtn.addEventListener('click', () => addSet(exercise.id));
          exCard.append(table, addSetBtn);
          cardBody.append(exCard);
        });
      }
      const actions = createElem('div', { className: 'flex flex-col gap-3 sm:flex-row' });
      const addExerciseBtn = createElem('button', { className: 'btn-primary flex-1 rounded-xl px-4 py-3 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500', textContent: '種目を追加', attrs: { type: 'button' } });
      addExerciseBtn.addEventListener('click', addExercise);
      const finishBtn = createElem('button', { className: 'btn-muted flex-1 rounded-xl border border-slate-300 px-4 py-3 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500', textContent: '完了して履歴へ', attrs: { type: 'button' } });
      finishBtn.addEventListener('click', finishWorkout);
      actions.append(addExerciseBtn, finishBtn);
      cardBody.append(actions);
      appRoot.append(createCard('現在のワークアウト', cardBody));
    };

    const renderHistory = () => {
      const cardBody = createElem('div', { className: 'space-y-6' });
      if (!appData.workouts.length) {
        cardBody.append(createElem('p', { className: 'text-sm text-slate-800', textContent: '履歴はまだありません。' }));
      } else {
        const list = createElem('div', { className: 'space-y-4' });
        appData.workouts.forEach((workout) => {
          const item = createElem('article', { className: 'rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
          const header = createElem('div', { className: 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between' });
          const timestamp = formatDate(workout.completedAt || workout.startedAt);
          header.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: timestamp }));
          const deleteBtn = createElem('button', { className: 'self-start text-xs font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500', textContent: '削除', attrs: { type: 'button' } });
          deleteBtn.addEventListener('click', () => deleteWorkout(workout.id));
          header.append(deleteBtn);
          item.append(header);
          workout.exercises.forEach((exercise) => {
            const exerciseBlock = createElem('div', { className: 'mt-4 space-y-3 rounded-xl border border-slate-200 bg-slate-50 p-4' });
            exerciseBlock.append(createElem('h4', { className: 'text-base font-bold text-slate-900', textContent: exercise.name }));
            const metaItems = [
              { label: '器具', value: exercise.equipment },
              { label: 'アタッチメント', value: exercise.attachment },
              { label: '角度 (°)', value: exercise.angle != null ? `${exercise.angle}°` : null },
              { label: 'スタンス / ポジション', value: exercise.position },
              { label: '実施日', value: exercise.performedOn },
              { label: 'インターバル (秒)', value: exercise.intervalSeconds != null ? `${exercise.intervalSeconds}秒` : null }
            ].filter((item) => item.value !== null && item.value !== undefined && item.value !== '');
            if (metaItems.length) {
              const metaList = createElem('ul', { className: 'grid grid-cols-1 gap-2 text-sm text-slate-800 sm:grid-cols-2' });
              metaItems.forEach(({ label, value }) => {
                const meta = createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 shadow-sm' });
                meta.append(
                  createElem('p', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-800', textContent: label }),
                  createElem('p', { className: 'text-sm font-medium text-slate-900', textContent: value })
                );
                metaList.append(meta);
              });
              exerciseBlock.append(metaList);
            }
            const setsList = createElem('ul', { className: 'space-y-2' });
            exercise.sets.forEach((set, index) => {
              const info = `#${index + 1} 重量: ${set.weight ?? '-'}${appData.settings.unit} / 回数: ${set.reps ?? '-'} / 推定1RM: ${set.oneRM ?? '-'}${set.note ? ' / ' + set.note : ''}`;
              setsList.append(createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-800 shadow-sm', textContent: info }));
            });
            const trendBtn = createElem('button', { className: 'text-xs font-semibold text-blue-700 underline decoration-dotted hover:text-blue-800', textContent: '推移を表示', attrs: { type: 'button' } });
            trendBtn.addEventListener('click', () => {
              appData.historyView.exerciseName = exercise.name;
              renderRoute();
            });
            exerciseBlock.append(setsList, trendBtn);
            item.append(exerciseBlock);
          });
          list.append(item);
        });
        cardBody.append(list);
      }
      if (!historyChartCanvas) {
        historyChartCanvas = createElem('canvas');
        historyChartManager = createChartManager(historyChartCanvas);
      }
      const chartContainer = createElem('div', { className: 'mt-6 h-64 relative' });
      chartContainer.append(historyChartCanvas);
      cardBody.append(chartContainer);
      appRoot.append(createCard('ワークアウト履歴', cardBody));
      const exerciseName = appData.historyView.exerciseName;
      if (exerciseName) {
        const dataset = [];
        appData.workouts.slice().reverse().forEach((workout) => {
          workout.exercises.filter((ex) => ex.name === exerciseName).forEach((exercise) => {
            const best = Math.max(...exercise.sets.map((set) => Number(set.oneRM) || 0));
            dataset.push({ date: workout.completedAt || workout.startedAt, value: best });
          });
        });
        const labels = dataset.map((d) => formatDate(d.date));
        const values = dataset.map((d) => d.value);
        historyChartManager.update(labels, values);
      } else {
        historyChartManager.update([], []);
      }
    };

    const renderWorkout = () => {
      const cardBody = createElem('div', { className: 'space-y-6' });
      if (!appData.workouts.length) {
        cardBody.append(createElem('p', { className: 'text-sm text-slate-800', textContent: '保存済みのワークアウトはありません。' }));
      } else {
        const latest = appData.workouts[0];
        cardBody.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: `最新の完了日時: ${formatDate(latest.completedAt || latest.startedAt)}` }));
        latest.exercises.forEach((exercise) => {
          const block = createElem('div', { className: 'space-y-3 rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
          block.append(createElem('h3', { className: 'text-base font-bold text-slate-900', textContent: exercise.name }));
          const metaItems = [
            { label: '器具', value: exercise.equipment },
            { label: 'アタッチメント', value: exercise.attachment },
            { label: '角度 (°)', value: exercise.angle != null ? `${exercise.angle}°` : null },
            { label: 'スタンス / ポジション', value: exercise.position },
            { label: '実施日', value: exercise.performedOn },
            { label: 'インターバル (秒)', value: exercise.intervalSeconds != null ? `${exercise.intervalSeconds}秒` : null }
          ].filter((item) => item.value !== null && item.value !== undefined && item.value !== '');
          if (metaItems.length) {
            const metaList = createElem('ul', { className: 'grid grid-cols-1 gap-2 text-sm text-slate-800 sm:grid-cols-2' });
            metaItems.forEach(({ label, value }) => {
              const meta = createElem('li', { className: 'rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 shadow-sm' });
              meta.append(
                createElem('p', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-800', textContent: label }),
                createElem('p', { className: 'text-sm font-medium text-slate-900', textContent: value })
              );
              metaList.append(meta);
            });
            block.append(metaList);
          }
          const list = createElem('ul', { className: 'space-y-2' });
          exercise.sets.forEach((set, idx) => {
            list.append(createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-800 shadow-sm', textContent: `#${idx + 1} 重量:${set.weight ?? '-'}${appData.settings.unit} / 回数:${set.reps ?? '-'} / 推定1RM:${set.oneRM ?? '-'}` }));
          });
          block.append(list);
          cardBody.append(block);
        });
      }
      appRoot.append(createCard('最新のワークアウト', cardBody));
    };

    const renderSettings = () => {
      const cardBody = createElem('div', { className: 'space-y-6' });
      const unitSection = createElem('div', { className: 'space-y-3' });
      unitSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '単位設定' }));
      const unitOptions = ['kg', 'lb'];
      const unitWrap = createElem('div', { className: 'flex gap-3' });
      unitOptions.forEach((unit) => {
        const label = createElem('label', { className: 'inline-flex items-center gap-2 text-sm text-slate-800 font-semibold' });
        const input = createElem('input', { attrs: { type: 'radio', name: 'unit', value: unit } });
        if (appData.settings.unit === unit) input.checked = true;
        input.addEventListener('change', () => changeUnit(unit));
        label.append(input, createElem('span', { textContent: unit }));
        unitWrap.append(label);
      });
      unitSection.append(unitWrap);
      cardBody.append(unitSection);

      const catalogSection = createElem('div', { className: 'space-y-3' });
      catalogSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '登録済み種目' }));
      const list = createElem('ul', { className: 'space-y-2' });
      appData.settings.exerciseCatalog.forEach((name) => {
        list.append(createElem('li', { className: 'text-sm text-slate-800 px-3 py-2 bg-slate-100 rounded-lg border border-slate-200', textContent: name }));
      });
      catalogSection.append(list);
      cardBody.append(catalogSection);

      const importExportSection = createElem('div', { className: 'space-y-3' });
      importExportSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: 'バックアップ' }));
      const exportBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'エクスポート', attrs: { type: 'button' } });
      exportBtn.addEventListener('click', exportData);
      const importLabel = createElem('label', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold inline-flex items-center justify-center gap-2 w-fit cursor-pointer' });
      importLabel.append(createElem('span', { textContent: 'インポート' }));
      const input = createElem('input', { attrs: { type: 'file', accept: 'application/json' } });
      input.classList.add('hidden');
      input.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        importData(file);
        event.target.value = '';
      });
      importLabel.append(input);
      importExportSection.append(createElem('div', { className: 'flex gap-3', children: [exportBtn, importLabel] }));
      cardBody.append(importExportSection);

      const dangerSection = createElem('div', { className: 'space-y-3' });
      dangerSection.append(createElem('h3', { className: 'text-base font-semibold text-red-700', textContent: 'データ初期化' }));
      const clearBtn = createElem('button', { className: 'bg-red-700 hover:bg-red-800 text-white px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'すべて削除', attrs: { type: 'button' } });
      clearBtn.addEventListener('click', clearAllData);
      dangerSection.append(clearBtn);
      cardBody.append(dangerSection);

      appRoot.append(createCard('設定', cardBody));
    };

    /*** bootstrap ***/
    bindTabs();
    setHash(parseHash(location.hash));
  })();
  </script>
</body>
</html>
