<!DOCTYPE html>
<html lang="ja" class="bg-slate-100">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BUILD_TAG=PERF-YYYYMMDD</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha384-Jl0nO9r2yZS3AuNEqFOtPiou0IZ6Tn6PvxI6Bfq5lHppZArYrusS4x+h0/pk3jfb" crossorigin="anonymous"></script>
  <style>
    body { font-size: 16px; min-height: 100vh; }
    .scroll-lock { overflow: hidden; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.45); display: flex; align-items: center; justify-content: center; padding: 1.5rem; backdrop-filter: blur(2px); }
    .modal-card { max-width: 22rem; width: 100%; background: white; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 25px 50px -12px rgba(15, 23, 42, 0.25); }
    .error-banner { position: fixed; inset-inline: 0; top: 0; z-index: 50; }
    .tab-nav { position: fixed; bottom: 0; inset-inline: 0; background: white; border-top: 1px solid rgba(51, 65, 85, 0.2); padding: 0.5rem 0; display: flex; justify-content: space-around; }
    .main-content { padding-bottom: 4.5rem; padding-top: 4.5rem; }
    .btn-primary { background-color: #1f2937; color: white; }
    .btn-primary:hover { background-color: #111827; }
    .btn-muted { background-color: white; color: #1f2937; border: 1px solid rgba(30,41,59,0.3); }
    .input-base { border: 1px solid rgba(51,65,85,0.35); border-radius: 0.75rem; padding: 0.6rem 0.75rem; font-size: 1rem; width: 100%; background-color: white; color: #111827; }
    .input-base:focus { outline: 2px solid rgba(30, 64, 175, 0.6); outline-offset: 2px; }
  </style>
</head>
<body class="text-slate-900 overflow-x-hidden">
  <div id="error-root" class="error-banner hidden"></div>
  <main id="app" class="max-w-3xl mx-auto main-content px-4 sm:px-6"></main>
  <nav class="tab-nav">
    <button data-route="home" class="tab-button flex-1 text-sm font-semibold text-slate-800">ホーム</button>
    <button data-route="history" class="tab-button flex-1 text-sm font-semibold text-slate-800">履歴</button>
    <button data-route="workout" class="tab-button flex-1 text-sm font-semibold text-slate-800">記録</button>
    <button data-route="settings" class="tab-button flex-1 text-sm font-semibold text-slate-800">設定</button>
  </nav>
  <script>
  (function(){
    'use strict';

    /*** utils ***/
    const ROUTES = Object.freeze({
      HOME: 'home',
      HISTORY: 'history',
      SETTINGS: 'settings',
      WORKOUT: 'workout'
    });
    const ROUTE_VALUES = new Set(Object.values(ROUTES));

    const createElem = (tag, opts = {}) => {
      const el = document.createElement(tag);
      if (opts.className) el.className = opts.className;
      if (opts.textContent !== undefined) el.textContent = opts.textContent;
      if (opts.html !== undefined) el.innerHTML = opts.html;
      if (opts.attrs) Object.entries(opts.attrs).forEach(([k, v]) => el.setAttribute(k, v));
      if (opts.value !== undefined) el.value = opts.value;
      if (opts.children) opts.children.forEach(child => el.appendChild(child));
      return el;
    };

    const createInfoIcon = (tooltip) => {
      return createElem('span', {
        className: 'inline-flex items-center justify-center w-5 h-5 rounded-full border border-blue-600 text-[0.625rem] font-bold text-blue-700 cursor-help',
        textContent: 'i',
        attrs: { title: tooltip, 'aria-label': tooltip }
      });
    };

    const createFieldWrapper = (labelText, tooltip, description, inputEl) => {
      const wrapper = createElem('label', { className: 'flex flex-col gap-2 text-sm font-semibold text-slate-900' });
      const header = createElem('div', { className: 'flex items-center gap-2' });
      header.append(
        createElem('span', { textContent: labelText }),
        createInfoIcon(tooltip)
      );
      wrapper.append(header);
      if (description) {
        wrapper.append(createElem('span', { className: 'text-xs font-normal text-slate-800', textContent: description }));
      }
      wrapper.append(inputEl);
      return wrapper;
    };

    const getTodayDateValue = () => {
      const now = new Date();
      const offset = now.getTimezoneOffset();
      const local = new Date(now.getTime() - offset * 60000);
      return local.toISOString().slice(0, 10);
    };

    const registerLongPress = (element, handler, delay = 600) => {
      let timerId = null;
      const cancel = () => {
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
      };
      const start = (event) => {
        if (event.type === 'touchstart' && event.touches.length > 1) return;
        if (event.target.closest('input, textarea, select, button')) return;
        cancel();
        timerId = setTimeout(() => {
          handler();
          cancel();
        }, delay);
      };
      element.addEventListener('touchstart', start, { passive: true });
      element.addEventListener('mousedown', (event) => {
        if (event.button !== 0) return;
        start(event);
      });
      ['touchend', 'touchcancel', 'touchmove', 'mouseup', 'mouseleave'].forEach((type) => {
        element.addEventListener(type, cancel);
      });
    };

    const formatDate = (value) => {
      try {
        return new Intl.DateTimeFormat('ja-JP', { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));
      } catch (err) {
        return '';
      }
    };

    const safeNumber = (value) => {
      if (value === null || value === undefined) return null;
      if (typeof value === 'string' && value.trim() === '') return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };

    const cloneDeep = (obj) => {
      if (typeof structuredClone === 'function') {
        return structuredClone(obj);
      }
      return JSON.parse(JSON.stringify(obj));
    };

    const CSV_SCHEMA_VERSION = 1;
    const CSV_RECORD_TYPES = Object.freeze({
      META: 'meta',
      SETTINGS: 'settings',
      CATALOG: 'catalog',
      HISTORY_VIEW: 'history-view',
      WORKOUT: 'workout',
      EXERCISE: 'exercise',
      SET: 'set'
    });
    const CSV_COLUMNS = Object.freeze([
      'schemaVersion',
      'device',
      'exportedAt',
      'recordType',
      'workoutState',
      'workoutId',
      'workoutStartedAt',
      'workoutCompletedAt',
      'workoutOrder',
      'date',
      'part',
      'exercise',
      'equipment',
      'attachment',
      'angle',
      'position',
      'performedOn',
      'intervalSeconds',
      'exerciseId',
      'setIndex',
      'setType',
      'weight',
      'reps',
      'oneRM',
      'note',
      'unit',
      'catalogEntry'
    ]);
    const CSV_ALLOWED_SET_TYPES = new Set(['', 'standard']);
    const CSV_LINE_BREAK = '\r\n';

    const getDeviceName = () => {
      try {
        if (navigator.userAgentData && Array.isArray(navigator.userAgentData.brands)) {
          const brands = navigator.userAgentData.brands
            .map((brand) => brand.brand)
            .filter(Boolean)
            .join(' ');
          if (brands) return brands.slice(0, 120);
        }
      } catch (err) {
        // ignore detection errors
      }
      if (navigator.platform && navigator.platform.trim()) {
        return navigator.platform.trim().slice(0, 120);
      }
      if (navigator.userAgent && navigator.userAgent.trim()) {
        return navigator.userAgent.trim().slice(0, 120);
      }
      return 'unknown-device';
    };

    const createCsvRow = () => {
      const row = {};
      CSV_COLUMNS.forEach((col) => {
        row[col] = '';
      });
      return row;
    };

    const escapeCsvValue = (value) => {
      if (value === null || value === undefined) return '';
      const str = String(value);
      if (str === '') return '';
      if (/[",\n\r]/.test(str)) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    };

    const serializeCsvRows = (rows) => {
      const header = CSV_COLUMNS.join(',');
      const body = rows
        .map((row) => CSV_COLUMNS.map((col) => escapeCsvValue(row[col])).join(','))
        .join(CSV_LINE_BREAK);
      return [header, body].filter(Boolean).join(CSV_LINE_BREAK) + CSV_LINE_BREAK;
    };

    const parseCsvContent = (text) => {
      const rows = [];
      let field = '';
      let currentRow = [];
      let inQuotes = false;
      let lineNumber = 1;
      const pushField = () => {
        currentRow.push(field);
        field = '';
      };
      const pushRow = () => {
        if (!currentRow.length) return;
        const isEmpty = currentRow.every((cell) => cell === '');
        if (!isEmpty) rows.push(currentRow.slice());
        currentRow = [];
        lineNumber += 1;
      };
      for (let i = 0; i < text.length; i += 1) {
        const char = text[i];
        if (inQuotes) {
          if (char === '"') {
            if (text[i + 1] === '"') {
              field += '"';
              i += 1;
            } else {
              inQuotes = false;
            }
          } else {
            field += char;
          }
          continue;
        }
        if (char === '"') {
          inQuotes = true;
          continue;
        }
        if (char === ',') {
          pushField();
          continue;
        }
        if (char === '\n') {
          pushField();
          pushRow();
          continue;
        }
        if (char === '\r') {
          if (text[i + 1] === '\n') {
            i += 1;
          }
          pushField();
          pushRow();
          continue;
        }
        field += char;
      }
      if (field !== '' || currentRow.length) {
        pushField();
        pushRow();
      }
      if (inQuotes) {
        rows.__unclosedQuote = true;
        rows.__lineNumber = lineNumber;
      }
      return rows;
    };

    const validateCsvHeader = (header) => {
      const issues = [];
      if (!Array.isArray(header)) {
        issues.push('ヘッダー行が取得できませんでした。');
        return issues;
      }
      if (header.length !== CSV_COLUMNS.length) {
        issues.push(`列数が一致しません (期待: ${CSV_COLUMNS.length} 列 / 実際: ${header.length} 列)`);
      }
      const max = Math.max(header.length, CSV_COLUMNS.length);
      for (let idx = 0; idx < max; idx += 1) {
        const expected = CSV_COLUMNS[idx] ?? '(該当なし)';
        const actual = header[idx] ?? '(該当なし)';
        if (expected !== actual) {
          issues.push(`列${idx + 1}: 期待 "${expected}" / 実際 "${actual}"`);
        }
      }
      return issues;
    };

    const toNumberOrNull = (value) => {
      if (value === null || value === undefined) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;
      const num = Number(trimmed);
      return Number.isFinite(num) ? num : null;
    };

    const toIntegerOrNull = (value) => {
      const num = toNumberOrNull(value);
      if (num === null) return null;
      return Number.isInteger(num) ? num : null;
    };

    /*** error banner ***/
    const errorRoot = document.getElementById('error-root');
    const errorState = { logs: [], expanded: false, rollback: null };

    const renderErrorBanner = () => {
      if (!errorRoot) return;
      if (!errorState.logs.length) {
        errorRoot.classList.add('hidden');
        errorRoot.replaceChildren();
        return;
      }
      errorRoot.classList.remove('hidden');
      const container = createElem('div', { className: 'bg-red-900/90 text-red-50 px-4 py-3 shadow-lg border-b border-red-300' });
      const header = createElem('div', { className: 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between' });
      const title = createElem('div', { className: 'font-semibold', textContent: 'アプリでエラーが発生しました' });
      const actionWrap = createElem('div', { className: 'flex items-center gap-3' });
      const toggleBtn = createElem('button', {
        className: 'text-sm underline decoration-dotted',
        textContent: errorState.expanded ? '閉じる' : '詳細',
        attrs: { type: 'button' }
      });
      actionWrap.append(toggleBtn);
      if (typeof errorState.rollback === 'function') {
        const rollbackBtn = createElem('button', {
          className: 'text-sm font-semibold underline decoration-dotted text-red-100 hover:text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-200',
          textContent: '直前操作を取り消す',
          attrs: { type: 'button' }
        });
        rollbackBtn.addEventListener('click', () => {
          const handler = errorState.rollback;
          errorState.rollback = null;
          renderErrorBanner();
          if (handler) {
            try {
              handler();
            } catch (err) {
              pushError(`ロールバックに失敗しました: ${err.message || err}`);
            }
          }
        });
        actionWrap.append(rollbackBtn);
      }
      header.append(title, actionWrap);
      const logList = createElem('pre', { className: 'mt-2 text-xs bg-red-950/40 rounded-lg p-2 overflow-x-auto whitespace-pre-wrap' });
      logList.textContent = errorState.logs.map((log, idx) => `#${idx + 1}\n${log}`).join('\n\n');
      if (!errorState.expanded) logList.classList.add('hidden');
      toggleBtn.addEventListener('click', () => {
        errorState.expanded = !errorState.expanded;
        renderErrorBanner();
      });
      container.append(header, logList);
      errorRoot.replaceChildren(container);
    };

    const pushError = (message) => {
      errorState.logs.push(message);
      renderErrorBanner();
    };

    const showRecoverableError = (message, rollback) => {
      errorState.logs.push(message);
      errorState.rollback = typeof rollback === 'function' ? rollback : null;
      renderErrorBanner();
    };

    const clearRecoverableError = () => {
      errorState.rollback = null;
      renderErrorBanner();
    };

    const validationRoot = (() => {
      const base = createElem('div', {
        className: 'error-banner hidden',
        attrs: { id: 'validation-banner', role: 'alert', 'aria-live': 'assertive' }
      });
      if (errorRoot && errorRoot.parentNode) {
        errorRoot.insertAdjacentElement('afterend', base);
      } else {
        document.body.prepend(base);
      }
      return base;
    })();

    const validationState = { message: null };

    const renderValidationBanner = () => {
      if (!validationRoot) return;
      if (!validationState.message) {
        validationRoot.classList.add('hidden');
        validationRoot.replaceChildren();
        return;
      }
      validationRoot.classList.remove('hidden');
      const container = createElem('div', {
        className: 'bg-red-700 text-red-50 px-4 py-3 shadow-lg border-b border-red-300'
      });
      container.append(
        createElem('p', { className: 'text-sm font-semibold', textContent: validationState.message })
      );
      validationRoot.replaceChildren(container);
    };

    const showValidationError = (message) => {
      validationState.message = message;
      renderValidationBanner();
    };

    const clearValidationError = () => {
      validationState.message = null;
      renderValidationBanner();
    };

    window.addEventListener('error', (event) => {
      pushError(`${event.message}\n${event.filename || ''}:${event.lineno || ''}`);
    });
    window.addEventListener('unhandledrejection', (event) => {
      pushError(`Promiseエラー: ${event.reason}`);
    });

    /*** storage ***/
    const SCHEMA_VERSION = CSV_SCHEMA_VERSION;
    const STORAGE_NAMESPACE = 'muscle-app-core';
    const AUTO_BACKUP_KEY = `${STORAGE_NAMESPACE}:auto-backup`;
    class NamespacedStorage {
      constructor(namespace, version) {
        this.namespace = namespace;
        this.version = version;
      }
      _key(key) {
        return `${this.namespace}:${key}`;
      }
      _safeParse(raw) {
        try {
          return JSON.parse(raw);
        } catch (err) {
          return null;
        }
      }
      load(key, fallback) {
        const raw = localStorage.getItem(this._key(key));
        if (!raw) return cloneDeep(fallback);
        const parsed = this._safeParse(raw);
        if (!parsed || parsed.schema !== this.version) return cloneDeep(fallback);
        return parsed.data;
      }
      save(key, data) {
        const payload = JSON.stringify({ schema: this.version, data });
        localStorage.setItem(this._key(key), payload);
      }
      clearNamespace() {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (k && k.startsWith(`${this.namespace}:`)) keys.push(k);
        }
        keys.forEach((k) => localStorage.removeItem(k));
      }
    }

    const storage = new NamespacedStorage(STORAGE_NAMESPACE, SCHEMA_VERSION);

    const readAutoBackupSnapshot = () => {
      try {
        const raw = localStorage.getItem(AUTO_BACKUP_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return null;
        if (parsed.schemaVersion !== SCHEMA_VERSION) {
          return null;
        }
        return parsed;
      } catch (err) {
        return null;
      }
    };

    const createAutoBackupSnapshot = () => {
      if (!appData) return;
      try {
        const payload = {
          schemaVersion: SCHEMA_VERSION,
          device: getDeviceName(),
          savedAt: new Date().toISOString(),
          data: cloneDeep(appData)
        };
        localStorage.setItem(AUTO_BACKUP_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('自動バックアップの保存に失敗しました', err);
      }
    };

    /*** modal api ***/
    const modalState = { activePromise: null, locked: false };

    const openModal = (buildContent, { cancelValue = null } = {}) => {
      if (modalState.locked) {
        return modalState.activePromise ?? Promise.resolve(cancelValue);
      }

      const body = document.body;
      const backdrop = createElem('div', { className: 'modal-backdrop' });
      const card = createElem('div', { className: 'modal-card relative' });
      backdrop.append(card);
      body.append(backdrop);
      body.classList.add('scroll-lock');

      modalState.locked = true;

      let resolvePromise;
      let rejectPromise;
      const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });

      modalState.activePromise = promise;

      let settled = false;
      let cleanupRan = false;

      const runCleanup = () => {
        if (cleanupRan) return;
        cleanupRan = true;
        document.removeEventListener('keydown', handleKeydown);
        backdrop.removeEventListener('click', handleOutsideClick);
        if (backdrop.parentNode) backdrop.remove();
        body.classList.remove('scroll-lock');
        modalState.activePromise = null;
        modalState.locked = false;
      };

      const finish = (value) => {
        if (settled) return;
        settled = true;
        runCleanup();
        resolvePromise(value);
      };

      const requestCancel = () => finish(cancelValue);

      const handleKeydown = (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          requestCancel();
        }
      };

      const handleOutsideClick = (event) => {
        if (event.target === backdrop) {
          requestCancel();
        }
      };

      const abortWithError = (error) => {
        if (settled) return;
        settled = true;
        runCleanup();
        rejectPromise(error);
      };

      document.addEventListener('keydown', handleKeydown);
      backdrop.addEventListener('click', handleOutsideClick);

      try {
        const { content, focus } = buildContent({ finish, cancel: requestCancel });
        if (content instanceof Node) {
          card.append(content);
        }
        if (typeof focus === 'function') {
          try {
            focus();
          } catch (focusError) {
            abortWithError(focusError);
          }
        }
      } catch (error) {
        abortWithError(error);
      }

      return promise;
    };

    const confirmAction = (message) => {
      return openModal(({ finish, cancel }) => {
        const header = createElem('div', { className: 'flex items-start justify-between gap-4 mb-4' });
        const closeBtn = createElem('button', {
          className: 'text-xl leading-none text-slate-400 hover:text-slate-700',
          textContent: '×',
          attrs: { type: 'button', 'aria-label': '閉じる' }
        });
        const requestCancel = () => cancel();
        closeBtn.addEventListener('click', requestCancel);
        header.append(
          createElem('p', { className: 'text-sm text-slate-800', textContent: message }),
          closeBtn
        );
        const btnWrap = createElem('div', { className: 'flex justify-end gap-2' });
        const cancelBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const okBtn = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'OK', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', requestCancel);
        okBtn.addEventListener('click', () => finish(true));
        btnWrap.append(cancelBtn, okBtn);
        const content = createElem('div', { children: [header, btnWrap] });
        return { content, focus: () => okBtn.focus() };
      }, { cancelValue: false }).then((value) => Boolean(value));
    };

    const pickFromList = (title, options) => {
      return openModal(({ finish, cancel }) => {
        const header = createElem('div', { className: 'mb-3 flex items-start justify-between gap-4' });
        const closeBtn = createElem('button', {
          className: 'text-xl leading-none text-slate-400 hover:text-slate-700',
          textContent: '×',
          attrs: { type: 'button', 'aria-label': '閉じる' }
        });
        const requestCancel = () => cancel();
        closeBtn.addEventListener('click', requestCancel);
        header.append(
          createElem('p', { className: 'text-sm font-semibold text-slate-800', textContent: title }),
          closeBtn
        );
        const list = createElem('div', { className: 'max-h-64 overflow-y-auto space-y-2' });
        options.forEach((opt) => {
          const btn = createElem('button', { className: 'w-full text-left px-3 py-2 rounded-lg border border-slate-200 hover:border-slate-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500', textContent: opt, attrs: { type: 'button' } });
          btn.addEventListener('click', () => finish(opt));
          list.append(btn);
        });
        const cancelBtn = createElem('button', { className: 'mt-4 btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', requestCancel);
        const firstButton = () => list.querySelector('button');
        const content = createElem('div', { children: [header, list, cancelBtn] });
        return { content, focus: () => { const btn = firstButton(); if (btn) btn.focus(); else cancelBtn.focus(); } };
      });
    };

    const promptText = (title) => {
      return openModal(({ finish, cancel }) => {
        const label = createElem('label', { className: 'flex flex-col gap-2' });
        label.append(
          createElem('span', { className: 'text-sm font-semibold text-slate-800', textContent: title }),
          createElem('input', { className: 'input-base', attrs: { type: 'text' } })
        );
        const actions = createElem('div', { className: 'flex justify-end gap-2 mt-4' });
        const cancelBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const ok = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: '決定', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', cancel);
        const input = label.querySelector('input');
        ok.addEventListener('click', () => finish(input.value.trim() || null));
        actions.append(cancelBtn, ok);
        const content = createElem('div', { children: [label, actions] });
        return { content, focus: () => input.focus() };
      });
    };

    const showImportReport = (title, issues) => {
      const messages = Array.isArray(issues) && issues.length ? issues : ['詳細情報が見つかりませんでした。'];
      const backup = readAutoBackupSnapshot();
      return openModal(({ finish }) => {
        const header = createElem('div', { className: 'mb-3 flex items-start justify-between gap-4' });
        const heading = createElem('p', { className: 'text-sm font-semibold text-slate-800', textContent: title });
        const closeBtn = createElem('button', {
          className: 'text-xl leading-none text-slate-400 hover:text-slate-700',
          textContent: '×',
          attrs: { type: 'button', 'aria-label': '閉じる' }
        });
        closeBtn.addEventListener('click', () => finish());
        header.append(heading, closeBtn);

        const list = createElem('ul', { className: 'list-disc space-y-1 pl-5 text-sm text-slate-700 max-h-56 overflow-y-auto pr-1' });
        messages.slice(0, 50).forEach((msg) => {
          list.append(createElem('li', { textContent: msg }));
        });
        if (messages.length > 50) {
          list.append(createElem('li', { className: 'text-xs text-slate-500', textContent: `...ほか ${messages.length - 50} 件` }));
        }

        const backupInfo = backup
          ? createElem('div', {
              className: 'mt-3 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600',
              textContent: `最新の自動バックアップ: schema ${backup.schemaVersion ?? '-'} / device ${backup.device || '不明'} / 保存 ${backup.savedAt ? formatDate(backup.savedAt) : '不明'}`
            })
          : createElem('p', { className: 'mt-3 text-xs text-slate-500', textContent: '自動バックアップ情報はまだありません。' });

        const footer = createElem('div', { className: 'mt-4 flex justify-end' });
        const okBtn = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: '閉じる', attrs: { type: 'button' } });
        okBtn.addEventListener('click', () => finish());
        footer.append(okBtn);

        const content = createElem('div', { children: [header, list, backupInfo, footer] });
        return { content, focus: () => okBtn.focus() };
      });
    };

    /*** data model ***/
    const STORAGE_KEYS = Object.freeze({
      DATA: 'data'
    });

    const createInitialData = () => ({
      workouts: [],
      currentWorkout: {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: []
      },
      settings: {
        unit: 'kg',
        exerciseCatalog: ['ベンチプレス', 'スクワット', 'デッドリフト']
      },
      historyView: {
        exerciseName: null
      }
    });

    const loadData = () => {
      const stored = storage.load(STORAGE_KEYS.DATA, createInitialData());
      const base = createInitialData();
      return { ...base, ...stored };
    };

    let appData = loadData();
    createAutoBackupSnapshot();

    const persist = () => {
      storage.save(STORAGE_KEYS.DATA, appData);
      createAutoBackupSnapshot();
    };

    const resetData = () => {
      appData = createInitialData();
      oneRmMemo.clear();
      persist();
    };

    /*** 1RM memoization ***/
    const oneRmMemo = new Map();
    const compute1RM = (weight, reps) => {
      const w = safeNumber(weight);
      const r = safeNumber(reps);
      if (w === null || r === null || r <= 0 || w <= 0) return null;
      return Number((w * (1 + r / 30)).toFixed(2));
    };

    const getExerciseKey = (workoutId, exerciseId) => `${workoutId}:${exerciseId}`;

    const recomputeExercise = (workoutId, exercise) => {
      const key = getExerciseKey(workoutId, exercise.id);
      const signature = exercise.sets.map((set) => `${set.weight ?? ''}|${set.reps ?? ''}`).join('::');
      const cached = oneRmMemo.get(key);
      if (cached && cached.signature === signature) {
        cached.values.forEach((val, idx) => {
          exercise.sets[idx].oneRM = val;
        });
        return;
      }
      const values = exercise.sets.map((set) => compute1RM(set.weight, set.reps));
      values.forEach((val, idx) => {
        exercise.sets[idx].oneRM = val;
      });
      oneRmMemo.set(key, { signature, values });
    };

    const recomputeAll = () => {
      appData.workouts.forEach((workout) => {
        workout.exercises.forEach((exercise) => recomputeExercise(workout.id, exercise));
      });
      appData.currentWorkout.exercises.forEach((exercise) => recomputeExercise(appData.currentWorkout.id, exercise));
    };
    recomputeAll();

    /*** router & state ***/
    const parseRoute = (hash) => {
      const normalized = (hash || '').trim();
      if (!normalized) return ROUTES.HOME;
      const matched = normalized.match(/^#\/?([a-z0-9_-]+)$/i);
      const route = matched ? matched[1].toLowerCase() : '';
      if (!route) return ROUTES.HOME;
      if (!ROUTE_VALUES.has(route)) return ROUTES.HOME;
      return route;
    };

    const buildHash = (route) => `#/${route}`;

    let appState = { route: parseRoute(location.hash) };
    let lastStableState = { ...appState };
    let suppressHashEvent = false;
    let renderQueued = false;

    const requestRender = () => {
      if (renderQueued) return;
      renderQueued = true;
      queueMicrotask(() => {
        renderQueued = false;
        render(appState);
      });
    };

    const syncHashToRoute = (route) => {
      const target = buildHash(route);
      if (location.hash !== target) {
        suppressHashEvent = true;
        location.hash = target;
      }
    };

    const applyRoute = (route) => {
      const normalized = ROUTE_VALUES.has(route) ? route : ROUTES.HOME;
      const previousState = { ...appState };
      const nextState = { ...appState, route: normalized };
      try {
        appState = nextState;
        render(appState);
        lastStableState = { ...appState };
        clearRecoverableError();
      } catch (err) {
        appState = previousState;
        syncHashToRoute(previousState.route);
        showRecoverableError(`画面の更新に失敗しました: ${err.message || err}`, () => {
          appState = { ...lastStableState };
          syncHashToRoute(lastStableState.route);
          render(appState);
        });
      }
    };

    const setHash = (route) => {
      const normalized = ROUTE_VALUES.has(route) ? route : ROUTES.HOME;
      const target = buildHash(normalized);
      if (location.hash === target) {
        applyRoute(normalized);
        return;
      }
      suppressHashEvent = true;
      location.hash = target;
      applyRoute(normalized);
    };

    window.addEventListener('hashchange', () => {
      if (suppressHashEvent) {
        suppressHashEvent = false;
        return;
      }
      const route = parseRoute(location.hash);
      applyRoute(route);
    });

    /*** chart manager ***/
    const createChartManager = (canvas) => {
      const chart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: '推定1RM',
            data: [],
            borderColor: '#1d4ed8',
            backgroundColor: 'rgba(29, 78, 216, 0.15)',
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { color: '#1f2937' } },
            y: {
              ticks: { color: '#1f2937' },
              beginAtZero: true
            }
          },
          plugins: {
            legend: { labels: { color: '#1f2937', font: { weight: '600' } } }
          }
        }
      });
      return {
        update(labels, values) {
          chart.data.labels = labels;
          chart.data.datasets[0].data = values;
          chart.update();
        }
      };
    };

    const HISTORY_ITEM_GAP = 16;
    const DEFAULT_HISTORY_ITEM_HEIGHT = 320;
    const HISTORY_VIRTUAL_OVERSCAN = 6;
    const historyHeightCache = new Map();
    let historyListScrollTop = 0;

    let historyChartCanvas = null;
    let historyChartManager = null;
    let historyChartObserver = null;
    let historyChartHost = null;
    let historyChartPendingData = { labels: [], values: [] };

    const applyHistoryChartData = () => {
      if (!historyChartManager || !historyChartPendingData) return;
      const { labels, values } = historyChartPendingData;
      historyChartManager.update(labels, values);
    };

    const ensureHistoryChartObserver = () => {
      if (historyChartObserver) return;
      historyChartObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          if (!historyChartCanvas) return;
          if (historyChartHost && entry.target !== historyChartHost) return;
          if (!historyChartManager) {
            historyChartManager = createChartManager(historyChartCanvas);
          }
          applyHistoryChartData();
          if (historyChartObserver && entry.target) {
            historyChartObserver.unobserve(entry.target);
          }
        });
      }, { threshold: 0.1 });
    };

    /*** render helpers ***/
    const appRoot = document.getElementById('app');

    const heading = createElem('h1', { className: 'mb-6 text-2xl font-bold text-slate-900', textContent: '筋トレメモ' });
    const viewContainer = createElem('div', { className: 'space-y-6' });
    const viewHosts = {
      [ROUTES.HOME]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.HOME } }),
      [ROUTES.HISTORY]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.HISTORY } }),
      [ROUTES.SETTINGS]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.SETTINGS } }),
      [ROUTES.WORKOUT]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.WORKOUT } })
    };
    Object.values(viewHosts).forEach((host) => {
      host.classList.add('hidden');
      viewContainer.append(host);
    });
    if (appRoot) {
      appRoot.append(heading, viewContainer);
    }

    const updateTabState = (activeRoute) => {
      document.querySelectorAll('.tab-button').forEach((tab) => {
        const route = tab.getAttribute('data-route');
        if (route === activeRoute) {
          tab.classList.add('text-blue-600', 'font-bold');
          tab.classList.remove('text-slate-800');
        } else {
          tab.classList.remove('text-blue-600', 'font-bold');
          tab.classList.add('text-slate-800');
        }
      });
    };

    const bindTabs = () => {
      document.querySelectorAll('.tab-button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const route = btn.getAttribute('data-route');
          if (ROUTE_VALUES.has(route)) setHash(route);
        });
      });
    };

    const createCard = (titleText, body) => {
      return createElem('section', {
        className: 'bg-white rounded-2xl shadow-sm border border-slate-200/70 p-5 mb-6',
        children: [
          createElem('header', { className: 'flex items-center justify-between mb-4', children: [
            createElem('h2', { className: 'text-lg font-bold text-slate-800', textContent: titleText })
          ] }),
          body
        ]
      });
    };

    /*** actions ***/
    const ensureExerciseCatalog = (name) => {
      if (!name) return;
      if (!appData.settings.exerciseCatalog.includes(name)) {
        appData.settings.exerciseCatalog.push(name);
      }
    };

    const addExercise = async () => {
      const catalog = [...appData.settings.exerciseCatalog];
      catalog.sort((a, b) => a.localeCompare(b, 'ja'));
      const choice = await pickFromList('種目を選択', [...catalog, '新規追加']);
      if (!choice) return;
      let exerciseName = choice;
      if (choice === '新規追加') {
        exerciseName = await promptText('新しい種目名');
        if (!exerciseName) return;
      }
      ensureExerciseCatalog(exerciseName);
      const newExercise = {
        id: `ex-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`,
        name: exerciseName,
        equipment: '',
        attachment: '',
        angle: null,
        position: '',
        performedOn: getTodayDateValue(),
        intervalSeconds: null,
        sets: [createEmptySet()]
      };
      appData.currentWorkout.exercises.push(newExercise);
      recomputeExercise(appData.currentWorkout.id, newExercise);
      persist();
      requestRender();
    };

    const createEmptySet = () => ({ weight: null, reps: null, oneRM: null, note: '' });

    const INPUT_BUFFER_DELAY = 300;
    const bufferedMutations = new Map();
    const bufferTimers = new Map();

    const handleCommitOutcome = (key, outcome) => {
      if (!outcome || typeof outcome !== 'object') {
        showValidationError('入力値を保存できませんでした。');
        return;
      }
      if (!outcome.success) {
        showValidationError(outcome.message || '入力値が正しくありません。');
        return;
      }
      bufferedMutations.delete(key);
      clearValidationError();
      if (outcome.rerender) {
        requestRender();
      }
    };

    const attemptBufferedCommit = (key) => {
      const entry = bufferedMutations.get(key);
      if (!entry) return;
      const { executor, value } = entry;
      try {
        const result = executor(value);
        if (result && typeof result.then === 'function') {
          result.then((resolved) => handleCommitOutcome(key, resolved)).catch((err) => {
            showValidationError(`保存処理でエラーが発生しました: ${err?.message || err}`);
          });
        } else {
          handleCommitOutcome(key, result);
        }
      } catch (err) {
        showValidationError(`保存処理でエラーが発生しました: ${err?.message || err}`);
      }
    };

    const scheduleBufferedCommit = (key, value, executor) => {
      bufferedMutations.set(key, { value, executor });
      if (bufferTimers.has(key)) {
        clearTimeout(bufferTimers.get(key));
      }
      const timer = setTimeout(() => {
        bufferTimers.delete(key);
        attemptBufferedCommit(key);
      }, INPUT_BUFFER_DELAY);
      bufferTimers.set(key, timer);
    };

    const commitSetField = (exerciseId, setIndex, field, rawValue) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) {
        return { success: false, message: '対象の種目が見つかりません。' };
      }
      const set = exercise.sets[setIndex];
      if (!set) {
        return { success: false, message: '対象のセットが見つかりません。' };
      }
      if (field === 'weight' || field === 'reps') {
        const num = safeNumber(rawValue);
        if (num === null) {
          const label = field === 'weight' ? '重量' : '回数';
          return { success: false, message: `${label}には数値を入力してください。` };
        }
        set[field] = num;
        recomputeExercise(appData.currentWorkout.id, exercise);
        persist();
        return { success: true, rerender: true };
      }
      if (field === 'note') {
        set[field] = typeof rawValue === 'string' ? rawValue : '';
        persist();
        return { success: true, rerender: false };
      }
      return { success: false, message: '不明なフィールドです。' };
    };

    const commitExerciseField = (exerciseId, field, rawValue) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) {
        return { success: false, message: '対象の種目が見つかりません。' };
      }
      if (field === 'angle' || field === 'intervalSeconds') {
        if (rawValue === '' || rawValue === null || rawValue === undefined) {
          exercise[field] = null;
          persist();
          return { success: true, rerender: false };
        }
        const num = safeNumber(rawValue);
        if (num === null) {
          const label = field === 'angle' ? '角度' : 'インターバル';
          return { success: false, message: `${label}には数値を入力してください。` };
        }
        exercise[field] = num;
        persist();
        return { success: true, rerender: false };
      }
      if (field === 'performedOn') {
        exercise[field] = rawValue || '';
        persist();
        return { success: true, rerender: false };
      }
      if (field === 'equipment' || field === 'attachment' || field === 'position') {
        exercise[field] = typeof rawValue === 'string' ? rawValue : '';
        persist();
        return { success: true, rerender: false };
      }
      return { success: false, message: '不明なフィールドです。' };
    };

    const scheduleSetFieldUpdate = (exerciseId, setIndex, field, value) => {
      const key = `set:${exerciseId}:${setIndex}:${field}`;
      scheduleBufferedCommit(key, value, (payload) => commitSetField(exerciseId, setIndex, field, payload));
    };

    const scheduleExerciseFieldUpdate = (exerciseId, field, value) => {
      const key = `exercise:${exerciseId}:${field}`;
      scheduleBufferedCommit(key, value, (payload) => commitExerciseField(exerciseId, field, payload));
    };

    const addSet = (exerciseId) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      exercise.sets.push(createEmptySet());
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
      requestRender();
    };

    const duplicateSet = (exerciseId, setIndex) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      const baseSet = exercise.sets[setIndex];
      if (!baseSet) return;
      const cloned = createEmptySet();
      cloned.weight = baseSet.weight;
      cloned.reps = baseSet.reps;
      cloned.note = baseSet.note;
      exercise.sets.splice(setIndex + 1, 0, cloned);
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
      requestRender();
    };

    const deleteExercise = async (exerciseId) => {
      if (!(await confirmAction('この種目を削除しますか？'))) return;
      appData.currentWorkout.exercises = appData.currentWorkout.exercises.filter((ex) => ex.id !== exerciseId);
      persist();
      requestRender();
    };

    const finishWorkout = async () => {
      if (!appData.currentWorkout.exercises.length) return;
      const confirmed = await confirmAction('現在のワークアウトを完了として保存しますか？');
      if (!confirmed) return;
      const workoutCopy = cloneDeep(appData.currentWorkout);
      workoutCopy.id = `wo-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`;
      workoutCopy.completedAt = Date.now();
      workoutCopy.exercises.forEach((exercise) => recomputeExercise(workoutCopy.id, exercise));
      appData.workouts.unshift(workoutCopy);
      appData.currentWorkout = {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: []
      };
      persist();
      requestRender();
    };

    const deleteWorkout = async (workoutId) => {
      const ok = await confirmAction('選択した履歴を削除しますか？');
      if (!ok) return;
      appData.workouts = appData.workouts.filter((wk) => wk.id !== workoutId);
      persist();
      requestRender();
    };

    const createHistoryWorkoutNode = (workout, workoutIndex, totalWorkouts) => {
      const item = createElem('article', { className: 'rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
      item.dataset.historyIndex = String(workoutIndex);
      const header = createElem('div', { className: 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between' });
      const timestamp = formatDate(workout.completedAt || workout.startedAt);
      header.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: timestamp }));
      const deleteBtn = createElem('button', {
        className: 'self-start text-xs font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500',
        textContent: '削除',
        attrs: { type: 'button' }
      });
      deleteBtn.addEventListener('click', () => deleteWorkout(workout.id));
      header.append(deleteBtn);
      item.append(header);

      workout.exercises.forEach((exercise) => {
        const exerciseBlock = createElem('div', { className: 'mt-4 space-y-3 rounded-xl border border-slate-200 bg-slate-50 p-4' });
        exerciseBlock.append(createElem('h4', { className: 'text-base font-bold text-slate-900', textContent: exercise.name }));
        const metaItems = [
          { label: '器具', value: exercise.equipment },
          { label: 'アタッチメント', value: exercise.attachment },
          { label: '角度 (°)', value: exercise.angle != null ? `${exercise.angle}°` : null },
          { label: 'スタンス / ポジション', value: exercise.position },
          { label: '実施日', value: exercise.performedOn },
          { label: 'インターバル (秒)', value: exercise.intervalSeconds != null ? `${exercise.intervalSeconds}秒` : null }
        ].filter((entry) => entry.value !== null && entry.value !== undefined && entry.value !== '');
        if (metaItems.length) {
          const metaList = createElem('ul', { className: 'grid grid-cols-1 gap-2 text-sm text-slate-800 sm:grid-cols-2' });
          metaItems.forEach(({ label, value }) => {
            const meta = createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 shadow-sm' });
            meta.append(
              createElem('p', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-800', textContent: label }),
              createElem('p', { className: 'text-sm font-medium text-slate-900', textContent: value })
            );
            metaList.append(meta);
          });
          exerciseBlock.append(metaList);
        }
        const setsList = createElem('ul', { className: 'space-y-2' });
        exercise.sets.forEach((set, index) => {
          const info = `#${index + 1} 重量: ${set.weight ?? '-'}${appData.settings.unit} / 回数: ${set.reps ?? '-'} / 推定1RM: ${set.oneRM ?? '-'}${set.note ? ' / ' + set.note : ''}`;
          setsList.append(createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-800 shadow-sm', textContent: info }));
        });
        const trendBtn = createElem('button', {
          className: 'text-xs font-semibold text-blue-700 underline decoration-dotted hover:text-blue-800',
          textContent: '推移を表示',
          attrs: { type: 'button' }
        });
        trendBtn.addEventListener('click', () => {
          appData.historyView.exerciseName = exercise.name;
          requestRender();
        });
        exerciseBlock.append(setsList, trendBtn);
        item.append(exerciseBlock);
      });

      if (workoutIndex !== totalWorkouts - 1) {
        item.style.marginBottom = `${HISTORY_ITEM_GAP}px`;
      }
      return item;
    };

    const createHistoryVirtualList = (workouts) => {
      const count = workouts.length;
      const viewport = createElem('div', { className: 'relative max-h-[70vh] overflow-y-auto' });
      const spacer = createElem('div', { className: 'relative w-full' });
      const inner = createElem('div', { className: 'absolute inset-x-0 top-0' });
      spacer.append(inner);
      viewport.append(spacer);

      if (!count) {
        spacer.style.height = '0px';
        historyListScrollTop = 0;
        return viewport;
      }

      const cachedHeights = Array.from(historyHeightCache.values());
      const averageHeight = cachedHeights.length
        ? Math.max(160, Math.round(cachedHeights.reduce((sum, value) => sum + value, 0) / cachedHeights.length))
        : DEFAULT_HISTORY_ITEM_HEIGHT;
      const itemHeights = workouts.map((workout) => {
        const cached = historyHeightCache.get(workout.id);
        return cached && cached > 0 ? cached : averageHeight;
      });
      const positions = new Array(count + 1).fill(0);
      for (let i = 0; i < count; i += 1) {
        const blockHeight = itemHeights[i] + (i === count - 1 ? 0 : HISTORY_ITEM_GAP);
        positions[i + 1] = positions[i] + blockHeight;
      }
      let totalHeight = positions[count];
      spacer.style.height = `${totalHeight}px`;

      let renderedStart = -1;
      let renderedEnd = -1;
      let measurementScheduled = false;

      const recomputePositions = (startIndex = 0) => {
        if (startIndex < 0) startIndex = 0;
        for (let i = startIndex; i < count; i += 1) {
          const blockHeight = itemHeights[i] + (i === count - 1 ? 0 : HISTORY_ITEM_GAP);
          positions[i + 1] = positions[i] + blockHeight;
        }
        totalHeight = positions[count];
        spacer.style.height = `${totalHeight}px`;
      };

      const measureRenderedItems = () => {
        let changedFrom = count;
        Array.from(inner.children).forEach((child) => {
          const index = Number(child.dataset.historyIndex);
          if (!Number.isFinite(index)) return;
          const rect = child.getBoundingClientRect();
          const measured = Math.max(0, Math.round(rect.height));
          if (!measured || Math.abs(measured - itemHeights[index]) <= 1) return;
          itemHeights[index] = measured;
          historyHeightCache.set(workouts[index].id, measured);
          if (index < changedFrom) changedFrom = index;
        });
        if (changedFrom < count) {
          recomputePositions(changedFrom);
          renderedStart = -1;
          renderViewport();
        }
      };

      const scheduleMeasurement = () => {
        if (measurementScheduled) return;
        measurementScheduled = true;
        requestAnimationFrame(() => {
          measurementScheduled = false;
          measureRenderedItems();
        });
      };

      const renderViewport = () => {
        const scrollTop = viewport.scrollTop;
        const viewportHeight = viewport.clientHeight || 1;
        let start = 0;
        while (start < count && positions[start + 1] <= scrollTop) {
          start += 1;
        }
        start = Math.max(0, start - HISTORY_VIRTUAL_OVERSCAN);
        let end = start;
        const targetBottom = scrollTop + viewportHeight;
        while (end < count && positions[end] < targetBottom) {
          end += 1;
        }
        end = Math.min(count, end + HISTORY_VIRTUAL_OVERSCAN);
        if (end <= start) {
          end = Math.min(count, start + 1);
        }
        if (start === renderedStart && end === renderedEnd) return;
        renderedStart = start;
        renderedEnd = end;
        const fragment = document.createDocumentFragment();
        for (let index = start; index < end; index += 1) {
          fragment.append(createHistoryWorkoutNode(workouts[index], index, count));
        }
        inner.style.transform = `translateY(${positions[start]}px)`;
        inner.replaceChildren(fragment);
        scheduleMeasurement();
      };

      const handleScroll = () => {
        historyListScrollTop = viewport.scrollTop;
        renderViewport();
      };
      viewport.addEventListener('scroll', handleScroll, { passive: true });

      setTimeout(() => {
        const maxScroll = Math.max(totalHeight - viewport.clientHeight, 0);
        const target = Math.min(historyListScrollTop, maxScroll);
        if (Number.isFinite(target)) {
          viewport.scrollTop = target;
        }
        renderViewport();
      }, 0);

      return viewport;
    };

    const clearAllData = async () => {
      const ok = await confirmAction('すべてのデータを初期化します。よろしいですか？');
      if (!ok) return;
      storage.clearNamespace();
      resetData();
      requestRender();
    };

    const changeUnit = (unit) => {
      appData.settings.unit = unit;
      persist();
      requestRender();
    };

    const exportData = () => {
      const baseMeta = {
        schemaVersion: SCHEMA_VERSION,
        device: getDeviceName(),
        exportedAt: new Date().toISOString()
      };
      const rows = [];
      const pushRow = (data) => {
        const row = createCsvRow();
        Object.assign(row, baseMeta, data);
        rows.push(row);
      };

      pushRow({ recordType: CSV_RECORD_TYPES.META });
      pushRow({ recordType: CSV_RECORD_TYPES.SETTINGS, unit: appData.settings.unit });
      appData.settings.exerciseCatalog.forEach((entry) => {
        pushRow({
          recordType: CSV_RECORD_TYPES.CATALOG,
          catalogEntry: entry,
          exercise: entry
        });
      });
      pushRow({
        recordType: CSV_RECORD_TYPES.HISTORY_VIEW,
        exercise: appData.historyView.exerciseName ?? ''
      });

      const workoutDateValue = (workout, exercise) => {
        if (exercise?.performedOn) return exercise.performedOn;
        if (workout?.completedAt) return workout.completedAt;
        if (workout?.startedAt) return workout.startedAt;
        return '';
      };

      const addWorkoutRows = (workout, state, order) => {
        if (!workout || !workout.id) return;
        pushRow({
          recordType: CSV_RECORD_TYPES.WORKOUT,
          workoutState: state,
          workoutId: workout.id,
          workoutStartedAt: workout.startedAt ?? '',
          workoutCompletedAt: workout.completedAt ?? '',
          workoutOrder: order,
          date: workoutDateValue(workout)
        });
        workout.exercises.forEach((exercise) => {
          pushRow({
            recordType: CSV_RECORD_TYPES.EXERCISE,
            workoutState: state,
            workoutId: workout.id,
            exerciseId: exercise.id,
            exercise: exercise.name ?? '',
            equipment: exercise.equipment ?? '',
            attachment: exercise.attachment ?? '',
            angle: exercise.angle ?? '',
            position: exercise.position ?? '',
            performedOn: exercise.performedOn ?? '',
            intervalSeconds: exercise.intervalSeconds ?? '',
            date: workoutDateValue(workout, exercise)
          });
          exercise.sets.forEach((set, index) => {
            pushRow({
              recordType: CSV_RECORD_TYPES.SET,
              workoutState: state,
              workoutId: workout.id,
              exerciseId: exercise.id,
              setIndex: index,
              setType: 'standard',
              weight: set.weight ?? '',
              reps: set.reps ?? '',
              oneRM: set.oneRM ?? '',
              note: set.note ?? '',
              unit: appData.settings.unit,
              date: workoutDateValue(workout, exercise)
            });
          });
        });
      };

      appData.workouts.forEach((workout, index) => addWorkoutRows(workout, 'history', index));
      addWorkoutRows(appData.currentWorkout, 'current', 'current');

      const csv = serializeCsvRows(rows);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const timestamp = baseMeta.exportedAt.replace(/[-:]/g, '').replace(/\..*$/, '');
      const fileName = `muscle-app-export-${timestamp || Date.now()}.csv`;
      const url = URL.createObjectURL(blob);
      const link = createElem('a', { attrs: { href: url, download: fileName } });
      document.body.append(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    };

    const restoreAppDataFromCsv = (rows) => {
      const issues = [];
      const group = rows.reduce((acc, row) => {
        const type = row.recordType || '';
        if (!acc[type]) acc[type] = [];
        acc[type].push(row);
        return acc;
      }, {});

      const metaRow = (group[CSV_RECORD_TYPES.META] || [])[0];
      if (!metaRow) {
        issues.push('meta 行が見つかりません。');
      }
      const schemaValue = metaRow ? toIntegerOrNull(metaRow.schemaVersion) : null;
      if (schemaValue === null) {
        issues.push('SCHEMA_VERSION が解釈できません。');
      } else if (schemaValue !== SCHEMA_VERSION) {
        issues.push(`SCHEMA_VERSION が一致しません (期待: ${SCHEMA_VERSION} / 実際: ${schemaValue}).`);
      }

      const settingsRow = (group[CSV_RECORD_TYPES.SETTINGS] || [])[0];
      if (!settingsRow) {
        issues.push('settings 行が不足しています。');
      }
      const unit = (settingsRow?.unit || '').trim();
      const allowedUnits = new Set(['kg', 'lb']);
      if (!unit) {
        issues.push('単位 (unit) が指定されていません。');
      } else if (!allowedUnits.has(unit)) {
        issues.push(`サポートされていない単位です: ${unit}`);
      }

      const catalogEntries = (group[CSV_RECORD_TYPES.CATALOG] || []).map((row) => (row.catalogEntry || '').trim()).filter((entry) => entry);
      const historyViewRow = (group[CSV_RECORD_TYPES.HISTORY_VIEW] || [])[0];
      const historyExerciseName = historyViewRow && historyViewRow.exercise && historyViewRow.exercise.trim()
        ? historyViewRow.exercise.trim()
        : null;

      const workoutContainers = new Map();
      const exerciseContainers = new Map();
      const historyWorkouts = [];
      let currentWorkoutContainer = null;

      const workoutRows = group[CSV_RECORD_TYPES.WORKOUT] || [];
      workoutRows.forEach((row) => {
        const line = row.__line || '?';
        const state = (row.workoutState || '').trim();
        if (!state) {
          issues.push(`行${line}: workoutState が空です。`);
          return;
        }
        if (state !== 'history' && state !== 'current') {
          issues.push(`行${line}: 未対応の workoutState '${state}' です。`);
          return;
        }
        const workoutId = (row.workoutId || '').trim();
        if (!workoutId) {
          issues.push(`行${line}: workoutId がありません。`);
          return;
        }
        const startedAtRaw = row.workoutStartedAt;
        const startedAt = toIntegerOrNull(startedAtRaw);
        if (startedAt === null) {
          issues.push(`行${line}: workoutStartedAt が数値ではありません。`);
        }
        const completedAtRaw = row.workoutCompletedAt;
        let completedAt = null;
        if (completedAtRaw && String(completedAtRaw).trim()) {
          const parsed = toIntegerOrNull(completedAtRaw);
          if (parsed === null) {
            issues.push(`行${line}: workoutCompletedAt が数値ではありません。`);
          } else {
            completedAt = parsed;
          }
        }
        const orderRaw = row.workoutOrder;
        let orderValue = null;
        if (state === 'history') {
          const parsedOrder = toIntegerOrNull(orderRaw);
          if (parsedOrder === null) {
            issues.push(`行${line}: workoutOrder が数値ではありません。`);
          } else {
            orderValue = parsedOrder;
          }
        }
        const key = `${state}:${workoutId}`;
        if (workoutContainers.has(key)) {
          issues.push(`行${line}: workoutId '${workoutId}' が重複しています。`);
          return;
        }
        const workout = {
          id: workoutId,
          startedAt: startedAt ?? Date.now(),
          completedAt: completedAt,
          exercises: []
        };
        const container = { workout, state, order: orderValue ?? Number.MAX_SAFE_INTEGER, line };
        workoutContainers.set(key, container);
        if (state === 'history') {
          historyWorkouts.push(container);
        } else if (state === 'current') {
          currentWorkoutContainer = container;
        }
      });

      const exerciseRows = group[CSV_RECORD_TYPES.EXERCISE] || [];
      exerciseRows.forEach((row) => {
        const line = row.__line || '?';
        const state = (row.workoutState || '').trim();
        if (!state) {
          issues.push(`行${line}: workoutState が空です。`);
          return;
        }
        const workoutId = (row.workoutId || '').trim();
        if (!workoutId) {
          issues.push(`行${line}: workoutId がありません。`);
          return;
        }
        const key = `${state}:${workoutId}`;
        const workoutContainer = workoutContainers.get(key);
        if (!workoutContainer) {
          issues.push(`行${line}: 対応するワークアウト (${key}) が見つかりません。`);
          return;
        }
        const exerciseId = (row.exerciseId || '').trim();
        if (!exerciseId) {
          issues.push(`行${line}: exerciseId がありません。`);
          return;
        }
        const angleRaw = row.angle;
        const angle = toNumberOrNull(angleRaw);
        if (angleRaw && String(angleRaw).trim() && angle === null) {
          issues.push(`行${line}: angle が数値ではありません。`);
        }
        const intervalRaw = row.intervalSeconds;
        const intervalSeconds = toNumberOrNull(intervalRaw);
        if (intervalRaw && String(intervalRaw).trim() && intervalSeconds === null) {
          issues.push(`行${line}: intervalSeconds が数値ではありません。`);
        }
        const exercise = {
          id: exerciseId,
          name: row.exercise || '',
          equipment: row.equipment || '',
          attachment: row.attachment || '',
          angle: angle === null ? null : angle,
          position: row.position || '',
          performedOn: row.performedOn || '',
          intervalSeconds: intervalSeconds === null ? null : intervalSeconds,
          sets: []
        };
        workoutContainer.workout.exercises.push(exercise);
        const exerciseKey = `${key}:${exerciseId}`;
        exerciseContainers.set(exerciseKey, { exercise, line });
      });

      const setRows = group[CSV_RECORD_TYPES.SET] || [];
      setRows.forEach((row) => {
        const line = row.__line || '?';
        const state = (row.workoutState || '').trim();
        if (!state) {
          issues.push(`行${line}: workoutState が空です。`);
          return;
        }
        const workoutId = (row.workoutId || '').trim();
        if (!workoutId) {
          issues.push(`行${line}: workoutId がありません。`);
          return;
        }
        const exerciseId = (row.exerciseId || '').trim();
        if (!exerciseId) {
          issues.push(`行${line}: exerciseId がありません。`);
          return;
        }
        const exerciseKey = `${state}:${workoutId}:${exerciseId}`;
        const container = exerciseContainers.get(exerciseKey);
        if (!container) {
          issues.push(`行${line}: exerciseId '${exerciseId}' に対応する種目が見つかりません。`);
          return;
        }
        const setIndex = toIntegerOrNull(row.setIndex);
        if (setIndex === null || setIndex < 0) {
          issues.push(`行${line}: setIndex が不正です。`);
          return;
        }
        const setType = (row.setType || '').trim();
        if (!CSV_ALLOWED_SET_TYPES.has(setType)) {
          issues.push(`行${line}: 未対応の setType '${setType}' です。`);
        }
        if (row.unit && unit && row.unit !== unit) {
          issues.push(`行${line}: 単位が一致しません (期待: ${unit} / 実際: ${row.unit})。`);
        }
        const weight = toNumberOrNull(row.weight);
        if (row.weight && String(row.weight).trim() && weight === null) {
          issues.push(`行${line}: weight が数値ではありません。`);
        }
        const reps = toNumberOrNull(row.reps);
        if (row.reps && String(row.reps).trim()) {
          if (reps === null) {
            issues.push(`行${line}: reps が数値ではありません。`);
          } else if (!Number.isInteger(reps)) {
            issues.push(`行${line}: reps は整数である必要があります。`);
          }
        }
        const oneRM = toNumberOrNull(row.oneRM);
        if (row.oneRM && String(row.oneRM).trim() && oneRM === null) {
          issues.push(`行${line}: oneRM が数値ではありません。`);
        }
        const targetSets = container.exercise.sets;
        if (!targetSets[setIndex]) {
          targetSets[setIndex] = {
            weight: weight === null ? null : weight,
            reps: reps === null ? null : reps,
            oneRM: oneRM === null ? null : oneRM,
            note: row.note != null ? String(row.note) : ''
          };
        } else {
          issues.push(`行${line}: setIndex ${setIndex} が重複しています。`);
        }
      });

      exerciseContainers.forEach(({ exercise, line }) => {
        for (let idx = 0; idx < exercise.sets.length; idx += 1) {
          if (!exercise.sets[idx]) {
            issues.push(`行${line}: セット #${idx} のデータが不足しています。`);
            exercise.sets.splice(idx, 1);
            idx -= 1;
          }
        }
      });

      if (!currentWorkoutContainer) {
        issues.push('現在のワークアウト情報が不足しています。');
      }

      historyWorkouts.sort((a, b) => {
        if (a.order === b.order) return a.line - b.line;
        return a.order - b.order;
      });

      const base = createInitialData();
      const data = {
        workouts: historyWorkouts.map((item) => item.workout),
        currentWorkout: currentWorkoutContainer ? currentWorkoutContainer.workout : base.currentWorkout,
        settings: {
          ...base.settings,
          unit: unit || base.settings.unit,
          exerciseCatalog: catalogEntries.length ? catalogEntries : base.settings.exerciseCatalog
        },
        historyView: {
          exerciseName: historyExerciseName
        }
      };

      return { issues, data };
    };

    const importData = async (file) => {
      if (!file) return;
      try {
        const text = await file.text();
        const parsedRows = parseCsvContent(text);
        if (parsedRows.__unclosedQuote) {
          const line = parsedRows.__lineNumber || '?';
          showImportReport('CSVの解析に失敗しました', [`行${line}: クォートが正しく閉じられていません。`]);
          return;
        }
        if (!parsedRows.length) {
          showImportReport('インポートを中止しました', ['CSVにデータが含まれていません。']);
          return;
        }
        const header = parsedRows.shift();
        const headerIssues = validateCsvHeader(header);
        if (headerIssues.length) {
          showImportReport('ヘッダーが一致しません', headerIssues);
          return;
        }
        const rowLengthIssues = [];
        const rows = [];
        parsedRows.forEach((cells, index) => {
          if (cells.length !== header.length) {
            rowLengthIssues.push(`行${index + 2}: 列数が ${cells.length} 列です (期待: ${header.length} 列)。`);
            return;
          }
          const row = createCsvRow();
          header.forEach((col, colIndex) => {
            row[col] = cells[colIndex] ?? '';
          });
          row.__line = index + 2;
          rows.push(row);
        });
        if (rowLengthIssues.length) {
          showImportReport('列数が一致しません', rowLengthIssues);
          return;
        }
        const { issues, data } = restoreAppDataFromCsv(rows);
        if (issues.length) {
          showImportReport('インポートを中止しました', issues);
          return;
        }
        oneRmMemo.clear();
        appData = data;
        recomputeAll();
        persist();
        requestRender();
      } catch (err) {
        pushError(`読み込みに失敗しました: ${err?.message || err}`);
      }
    };

    /*** route renderers ***/
    const buildHomeView = () => {
      const nodes = [];
      const workout = appData.currentWorkout;
      const cardBody = createElem('div', { className: 'space-y-6' });
      const headerInfo = createElem('p', {
        className: 'rounded-xl border border-slate-300 bg-slate-50 px-4 py-3 text-sm text-slate-800',
        textContent: `開始: ${formatDate(workout.startedAt)}`
      });
      cardBody.append(headerInfo);
      if (!workout.exercises.length) {
        cardBody.append(createElem('p', { className: 'text-sm leading-relaxed text-slate-800', textContent: '種目を追加して記録を開始しましょう。' }));
      } else {
        workout.exercises.forEach((exercise) => {
          const exCard = createElem('section', { className: 'space-y-5 rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
          const exHeader = createElem('div', { className: 'flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between' });
          exHeader.append(createElem('h3', { className: 'text-lg font-bold text-slate-900', textContent: exercise.name }));
          const deleteBtn = createElem('button', { className: 'self-start text-sm font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500', textContent: '削除', attrs: { type: 'button' } });
          deleteBtn.addEventListener('click', () => deleteExercise(exercise.id));
          exHeader.append(deleteBtn);
          exCard.append(exHeader);

          const metaPanel = createElem('div', { className: 'space-y-4 rounded-xl border border-slate-200 bg-slate-50 p-4' });
          const equipmentRow = createElem('div', { className: 'grid grid-cols-1 gap-4 sm:grid-cols-2' });
          const equipmentInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'text', autocomplete: 'off', placeholder: '例: バーベル' }, value: exercise.equipment ?? '' });
          equipmentInput.addEventListener('input', (event) => {
            scheduleExerciseFieldUpdate(exercise.id, 'equipment', event.target.value);
          });
          const equipmentField = createFieldWrapper('器具', '使用した器具を入力します。', '使用した器具の種類を記録しましょう。', equipmentInput);
          const attachmentInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'text', autocomplete: 'off', placeholder: '例: ワイドグリップ' }, value: exercise.attachment ?? '' });
          attachmentInput.addEventListener('input', (event) => {
            scheduleExerciseFieldUpdate(exercise.id, 'attachment', event.target.value);
          });
          const attachmentField = createFieldWrapper('アタッチメント', '利用したアタッチメントを記録します。', 'ケーブルハンドルなどをメモできます。', attachmentInput);
          equipmentRow.append(equipmentField, attachmentField);
          metaPanel.append(equipmentRow);

          const angleRow = createElem('div', { className: 'grid grid-cols-1 gap-4 sm:grid-cols-2' });
          const angleInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'decimal', min: '0', max: '180', step: '1', placeholder: '例: 30' }, value: exercise.angle ?? '' });
          angleInput.addEventListener('input', (event) => {
            scheduleExerciseFieldUpdate(exercise.id, 'angle', event.target.value);
          });
          const angleField = createFieldWrapper('角度 (°)', 'ベンチやマシンの角度を記録します。', '角度の変化を記録してフォームを比較。', angleInput);
          const positionInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'text', autocomplete: 'off', placeholder: '例: ナロー・スタンス' }, value: exercise.position ?? '' });
          positionInput.addEventListener('input', (event) => {
            scheduleExerciseFieldUpdate(exercise.id, 'position', event.target.value);
          });
          const positionField = createFieldWrapper('スタンス / ポジション', '足幅やグリップ幅などを記録します。', 'スタンスやポジションの工夫を書き残しましょう。', positionInput);
          angleRow.append(angleField, positionField);
          metaPanel.append(angleRow);

          const scheduleRow = createElem('div', { className: 'grid grid-cols-1 gap-4 sm:grid-cols-2' });
          const performedOnInput = createElem('input', { className: 'input-base text-slate-900', attrs: { type: 'date', min: '2000-01-01', max: '2099-12-31', step: '1' }, value: exercise.performedOn ?? '' });
          performedOnInput.addEventListener('input', (event) => {
            scheduleExerciseFieldUpdate(exercise.id, 'performedOn', event.target.value);
          });
          const performedOnField = createFieldWrapper('実施日', 'トレーニングを行った日付です。', '後から見返すために日付を残せます。', performedOnInput);
          const intervalInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'numeric', min: '0', max: '600', step: '5', placeholder: '例: 90' }, value: exercise.intervalSeconds ?? '' });
          intervalInput.addEventListener('input', (event) => {
            scheduleExerciseFieldUpdate(exercise.id, 'intervalSeconds', event.target.value);
          });
          const intervalField = createFieldWrapper('インターバル (秒)', 'セット間の休憩秒数を記録します。', 'タイマーで計測した秒数を入力。', intervalInput);
          scheduleRow.append(performedOnField, intervalField);
          metaPanel.append(scheduleRow);
          exCard.append(metaPanel);

          const table = createElem('div', { className: 'space-y-4' });
          exercise.sets.forEach((set, index) => {
            const row = createElem('div', { className: 'grid grid-cols-1 sm:grid-cols-4 gap-4 items-start rounded-xl border border-slate-200 bg-white p-4 shadow-sm', attrs: { title: '長押しでこのセットを複製できます' } });
            registerLongPress(row, () => duplicateSet(exercise.id, index));
            const weightInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'decimal', min: '0', step: '0.5' }, value: set.weight ?? '' });
            weightInput.addEventListener('input', (event) => {
              scheduleSetFieldUpdate(exercise.id, index, 'weight', event.target.value);
            });
            const weightField = createFieldWrapper(`重量 (${appData.settings.unit})`, 'このセットで扱った重量です。', '小数点も入力できます。', weightInput);
            const repsInput = createElem('input', { className: 'input-base text-slate-900 placeholder-slate-400', attrs: { type: 'number', inputmode: 'numeric', min: '0', step: '1' }, value: set.reps ?? '' });
            repsInput.addEventListener('input', (event) => {
              scheduleSetFieldUpdate(exercise.id, index, 'reps', event.target.value);
            });
            const repsField = createFieldWrapper('回数', '完了した反復回数を入力します。', '失敗した場合は実際の回数を。', repsInput);
            const noteInput = createElem('textarea', { className: 'input-base min-h-[3rem] text-slate-900 placeholder-slate-400', attrs: { rows: '2', placeholder: 'フォームや感覚をメモ' }, textContent: set.note || '' });
            noteInput.addEventListener('input', (event) => {
              scheduleSetFieldUpdate(exercise.id, index, 'note', event.target.value);
            });
            const noteField = createFieldWrapper('セットメモ', '気づいたことや次回の課題を記録します。', 'フォームやRPEを自由に入力。', noteInput);
            noteField.classList.add('sm:col-span-2');
            const oneRmLabel = createElem('p', { className: 'sm:col-span-4 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-sm font-medium text-slate-800', textContent: set.oneRM ? `推定1RM: ${set.oneRM} ${appData.settings.unit}` : '推定1RM: -' });
            row.append(weightField, repsField, noteField, oneRmLabel);
            table.append(row);
          });
          const addSetBtn = createElem('button', { className: 'btn-muted mt-2 inline-flex items-center justify-center rounded-lg border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100', textContent: 'セットを追加', attrs: { type: 'button' } });
          addSetBtn.addEventListener('click', () => addSet(exercise.id));
          exCard.append(table, addSetBtn);
          cardBody.append(exCard);
        });
      }
      const actions = createElem('div', { className: 'flex flex-col gap-3 sm:flex-row' });
      const addExerciseBtn = createElem('button', { className: 'btn-primary flex-1 rounded-xl px-4 py-3 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500', textContent: '種目を追加', attrs: { type: 'button' } });
      addExerciseBtn.addEventListener('click', addExercise);
      const finishBtn = createElem('button', { className: 'btn-muted flex-1 rounded-xl border border-slate-300 px-4 py-3 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500', textContent: '完了して履歴へ', attrs: { type: 'button' } });
      finishBtn.addEventListener('click', finishWorkout);
      actions.append(addExerciseBtn, finishBtn);
      cardBody.append(actions);
      nodes.push(createCard('現在のワークアウト', cardBody));
      return nodes;
    };

    const buildHistoryView = () => {
      const nodes = [];
      const cardBody = createElem('div', { className: 'space-y-6' });
      if (!appData.workouts.length) {
        historyListScrollTop = 0;
        cardBody.append(createElem('p', { className: 'text-sm text-slate-800', textContent: '履歴はまだありません。' }));
      } else {
        cardBody.append(createHistoryVirtualList(appData.workouts));
      }

      if (!historyChartCanvas) {
        historyChartCanvas = createElem('canvas');
      }
      const chartContainer = createElem('div', { className: 'mt-6 h-64 relative' });
      chartContainer.append(historyChartCanvas);
      cardBody.append(chartContainer);

      if (historyChartObserver && historyChartHost && historyChartHost !== chartContainer) {
        historyChartObserver.unobserve(historyChartHost);
      }
      historyChartHost = chartContainer;

      const exerciseName = appData.historyView.exerciseName;
      if (exerciseName) {
        const dataset = [];
        appData.workouts.slice().reverse().forEach((workout) => {
          workout.exercises
            .filter((ex) => ex.name === exerciseName)
            .forEach((exercise) => {
              const best = Math.max(...exercise.sets.map((set) => Number(set.oneRM) || 0));
              dataset.push({ date: workout.completedAt || workout.startedAt, value: best });
            });
        });
        historyChartPendingData = {
          labels: dataset.map((d) => formatDate(d.date)),
          values: dataset.map((d) => d.value)
        };
      } else {
        historyChartPendingData = { labels: [], values: [] };
      }

      if (historyChartManager) {
        applyHistoryChartData();
      } else {
        ensureHistoryChartObserver();
        if (historyChartObserver) {
          historyChartObserver.observe(chartContainer);
        }
      }

      nodes.push(createCard('ワークアウト履歴', cardBody));
      return nodes;
    };

    const buildWorkoutView = () => {
      const nodes = [];
      const cardBody = createElem('div', { className: 'space-y-6' });
      if (!appData.workouts.length) {
        cardBody.append(createElem('p', { className: 'text-sm text-slate-800', textContent: '保存済みのワークアウトはありません。' }));
      } else {
        const latest = appData.workouts[0];
        cardBody.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: `最新の完了日時: ${formatDate(latest.completedAt || latest.startedAt)}` }));
        latest.exercises.forEach((exercise) => {
          const block = createElem('div', { className: 'space-y-3 rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
          block.append(createElem('h3', { className: 'text-base font-bold text-slate-900', textContent: exercise.name }));
          const metaItems = [
            { label: '器具', value: exercise.equipment },
            { label: 'アタッチメント', value: exercise.attachment },
            { label: '角度 (°)', value: exercise.angle != null ? `${exercise.angle}°` : null },
            { label: 'スタンス / ポジション', value: exercise.position },
            { label: '実施日', value: exercise.performedOn },
            { label: 'インターバル (秒)', value: exercise.intervalSeconds != null ? `${exercise.intervalSeconds}秒` : null }
          ].filter((item) => item.value !== null && item.value !== undefined && item.value !== '');
          if (metaItems.length) {
            const metaList = createElem('ul', { className: 'grid grid-cols-1 gap-2 text-sm text-slate-800 sm:grid-cols-2' });
            metaItems.forEach(({ label, value }) => {
              const meta = createElem('li', { className: 'rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 shadow-sm' });
              meta.append(
                createElem('p', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-800', textContent: label }),
                createElem('p', { className: 'text-sm font-medium text-slate-900', textContent: value })
              );
              metaList.append(meta);
            });
            block.append(metaList);
          }
          const list = createElem('ul', { className: 'space-y-2' });
          exercise.sets.forEach((set, idx) => {
            list.append(createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-800 shadow-sm', textContent: `#${idx + 1} 重量:${set.weight ?? '-'}${appData.settings.unit} / 回数:${set.reps ?? '-'} / 推定1RM:${set.oneRM ?? '-'}` }));
          });
          block.append(list);
          cardBody.append(block);
        });
      }
      nodes.push(createCard('最新のワークアウト', cardBody));
      return nodes;
    };

    const buildSettingsView = () => {
      const nodes = [];
      const cardBody = createElem('div', { className: 'space-y-6' });
      const unitSection = createElem('div', { className: 'space-y-3' });
      unitSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '単位設定' }));
      const unitOptions = ['kg', 'lb'];
      const unitWrap = createElem('div', { className: 'flex gap-3' });
      unitOptions.forEach((unit) => {
        const label = createElem('label', { className: 'inline-flex items-center gap-2 text-sm text-slate-800 font-semibold' });
        const input = createElem('input', { attrs: { type: 'radio', name: 'unit', value: unit } });
        if (appData.settings.unit === unit) input.checked = true;
        input.addEventListener('change', () => changeUnit(unit));
        label.append(input, createElem('span', { textContent: unit }));
        unitWrap.append(label);
      });
      unitSection.append(unitWrap);
      cardBody.append(unitSection);

      const catalogSection = createElem('div', { className: 'space-y-3' });
      catalogSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '登録済み種目' }));
      const list = createElem('ul', { className: 'space-y-2' });
      appData.settings.exerciseCatalog.forEach((name) => {
        list.append(createElem('li', { className: 'text-sm text-slate-800 px-3 py-2 bg-slate-100 rounded-lg border border-slate-200', textContent: name }));
      });
      catalogSection.append(list);
      cardBody.append(catalogSection);

      const importExportSection = createElem('div', { className: 'space-y-3' });
      importExportSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: 'バックアップ' }));
      const exportBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'エクスポート', attrs: { type: 'button' } });
      exportBtn.addEventListener('click', exportData);
      const importLabel = createElem('label', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold inline-flex items-center justify-center gap-2 w-fit cursor-pointer' });
      importLabel.append(createElem('span', { textContent: 'インポート' }));
      const input = createElem('input', { attrs: { type: 'file', accept: '.csv,text/csv' } });
      input.classList.add('hidden');
      input.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        importData(file);
        event.target.value = '';
      });
      importLabel.append(input);
      importExportSection.append(createElem('div', { className: 'flex gap-3', children: [exportBtn, importLabel] }));
      cardBody.append(importExportSection);

      const dangerSection = createElem('div', { className: 'space-y-3' });
      dangerSection.append(createElem('h3', { className: 'text-base font-semibold text-red-700', textContent: 'データ初期化' }));
      const clearBtn = createElem('button', { className: 'bg-red-700 hover:bg-red-800 text-white px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'すべて削除', attrs: { type: 'button' } });
      clearBtn.addEventListener('click', clearAllData);
      dangerSection.append(clearBtn);
      cardBody.append(dangerSection);

      nodes.push(createCard('設定', cardBody));
      return nodes;
    };

    const viewBuilders = {
      [ROUTES.HOME]: buildHomeView,
      [ROUTES.HISTORY]: buildHistoryView,
      [ROUTES.SETTINGS]: buildSettingsView,
      [ROUTES.WORKOUT]: buildWorkoutView
    };

    const render = (state) => {
      if (!appRoot) return;
      const route = ROUTE_VALUES.has(state.route) ? state.route : ROUTES.HOME;
      updateTabState(route);
      Object.entries(viewHosts).forEach(([key, host]) => {
        if (key === route) {
          host.classList.remove('hidden');
        } else {
          host.classList.add('hidden');
        }
      });
      const builder = viewBuilders[route] || viewBuilders[ROUTES.HOME];
      const result = builder ? builder() : [];
      const nodes = Array.isArray(result) ? result : (result ? [result] : []);
      const host = viewHosts[route] || viewHosts[ROUTES.HOME];
      host.replaceChildren(...nodes);
    };

    /*** bootstrap ***/
    bindTabs();
    syncHashToRoute(appState.route);
    try {
      render(appState);
      lastStableState = { ...appState };
    } catch (err) {
      pushError(`初期化に失敗しました: ${err.message || err}`);
    }
  })();
  </script>
</body>
</html>
