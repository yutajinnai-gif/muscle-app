<!DOCTYPE html>
<html lang="ja" class="bg-slate-100">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BUILD_TAG=FIX-20251002-SYNTAX-5378</title>
  <meta name="theme-color" content="#111827">
  <link rel="manifest" id="app-manifest" href="#">
  <script>
    (function initErrorBanner() {
      'use strict';
      const BAR_ID = 'errbar';
      const queue = [];

      function ensureHost() {
        const el = document.getElementById(BAR_ID);
        if (!el) return null;
        if (!el.dataset.ready) {
          el.dataset.ready = '1';
          el.classList.add('block');
        }
        return el;
      }

      function render(bar, payload) {
        if (!bar) return;
        const card = document.createElement('div');
        card.className = 'pointer-events-auto bg-red-600 text-white shadow-lg shadow-red-900/40';
        card.innerHTML = `
          <div class="max-w-3xl mx-auto px-4 sm:px-6 py-3 text-sm font-semibold leading-snug flex flex-col gap-1">
            <div>${payload.message}</div>
            ${payload.detail ? `<pre class="text-xs font-mono whitespace-pre-wrap break-words text-red-100/90">${payload.detail}</pre>` : ''}
          </div>
        `;
        bar.replaceChildren(card);
      }

      function flush() {
        const bar = ensureHost();
        if (!bar) return;
        while (queue.length) {
          render(bar, queue.shift());
        }
      }

      window.showError = function showError(message, detail) {
        const payload = {
          message: typeof message === 'string' ? message : String(message ?? 'エラーが発生しました'),
          detail: detail ? (typeof detail === 'string' ? detail : String(detail)) : ''
        };
        const bar = ensureHost();
        if (!bar) {
          queue.push(payload);
          return;
        }
        render(bar, payload);
      };

      window.onerror = function onWindowError(message, source, lineno, colno, error) {
        const parts = [];
        if (source) parts.push(`${source}:${lineno ?? 0}:${colno ?? 0}`);
        if (error && error.stack) {
          parts.push(error.stack);
        } else if (message) {
          parts.push(String(message));
        }
        showError('予期しないエラーが発生しました', parts.join('\n'));
        return false;
      };

      window.addEventListener('unhandledrejection', (event) => {
        const reason = event?.reason;
        const detail = typeof reason === 'string'
          ? reason
          : reason?.stack
            ? reason.stack
            : reason ? JSON.stringify(reason) : '';
        showError('処理されていないPromise例外を検出しました', detail);
      });

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        flush();
      } else {
        document.addEventListener('DOMContentLoaded', flush, { once: true });
      }
    })();
  </script>
  <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha384-Jl0nO9r2yZS3AuNEqFOtPiou0IZ6Tn6PvxI6Bfq5lHppZArYrusS4x+h0/pk3jfb" crossorigin="anonymous"></script>
  <style>
    body { font-size: 16px; min-height: 100vh; }
    .scroll-lock { overflow: hidden; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.45); display: flex; align-items: center; justify-content: center; padding: 1.5rem; backdrop-filter: blur(2px); }
    .modal-card { max-width: 22rem; width: 100%; background: white; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 25px 50px -12px rgba(15, 23, 42, 0.25); }
    .error-banner { position: fixed; inset-inline: 0; top: 0; z-index: 50; }
    .tab-nav { position: fixed; bottom: 0; inset-inline: 0; background: white; border-top: 1px solid rgba(51, 65, 85, 0.2); padding: 0.5rem 0; display: flex; justify-content: space-around; }
    .main-content { padding-bottom: 7.5rem; padding-top: 4.5rem; }
    .btn-primary { background-color: #1f2937; color: white; }
    .btn-primary:hover { background-color: #111827; }
    .btn-muted { background-color: white; color: #1f2937; border: 1px solid rgba(30,41,59,0.3); }
    .input-base { border: 1px solid rgba(51,65,85,0.35); border-radius: 0.75rem; padding: 0.45rem 0.75rem; font-size: 1rem; width: 100%; background-color: white; color: #111827; min-height: 40px; }
    .input-base:focus { outline: 2px solid rgba(30, 64, 175, 0.6); outline-offset: 2px; }
    .select-base { border: 1px solid rgba(51,65,85,0.35); border-radius: 0.75rem; padding: 0.45rem 0.75rem; font-size: 1rem; width: 100%; background-color: white; color: #111827; min-height: 40px; }
    .select-base:focus { outline: 2px solid rgba(30, 64, 175, 0.6); outline-offset: 2px; }
    #errbar { min-height: 0.25rem; }
    #pwa-toast-root { position: fixed; inset-inline: 0; bottom: 4.5rem; display: flex; justify-content: center; padding: 0 1rem 1.25rem; pointer-events: none; z-index: 60; }
    #pwa-toast-root.hidden { display: none; }
    .pwa-toast-card { pointer-events: auto; display: inline-flex; align-items: center; gap: 0.75rem; background: #111827; color: white; border-radius: 9999px; padding: 0.75rem 1.15rem; box-shadow: 0 20px 45px rgba(15, 23, 42, 0.32); font-size: 0.95rem; font-weight: 600; }
    .pwa-toast-card button { background: white; color: #111827; font-weight: 700; border-radius: 9999px; padding: 0.4rem 0.95rem; font-size: 0.9rem; }
    .provisional-highlight { background-color: #fef3c7 !important; border-color: #fbbf24 !important; }
    .provisional-warning { background-color: #fef3c7; border: 1px solid #fbbf24; color: #78350f; }
    .action-bar-root { position: fixed; inset-inline: 0; bottom: 4.75rem; z-index: 45; pointer-events: none; }
    .action-bar-host { pointer-events: auto; }
    details summary { list-style: none; }
    details summary::-webkit-details-marker { display: none; }
  </style>
</head>
<body class="text-slate-900 overflow-x-hidden">
  <div id="errbar" class="error-banner"></div>
  <div id="error-root" class="error-banner hidden"></div>
  <div id="pwa-toast-root" class="hidden"></div>
  <div id="action-bar-root" class="action-bar-root hidden px-4 sm:px-6">
    <div id="action-bar-host" class="action-bar-host mx-auto max-w-3xl"></div>
  </div>
  <main id="app" class="max-w-3xl mx-auto main-content px-4 sm:px-6"></main>
  <nav class="tab-nav">
    <button data-route="home" class="tab-button flex-1 text-sm font-semibold text-slate-800">ホーム</button>
    <button data-route="history" class="tab-button flex-1 text-sm font-semibold text-slate-800">履歴</button>
    <button data-route="workout" class="tab-button flex-1 text-sm font-semibold text-slate-800">記録</button>
    <button data-route="settings" class="tab-button flex-1 text-sm font-semibold text-slate-800">設定</button>
  </nav>
  <script>
  (function(){
    'use strict';

      const BUILD_TAG = 'MARKERS-20240607';
      const SAFE_MODE = true;
      const SAFE_STORAGE_KEY = 'muscle-app.safe-mode.workout';
      const SAFE_BOOT_TIMEOUT = 2000;
      let safeModeServiceWorkerCleared = false;

    const IS_DEV = ['localhost', '127.0.0.1', '0.0.0.0', '[::1]'].includes(window.location.hostname);
    let initializationWarningCount = 0;

    function assertInitialized(name, value) {
      if (!IS_DEV) return;
      if (typeof value === 'undefined') {
        initializationWarningCount += 1;
        console.warn(`[init-warning] ${name} は未初期化のまま参照されました。`);
      }
    }

    let manifestObjectUrl = null;

    const ensureManifest = () => {
      const manifestLink = document.querySelector('#app-manifest');
      if (!manifestLink) return;
      if (manifestObjectUrl) {
        URL.revokeObjectURL(manifestObjectUrl);
        manifestObjectUrl = null;
      }
      const iconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="none"><rect width="512" height="512" rx="128" fill="#111827"/><path d="M140 364V148h70l46 96 46-96h70v216h-64V256l-52 112h-8l-52-112v108h-64Z" fill="#38bdf8"/></svg>';
      const iconUrl = `data:image/svg+xml;utf8,${encodeURIComponent(iconSvg)}`;
      const manifest = {
        name: '筋トレメモ',
        short_name: '筋トレメモ',
        description: 'オフラインでも使える筋トレ記録アプリ',
        start_url: '.',
        display: 'standalone',
        background_color: '#111827',
        theme_color: '#111827',
        lang: 'ja-JP',
        orientation: 'portrait',
        icons: [
          { src: iconUrl, sizes: '192x192', type: 'image/svg+xml', purpose: 'any maskable' },
          { src: iconUrl, sizes: '512x512', type: 'image/svg+xml', purpose: 'any maskable' }
        ]
      };
      manifestObjectUrl = URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: 'application/json' }));
      manifestLink.setAttribute('href', manifestObjectUrl);
    };

    window.addEventListener('beforeunload', () => {
      if (manifestObjectUrl) {
        URL.revokeObjectURL(manifestObjectUrl);
        manifestObjectUrl = null;
      }
    });

    const createPwaToastController = () => {
      const root = document.getElementById('pwa-toast-root');
      if (!root) {
        return {
          showUpdatePrompt: () => {},
          showStatus: () => {}
        };
      }

      let hideTimer = null;

      const clearTimer = () => {
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
      };

      const hide = () => {
        clearTimer();
        root.classList.add('hidden');
        root.innerHTML = '';
      };

      const show = (message, action) => {
        clearTimer();
        root.innerHTML = '';
        const card = document.createElement('div');
        card.className = 'pwa-toast-card';
        const text = document.createElement('span');
        text.textContent = message;
        card.appendChild(text);
        if (action) {
          const button = document.createElement('button');
          button.type = 'button';
          button.textContent = action.label;
          button.addEventListener('click', action.onClick, { once: true });
          card.appendChild(button);
        }
        root.appendChild(card);
        root.classList.remove('hidden');
      };

      return {
        showUpdatePrompt(onConfirm) {
          show('新バージョンがあります→更新', {
            label: '更新',
            onClick: () => {
              show('更新を適用しています…');
              onConfirm();
            }
          });
        },
        showStatus(message) {
          show(message);
          hideTimer = setTimeout(() => {
            hide();
          }, 3500);
        },
        hide
      };
    };

    const registerPwaFeatures = () => {
      ensureManifest();
      if (!('serviceWorker' in navigator)) {
        return;
      }

      const toast = createPwaToastController();
      const swUrl = `./pwa-sw.js?build=${BUILD_TAG}`;

      navigator.serviceWorker.register(swUrl).then((registration) => {
        const listenForWaiting = (worker) => {
          if (!worker) return;
          toast.showUpdatePrompt(() => worker.postMessage({ type: 'SKIP_WAITING' }));
        };

        if (registration.waiting) {
          listenForWaiting(registration.waiting);
        }

        registration.addEventListener('updatefound', () => {
          const worker = registration.installing;
          if (!worker) return;
          worker.addEventListener('statechange', () => {
            if (worker.state === 'installed' && navigator.serviceWorker.controller) {
              listenForWaiting(registration.waiting || worker);
            }
          });
        });

        navigator.serviceWorker.ready.then((readyRegistration) => {
          const hasController = Boolean(navigator.serviceWorker.controller);
          if (!hasController || !(registration.waiting || readyRegistration.waiting)) {
            toast.showStatus('オフラインモードを準備しました');
          }
        }).catch(() => {});
      }).catch((error) => {
        console.error('[pwa] Service worker registration failed', error);
      });

      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (refreshing) return;
        refreshing = true;
        window.location.reload();
      });
    };

    const disableServiceWorkerOnce = () => {
      if (safeModeServiceWorkerCleared || !SAFE_MODE || !('serviceWorker' in navigator)) {
        return;
      }
      safeModeServiceWorkerCleared = true;
      navigator.serviceWorker.getRegistrations?.().then((registrations) => {
        registrations.forEach((registration) => {
          registration.unregister().catch(() => {});
        });
      }).catch(() => {});
    };

    if (SAFE_MODE) {
      disableServiceWorkerOnce();
    } else {
      registerPwaFeatures();
    }

    /*** utils ***/
    const ROUTES = Object.freeze({
      HOME: 'home',
      HISTORY: 'history',
      SETTINGS: 'settings',
      WORKOUT: 'workout'
    });
    const ROUTE_VALUES = new Set(Object.values(ROUTES));

    const createElem = (tag, opts = {}) => {
      const el = document.createElement(tag);
      if (opts.className) el.className = opts.className;
      if (opts.textContent !== undefined) el.textContent = opts.textContent;
      if (opts.html !== undefined) el.innerHTML = opts.html;
      if (opts.attrs) Object.entries(opts.attrs).forEach(([k, v]) => el.setAttribute(k, v));
      if (opts.value !== undefined) el.value = opts.value;
      if (opts.children) opts.children.forEach(child => el.appendChild(child));
      return el;
    };

    const createSafeModeController = () => {
      if (!SAFE_MODE) {
        return {
          mount() {},
          onRenderSuccess() {},
          onRenderFailure(error) {
            if (error && typeof window.showError === 'function') {
              window.showError('初期化に失敗しました', error.stack || String(error));
            }
          }
        };
      }

      const createEmptySet = () => ({ weight: '', reps: '', seconds: '', rpe: '' });
      const createDefaultState = () => ({
        exerciseId: '',
        equipment: '',
        attachment: '',
        angle: '',
        position: '',
        sets: [createEmptySet(), createEmptySet(), createEmptySet()]
      });

      const loadState = () => {
        try {
          const raw = localStorage.getItem(SAFE_STORAGE_KEY);
          if (!raw) return createDefaultState();
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') return createDefaultState();
          const base = createDefaultState();
          return {
            exerciseId: typeof parsed.exerciseId === 'string' ? parsed.exerciseId : base.exerciseId,
            equipment: typeof parsed.equipment === 'string' ? parsed.equipment : base.equipment,
            attachment: typeof parsed.attachment === 'string' ? parsed.attachment : base.attachment,
            angle: typeof parsed.angle === 'string' ? parsed.angle : base.angle,
            position: typeof parsed.position === 'string' ? parsed.position : base.position,
            sets: Array.isArray(parsed.sets) && parsed.sets.length
              ? parsed.sets.map((set) => ({
                  weight: typeof set?.weight === 'string' ? set.weight : '',
                  reps: typeof set?.reps === 'string' ? set.reps : '',
                  seconds: typeof set?.seconds === 'string' ? set.seconds : '',
                  rpe: typeof set?.rpe === 'string' ? set.rpe : ''
                }))
              : base.sets
          };
        } catch (error) {
          if (typeof window.showError === 'function') {
            window.showError('安全モードデータの読み込みに失敗しました', error?.stack || String(error));
          }
          return createDefaultState();
        }
      };

      let state = null;
      let root = null;
      let shell = null;
      let setHost = null;
      let watchdog = null;
      let fallbackShown = false;

      const refs = {
        exercise: null,
        equipment: null,
        attachment: null,
        angle: null,
        position: null,
        addButton: null
      };

      const ensureState = () => {
        if (!state) state = loadState();
        return state;
      };

      const persist = () => {
        try {
          localStorage.setItem(SAFE_STORAGE_KEY, JSON.stringify(ensureState()));
        } catch (error) {
          if (typeof window.showError === 'function') {
            window.showError('安全モードデータの保存に失敗しました', error?.stack || String(error));
          }
        }
      };

      const renderSets = () => {
        if (!setHost) return;
        const current = ensureState();
        const rows = current.sets.map((set, index) => {
          const row = createElem('div', {
            className: 'rounded-xl border border-slate-200 bg-slate-50/80 px-4 py-3 sm:px-5 sm:py-4 flex flex-col gap-3'
          });
          const header = createElem('div', { className: 'flex items-center justify-between gap-3' });
          const labelWrap = createElem('div', { className: 'flex items-center gap-2 text-sm font-semibold text-slate-700' });
          labelWrap.append(
            createElem('span', {
              className: 'inline-flex items-center justify-center w-6 h-6 rounded-full bg-slate-800 text-white text-xs',
              textContent: String(index + 1)
            }),
            createElem('span', { textContent: 'Set' })
          );
          const actionWrap = createElem('div', { className: 'flex items-center gap-2' });
          const duplicateBtn = createElem('button', {
            className: 'text-xs font-semibold text-slate-600 hover:text-slate-900 underline',
            textContent: '複製',
            attrs: { type: 'button', 'data-action': 'duplicate', 'data-index': String(index) }
          });
          const removeBtn = createElem('button', {
            className: 'text-xs font-semibold text-red-600 hover:text-red-700',
            textContent: '削除',
            attrs: { type: 'button', 'data-action': 'remove', 'data-index': String(index) }
          });
          actionWrap.append(duplicateBtn, removeBtn);
          header.append(labelWrap, actionWrap);

          const grid = createElem('div', { className: 'grid grid-cols-1 sm:grid-cols-4 gap-3 text-sm' });
          const fields = [
            { key: 'weight', label: '重量 (kg)', type: 'number', step: '0.5', placeholder: '0' },
            { key: 'reps', label: '回数', type: 'number', step: '1', placeholder: '0' },
            { key: 'seconds', label: '秒', type: 'number', step: '1', placeholder: '0' },
            { key: 'rpe', label: 'RPE', type: 'number', step: '0.5', placeholder: '' }
          ];
          fields.forEach((field) => {
            const label = createElem('label', { className: 'flex flex-col gap-1 text-sm font-semibold leading-snug text-slate-900' });
            label.append(
              createElem('span', { textContent: field.label }),
              createElem('input', {
                className: 'input-base',
                attrs: {
                  type: field.type,
                  step: field.step,
                  inputmode: field.type === 'number' ? 'decimal' : undefined,
                  'data-field': field.key,
                  'data-index': String(index),
                  placeholder: field.placeholder
                },
                value: set[field.key] ?? ''
              })
            );
            grid.append(label);
          });
          row.append(header, grid);
          return row;
        });
        setHost.replaceChildren(...rows);
      };

      const addSet = () => {
        const current = ensureState();
        current.sets.push(createEmptySet());
        renderSets();
        persist();
      };

      const duplicateSet = (index) => {
        const current = ensureState();
        const source = current.sets[index];
        if (!source) return;
        current.sets.splice(index + 1, 0, { ...source });
        renderSets();
        persist();
      };

      const removeSet = (index) => {
        const current = ensureState();
        if (current.sets.length <= 1) {
          current.sets[0] = createEmptySet();
        } else {
          current.sets.splice(index, 1);
        }
        renderSets();
        persist();
      };

      const bindSetHost = () => {
        if (!setHost) return;
        setHost.addEventListener('click', (event) => {
          const action = event.target?.dataset?.action;
          const index = Number(event.target?.dataset?.index);
          if (!Number.isInteger(index)) return;
          if (action === 'duplicate') {
            duplicateSet(index);
          } else if (action === 'remove') {
            removeSet(index);
          }
        });
        setHost.addEventListener('input', (event) => {
          const field = event.target?.dataset?.field;
          const index = Number(event.target?.dataset?.index);
          if (!field || !Number.isInteger(index)) return;
          const current = ensureState();
          if (!current.sets[index]) return;
          current.sets[index][field] = event.target.value;
          persist();
        });
      };

      const syncField = (element, key) => {
        if (!element) return;
        element.value = ensureState()[key] ?? '';
        const handler = (event) => {
          ensureState()[key] = event.target.value;
          persist();
        };
        const type = element.tagName === 'SELECT' ? 'change' : 'input';
        element.addEventListener(type, handler);
      };

      const renderFallback = () => {
        if (!shell || fallbackShown) return;
        fallbackShown = true;
        const fallback = createElem('div', {
          className: 'safe-fallback bg-white rounded-2xl shadow-sm p-4 sm:p-6 flex flex-col gap-3'
        });
        fallback.append(
          createElem('div', { className: 'text-lg font-bold text-slate-900', textContent: '安全モードで起動' }),
          createElem('p', {
            className: 'text-sm text-slate-600',
            textContent: '初期化に失敗したため、安全モードのフォールバックUIを表示しています。'
          }),
          createElem('div', { className: 'flex flex-col sm:flex-row gap-2', children: [
            createElem('a', {
              className: 'btn-muted rounded-full px-4 py-2 text-center text-sm font-semibold',
              textContent: '設定へ',
              attrs: { href: '#/settings' }
            }),
            createElem('a', {
              className: 'btn-muted rounded-full px-4 py-2 text-center text-sm font-semibold',
              textContent: '履歴へ',
              attrs: { href: '#/history' }
            })
          ] })
        );
        shell.append(fallback);
      };

      const startWatchdog = () => {
        if (watchdog || !root) return;
        watchdog = window.setTimeout(() => {
          if (!root.dataset.fullAppReady) {
            if (typeof window.showError === 'function') {
              window.showError('Boot timeout', 'UIの描画が2秒以内に完了しませんでした');
            }
            renderFallback();
          }
        }, SAFE_BOOT_TIMEOUT);
      };

      const clearWatchdog = () => {
        if (!watchdog) return;
        window.clearTimeout(watchdog);
        watchdog = null;
      };

      const highlightWorkoutTab = () => {
        document.querySelectorAll('.tab-button').forEach((button) => {
          if (button.dataset.route === 'workout') {
            button.classList.add('text-blue-600', 'font-bold');
            button.classList.remove('text-slate-800');
          } else {
            button.classList.remove('text-blue-600', 'font-bold');
            button.classList.add('text-slate-800');
          }
        });
      };

      return {
        mount(target) {
          if (!target) {
            if (typeof window.showError === 'function') {
              window.showError('アプリのルート要素が見つかりません', 'id="app" が存在しないため安全モードを表示できません');
            }
            return;
          }
          if (shell) return;
          root = target;
          highlightWorkoutTab();
          state = loadState();
          shell = createElem('div', { className: 'safe-mode-shell flex flex-col gap-6 py-6 md:py-8' });

          const headline = createElem('div', {
            className: 'bg-white rounded-2xl shadow-sm px-4 py-3 sm:px-6 sm:py-4 flex items-center justify-between'
          });
          headline.append(
            createElem('div', {
              className: 'flex flex-col',
              children: [
                createElem('span', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-500', textContent: '安全モード' }),
                createElem('h1', { className: 'text-xl font-bold text-slate-900', textContent: 'ワークアウト記録' })
              ]
            }),
            createElem('span', { className: 'text-xs text-slate-500', textContent: `BUILD: ${BUILD_TAG}` })
          );

          const exerciseSection = createElem('section', {
            className: 'bg-white rounded-2xl shadow-sm p-4 sm:p-5 flex flex-col gap-4'
          });
          const exerciseLabel = createElem('label', {
            className: 'flex flex-col gap-2 text-sm font-semibold leading-snug text-slate-900'
          });
          exerciseLabel.append(
            createElem('span', { textContent: '種目を選択' }),
            (() => {
              const select = createElem('select', { className: 'select-base', attrs: { id: 'safe-exercise-select' } });
              [
                { value: '', label: '選択してください' },
                { value: 'bench_press', label: 'ベンチプレス' },
                { value: 'squat', label: 'スクワット' },
                { value: 'deadlift', label: 'デッドリフト' },
                { value: 'lat_pulldown', label: 'ラットプルダウン' },
                { value: 'shoulder_press', label: 'ショルダープレス' }
              ].forEach((option) => {
                select.append(createElem('option', { attrs: { value: option.value }, textContent: option.label }));
              });
              refs.exercise = select;
              return select;
            })()
          );
          exerciseSection.append(exerciseLabel);

          const metaSection = createElem('section', {
            className: 'bg-white rounded-2xl shadow-sm p-4 sm:p-5 flex flex-col gap-4'
          });
          metaSection.append(
            createElem('div', { className: 'text-sm font-semibold leading-snug text-slate-900', textContent: 'メタ情報' })
          );
          const metaGrid = createElem('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-x-3 gap-y-3' });
          const metaFields = [
            { key: 'equipment', label: '器具', placeholder: '例：バーベル' },
            { key: 'attachment', label: 'アタッチメント', placeholder: '例：ストレートバー' },
            { key: 'angle', label: '角度', placeholder: '例：フラット' },
            { key: 'position', label: 'ポジション', placeholder: '例：ラック1' }
          ];
          metaFields.forEach((field) => {
            const label = createElem('label', { className: 'flex flex-col gap-1 text-sm font-semibold leading-snug text-slate-900' });
            const input = createElem('input', {
              className: 'input-base',
              attrs: { id: `safe-${field.key}`, type: 'text', autocomplete: 'off', placeholder: field.placeholder }
            });
            refs[field.key] = input;
            label.append(createElem('span', { textContent: field.label }), input);
            metaGrid.append(label);
          });
          metaSection.append(metaGrid);

          const setSection = createElem('section', {
            className: 'bg-white rounded-2xl shadow-sm p-4 sm:p-5 flex flex-col gap-4'
          });
          const setHeader = createElem('div', { className: 'flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3' });
          setHeader.append(
            createElem('div', { className: 'text-sm font-semibold leading-snug text-slate-900', textContent: 'セットリスト' }),
            (() => {
              const wrap = createElem('div', { className: 'flex items-center gap-2' });
              const button = createElem('button', {
                className: 'btn-primary rounded-full px-4 py-2 text-sm font-semibold shadow-sm',
                textContent: 'セットを追加',
                attrs: { type: 'button', id: 'safe-add-set' }
              });
              refs.addButton = button;
              wrap.append(button);
              return wrap;
            })()
          );
          setSection.append(setHeader);
          setHost = createElem('div', { className: 'flex flex-col gap-3', attrs: { id: 'safe-set-host' } });
          setSection.append(setHost);

          shell.append(headline, exerciseSection, metaSection, setSection);
          target.append(shell);

          renderSets();
          bindSetHost();
          syncField(refs.exercise, 'exerciseId');
          syncField(refs.equipment, 'equipment');
          syncField(refs.attachment, 'attachment');
          syncField(refs.angle, 'angle');
          syncField(refs.position, 'position');
          if (refs.addButton) {
            refs.addButton.addEventListener('click', addSet);
          }

          startWatchdog();
        },
        onRenderSuccess() {
          if (!root) return;
          root.dataset.fullAppReady = '1';
          clearWatchdog();
          if (shell && shell.parentElement === root) {
            shell.remove();
          }
        },
        onRenderFailure(error) {
          clearWatchdog();
          if (error && typeof window.showError === 'function') {
            window.showError('安全モードで起動しました', error.stack || String(error));
          }
          renderFallback();
        }
      };
    };

    const actionBarRoot = document.getElementById('action-bar-root');
    const actionBarHost = document.getElementById('action-bar-host');
    let scheduledActionBarContent = null;
    const scheduleActionBar = (nodes) => {
      if (!Array.isArray(nodes) || !nodes.length) {
        scheduledActionBarContent = null;
        return;
      }
      scheduledActionBarContent = nodes;
    };
    const applyScheduledActionBar = (route) => {
      if (!actionBarRoot || !actionBarHost) {
        scheduledActionBarContent = null;
        return;
      }
      if (route === ROUTES.WORKOUT && scheduledActionBarContent && scheduledActionBarContent.length) {
        actionBarHost.replaceChildren(...scheduledActionBarContent);
        actionBarRoot.classList.remove('hidden');
      } else {
        actionBarHost.replaceChildren();
        actionBarRoot.classList.add('hidden');
      }
      scheduledActionBarContent = null;
    };

    const createInfoIcon = (tooltip) => {
      return createElem('span', {
        className: 'inline-flex items-center justify-center w-5 h-5 rounded-full border border-blue-600 text-[0.625rem] font-bold text-blue-700 cursor-help',
        textContent: 'i',
        attrs: { title: tooltip, 'aria-label': tooltip }
      });
    };

    const createFieldWrapper = (labelText, tooltip, description, inputEl) => {
      const wrapper = createElem('label', { className: 'flex flex-col gap-1 text-sm font-semibold leading-snug text-slate-900' });
      const header = createElem('div', { className: 'flex items-center gap-1 text-sm font-semibold leading-snug' });
      header.append(
        createElem('span', { textContent: labelText }),
        createInfoIcon(tooltip)
      );
      wrapper.append(header);
      if (description) {
        wrapper.append(createElem('span', { className: 'text-xs font-normal leading-snug text-slate-600', textContent: description }));
      }
      wrapper.append(inputEl);
      return wrapper;
    };

    const applyProvisionalHighlight = (element, shouldHighlight) => {
      if (!element) return;
      if (shouldHighlight) {
        element.classList.add('provisional-highlight');
      } else {
        element.classList.remove('provisional-highlight');
      }
    };

    const getTodayDateValue = () => {
      const now = new Date();
      const offset = now.getTimezoneOffset();
      const local = new Date(now.getTime() - offset * 60000);
      return local.toISOString().slice(0, 10);
    };

    const registerLongPress = (element, handler, delay = 600) => {
      let timerId = null;
      const cancel = () => {
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
      };
      const start = (event) => {
        if (event.type === 'touchstart' && event.touches.length > 1) return;
        if (event.target.closest('input, textarea, select, button')) return;
        cancel();
        timerId = setTimeout(() => {
          handler();
          cancel();
        }, delay);
      };
      element.addEventListener('touchstart', start, { passive: true });
      element.addEventListener('mousedown', (event) => {
        if (event.button !== 0) return;
        start(event);
      });
      ['touchend', 'touchcancel', 'touchmove', 'mouseup', 'mouseleave'].forEach((type) => {
        element.addEventListener(type, cancel);
      });
    };

    const formatDate = (value) => {
      try {
        return new Intl.DateTimeFormat('ja-JP', { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));
      } catch (err) {
        return '';
      }
    };

    const safeNumber = (value) => {
      if (value === null || value === undefined) return null;
      if (typeof value === 'string' && value.trim() === '') return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };

    const isFiniteNumber = (value) => typeof value === 'number' && Number.isFinite(value);

    const analyzeSetCompletion = (set) => {
      if (!set || typeof set !== 'object') {
        return {
          hasAny: false,
          hasWeight: false,
          hasReps: false,
          missingWeight: false,
          missingReps: false,
          isProvisional: false
        };
      }
      const hasWeight = isFiniteNumber(set.weight);
      const hasReps = isFiniteNumber(set.reps);
      const hasAny = hasWeight || hasReps;
      const missingWeight = hasAny && !hasWeight;
      const missingReps = hasAny && !hasReps;
      return {
        hasAny,
        hasWeight,
        hasReps,
        missingWeight,
        missingReps,
        isProvisional: hasAny && (missingWeight || missingReps)
      };
    };

    const applyProvisionalState = (set) => {
      const analysis = analyzeSetCompletion(set);
      set.isProvisional = analysis.isProvisional;
      if (set.isProvisional) {
        set.oneRM = null;
      }
      return analysis;
    };

    const cloneDeep = (obj) => {
      if (typeof structuredClone === 'function') {
        return structuredClone(obj);
      }
      return JSON.parse(JSON.stringify(obj));
    };

    const CSV_SCHEMA_VERSION = 1;
    const CSV_RECORD_TYPES = Object.freeze({
      META: 'meta',
      SETTINGS: 'settings',
      CATALOG: 'catalog',
      HISTORY_VIEW: 'history-view',
      WORKOUT: 'workout',
      EXERCISE: 'exercise',
      SET: 'set'
    });
    const CSV_COLUMNS = Object.freeze([
      'schemaVersion',
      'device',
      'exportedAt',
      'recordType',
      'workoutState',
      'workoutId',
      'workoutStartedAt',
      'workoutCompletedAt',
      'workoutOrder',
      'date',
      'part',
      'partKey',
      'exercise',
      'exerciseKey',
      'equipment',
      'equipmentKey',
      'attachment',
      'attachmentKey',
      'angle',
      'position',
      'positionKey',
      'performedOn',
      'intervalSeconds',
      'exerciseId',
      'setIndex',
      'setType',
      'weight',
      'reps',
      'oneRM',
      'note',
      'unit',
      'catalogEntry'
    ]);
    const EXERCISE_PARTS = Object.freeze([
      {
        key: 'chest',
        label: '胸',
        exercises: Object.freeze(['ベンチプレス', 'インクラインベンチプレス', 'ダンベルフライ', 'チェストプレス', 'ディップス'])
      },
      {
        key: 'back',
        label: '背中',
        exercises: Object.freeze(['デッドリフト', 'ベントオーバーロウ', 'ラットプルダウン', 'シーテッドロウ', 'プルアップ'])
      },
      {
        key: 'shoulder',
        label: '肩',
        exercises: Object.freeze(['ショルダープレス', 'サイドレイズ', 'リアレイズ', 'フロントレイズ', 'アップライトロウ'])
      },
      {
        key: 'arm',
        label: '腕',
        exercises: Object.freeze(['バイセップカール', 'トライセプスプレスダウン', 'ダンベルカール', 'スカルクラッシャー', 'ハンマーカール'])
      },
      {
        key: 'core',
        label: '体幹',
        exercises: Object.freeze(['プランク', 'クランチ', 'レッグレイズ', 'ロシアンツイスト', 'アブローラー'])
      },
      {
        key: 'leg',
        label: '脚',
        exercises: Object.freeze(['スクワット', 'ランジ', 'レッグプレス', 'レッグエクステンション', 'レッグカール'])
      }
    ]);
    const EXERCISE_PART_KEY_SET = new Set(EXERCISE_PARTS.map((part) => part.key));
    const normalizePartKey = (value) => {
      if (typeof value !== 'string') return null;
      const trimmed = value.trim();
      if (!trimmed) return null;
      return EXERCISE_PART_KEY_SET.has(trimmed) ? trimmed : null;
    };
    const getPartDefinition = (key) => {
      const normalized = normalizePartKey(key);
      return normalized ? EXERCISE_PARTS.find((part) => part.key === normalized) || null : null;
    };

    const DEFAULT_EXERCISE_OPTIONS = Object.freeze([
      { key: 'bench_press', label: 'ベンチプレス', partKey: 'chest' },
      { key: 'incline_bench_press', label: 'インクラインベンチプレス', partKey: 'chest' },
      { key: 'dumbbell_fly', label: 'ダンベルフライ', partKey: 'chest' },
      { key: 'chest_press_machine', label: 'チェストプレス', partKey: 'chest' },
      { key: 'dips', label: 'ディップス', partKey: 'chest' },
      { key: 'deadlift', label: 'デッドリフト', partKey: 'back' },
      { key: 'bent_over_row', label: 'ベントオーバーロウ', partKey: 'back' },
      { key: 'lat_pulldown', label: 'ラットプルダウン', partKey: 'back' },
      { key: 'seated_row', label: 'シーテッドロウ', partKey: 'back' },
      { key: 'pull_up', label: 'プルアップ', partKey: 'back' },
      { key: 'shoulder_press', label: 'ショルダープレス', partKey: 'shoulder' },
      { key: 'lateral_raise', label: 'サイドレイズ', partKey: 'shoulder' },
      { key: 'rear_raise', label: 'リアレイズ', partKey: 'shoulder' },
      { key: 'front_raise', label: 'フロントレイズ', partKey: 'shoulder' },
      { key: 'upright_row', label: 'アップライトロウ', partKey: 'shoulder' },
      { key: 'biceps_curl', label: 'バイセップカール', partKey: 'arm' },
      { key: 'triceps_pushdown', label: 'トライセプスプレスダウン', partKey: 'arm' },
      { key: 'dumbbell_curl', label: 'ダンベルカール', partKey: 'arm' },
      { key: 'skull_crusher', label: 'スカルクラッシャー', partKey: 'arm' },
      { key: 'hammer_curl', label: 'ハンマーカール', partKey: 'arm' },
      { key: 'plank', label: 'プランク', partKey: 'core' },
      { key: 'crunch', label: 'クランチ', partKey: 'core' },
      { key: 'leg_raise', label: 'レッグレイズ', partKey: 'core' },
      { key: 'russian_twist', label: 'ロシアンツイスト', partKey: 'core' },
      { key: 'ab_wheel', label: 'アブローラー', partKey: 'core' },
      { key: 'squat', label: 'スクワット', partKey: 'leg' },
      { key: 'lunge', label: 'ランジ', partKey: 'leg' },
      { key: 'leg_press', label: 'レッグプレス', partKey: 'leg' },
      { key: 'leg_extension', label: 'レッグエクステンション', partKey: 'leg' },
      { key: 'leg_curl', label: 'レッグカール', partKey: 'leg' }
    ]);

    const DEFAULT_EQUIPMENT_OPTIONS = Object.freeze([
      { key: 'barbell', label: 'バーベル' },
      { key: 'dumbbell', label: 'ダンベル' },
      { key: 'machine', label: 'マシン' },
      { key: 'cable', label: 'ケーブル' },
      { key: 'bodyweight', label: '自重' },
      { key: 'kettlebell', label: 'ケトルベル' }
    ]);

    const DEFAULT_ATTACHMENT_OPTIONS = Object.freeze([
      { key: 'none', label: 'なし' },
      { key: 'rope', label: 'ロープ' },
      { key: 'straight_bar', label: 'ストレートバー' },
      { key: 'ez_bar', label: 'EZバー' },
      { key: 'd_handle', label: 'Dハンドル' },
      { key: 'v_bar', label: 'Vバー' }
    ]);

    const DEFAULT_POSITION_OPTIONS = Object.freeze([
      { key: 'neutral', label: 'ナチュラル' },
      { key: 'wide', label: 'ワイド' },
      { key: 'narrow', label: 'ナロー' },
      { key: 'supinated', label: 'サップネイテッド' },
      { key: 'pronated', label: 'プロネイテッド' },
      { key: 'mixed', label: 'ミックスグリップ' }
    ]);

    const OPTION_FIELD_LIST = Object.freeze(['exercise', 'equipment', 'attachment', 'position']);

    const DEFAULT_OPTION_CATALOGS = Object.freeze({
      exercise: DEFAULT_EXERCISE_OPTIONS,
      equipment: DEFAULT_EQUIPMENT_OPTIONS,
      attachment: DEFAULT_ATTACHMENT_OPTIONS,
      position: DEFAULT_POSITION_OPTIONS
    });

    const cloneOptionEntries = (entries) => entries.map((entry) => ({ ...entry }));

    const normalizeLabelValue = (value) => {
      if (typeof value !== 'string') return '';
      try {
        return value.normalize('NFKC');
      } catch (err) {
        return value;
      }
    };

    const createLabelSignature = (value) => normalizeLabelValue(value).replace(/\s+/g, '').toLowerCase();

    const createDeterministicOptionKey = (field, label) => {
      const normalized = normalizeLabelValue(label);
      let hash = 0;
      for (const char of normalized) {
        const code = char.codePointAt(0);
        hash = (hash * 31 + code) >>> 0;
      }
      return `${field}-${hash.toString(36)}`;
    };

    const ensureOptionCatalogs = (settings) => {
      if (!settings || typeof settings !== 'object') return;
      if (!settings.optionCatalogs || typeof settings.optionCatalogs !== 'object') {
        settings.optionCatalogs = {};
      }
      OPTION_FIELD_LIST.forEach((field) => {
        const existing = Array.isArray(settings.optionCatalogs[field])
          ? settings.optionCatalogs[field]
          : [];
        const sanitized = [];
        const seenKeys = new Set();
        existing.forEach((entry) => {
          if (!entry || typeof entry !== 'object') return;
          const key = typeof entry.key === 'string' && entry.key.trim() ? entry.key.trim() : null;
          const label = normalizeLabelValue(entry.label ?? '');
          if (!key || !label) return;
          if (seenKeys.has(key)) return;
          const option = { key, label };
          if (field === 'exercise') {
            option.partKey = normalizePartKey(entry.partKey) || null;
          }
          if (entry.custom) option.custom = true;
          sanitized.push(option);
          seenKeys.add(key);
        });
        DEFAULT_OPTION_CATALOGS[field].forEach((entry) => {
          if (seenKeys.has(entry.key)) return;
          const option = field === 'exercise'
            ? { key: entry.key, label: entry.label, partKey: entry.partKey }
            : { key: entry.key, label: entry.label };
          sanitized.push(option);
          seenKeys.add(entry.key);
        });
        sanitized.sort((a, b) => a.label.localeCompare(b.label, 'ja'));
        settings.optionCatalogs[field] = sanitized;
      });
    };

    const getOptionCatalogFromSettings = (settings, field) => {
      if (!settings || typeof settings !== 'object') return DEFAULT_OPTION_CATALOGS[field] || [];
      ensureOptionCatalogs(settings);
      return settings.optionCatalogs[field] || [];
    };

    const getOptionCatalog = (field) => getOptionCatalogFromSettings(appData?.settings, field);

    const findOptionEntry = (field, predicate, settings = appData?.settings) => {
      const catalog = getOptionCatalogFromSettings(settings, field);
      for (let index = 0; index < catalog.length; index += 1) {
        const entry = catalog[index];
        if (predicate(entry)) return entry;
      }
      return null;
    };

    const getOptionByKey = (field, key) => {
      if (!key) return null;
      return findOptionEntry(field, (entry) => entry.key === key) || null;
    };

    const getOptionLabel = (field, key) => {
      if (!key) return '';
      const entry = getOptionByKey(field, key);
      return entry ? entry.label : '';
    };

    const ensureOptionEntry = (field, value, { partKey = null, allowCreate = true, settingsOverride = null } = {}) => {
      if (!value && value !== '') {
        return { key: null, entry: null, created: false };
      }
      const settings = settingsOverride || appData?.settings;
      const catalog = getOptionCatalogFromSettings(settings, field);
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) {
          return { key: null, entry: null, created: false };
        }
        const byKey = findOptionEntry(field, (entry) => entry.key === trimmed, settings);
        if (byKey) {
          return { key: byKey.key, entry: byKey, created: false };
        }
        const signature = createLabelSignature(trimmed);
        const byLabel = findOptionEntry(field, (entry) => createLabelSignature(entry.label) === signature, settings);
        if (byLabel) {
          return { key: byLabel.key, entry: byLabel, created: false };
        }
        if (!allowCreate) {
          return { key: null, entry: null, created: false };
        }
        if (!settings) {
          return { key: null, entry: null, created: false };
        }
        ensureOptionCatalogs(settings);
        const label = normalizeLabelValue(trimmed).trim();
        if (!label) {
          return { key: null, entry: null, created: false };
        }
        let candidateKey = createDeterministicOptionKey(field, label);
        let counter = 1;
        while ((settings.optionCatalogs[field] || []).some((entry) => entry.key === candidateKey)) {
          counter += 1;
          candidateKey = `${createDeterministicOptionKey(field, `${label}-${counter}`)}-${counter}`;
        }
        const newEntry = field === 'exercise'
          ? { key: candidateKey, label, partKey: normalizePartKey(partKey) || null, custom: true }
          : { key: candidateKey, label, custom: true };
        settings.optionCatalogs[field].push(newEntry);
        settings.optionCatalogs[field].sort((a, b) => a.label.localeCompare(b.label, 'ja'));
        return { key: candidateKey, entry: newEntry, created: true };
      }
      return { key: null, entry: null, created: false };
    };

    const ensureExerciseCatalogIntegrity = () => {
      if (!appData || !appData.settings) return;
      ensureOptionCatalogs(appData.settings);
      if (!Array.isArray(appData.settings.exerciseCatalog)) {
        appData.settings.exerciseCatalog = [];
      }
      const seen = new Set();
      const normalized = [];
      const appendKey = (key) => {
        if (!key || seen.has(key)) return;
        seen.add(key);
        normalized.push(key);
      };
      appData.settings.exerciseCatalog.forEach((value) => {
        const result = ensureOptionEntry('exercise', value, { allowCreate: true });
        if (result.key) appendKey(result.key);
      });
      DEFAULT_OPTION_CATALOGS.exercise.forEach((entry) => appendKey(entry.key));
      appData.settings.exerciseCatalog = normalized;
    };

    const getExerciseLabelByKey = (key) => getOptionLabel('exercise', key);

    const getExercisePartByKey = (key) => {
      if (!key) return null;
      const entry = getOptionByKey('exercise', key);
      return entry ? normalizePartKey(entry.partKey) : null;
    };

    const normalizeExercisePartHints = () => {
      if (!appData || !appData.settings) return;
      const hints = appData.settings.exercisePartHints;
      const next = {};
      if (hints && typeof hints === 'object') {
        Object.entries(hints).forEach(([rawName, rawPart]) => {
          const normalizedPart = normalizePartKey(rawPart);
          if (!normalizedPart) return;
          const { key } = ensureOptionEntry('exercise', rawName, { allowCreate: true });
          if (key) {
            next[key] = normalizedPart;
          }
        });
      }
      appData.settings.exercisePartHints = next;
    };
    const CSV_ALLOWED_SET_TYPES = new Set(['', 'standard']);
    const CSV_LINE_BREAK = '\r\n';

    const getDeviceName = () => {
      try {
        if (navigator.userAgentData && Array.isArray(navigator.userAgentData.brands)) {
          const brands = navigator.userAgentData.brands
            .map((brand) => brand.brand)
            .filter(Boolean)
            .join(' ');
          if (brands) return brands.slice(0, 120);
        }
      } catch (err) {
        // ignore detection errors
      }
      if (navigator.platform && navigator.platform.trim()) {
        return navigator.platform.trim().slice(0, 120);
      }
      if (navigator.userAgent && navigator.userAgent.trim()) {
        return navigator.userAgent.trim().slice(0, 120);
      }
      return 'unknown-device';
    };

    const createCsvRow = () => {
      const row = {};
      CSV_COLUMNS.forEach((col) => {
        row[col] = '';
      });
      return row;
    };

    const escapeCsvValue = (value) => {
      if (value === null || value === undefined) return '';
      const str = String(value);
      if (str === '') return '';
      if (/[",\n\r]/.test(str)) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    };

    const serializeCsvRows = (rows) => {
      const header = CSV_COLUMNS.join(',');
      const body = rows
        .map((row) => CSV_COLUMNS.map((col) => escapeCsvValue(row[col])).join(','))
        .join(CSV_LINE_BREAK);
      return [header, body].filter(Boolean).join(CSV_LINE_BREAK) + CSV_LINE_BREAK;
    };

    const parseCsvContent = (text) => {
      const rows = [];
      let field = '';
      let currentRow = [];
      let inQuotes = false;
      let lineNumber = 1;
      const pushField = () => {
        currentRow.push(field);
        field = '';
      };
      const pushRow = () => {
        if (!currentRow.length) return;
        const isEmpty = currentRow.every((cell) => cell === '');
        if (!isEmpty) rows.push(currentRow.slice());
        currentRow = [];
        lineNumber += 1;
      };
      for (let i = 0; i < text.length; i += 1) {
        const char = text[i];
        if (inQuotes) {
          if (char === '"') {
            if (text[i + 1] === '"') {
              field += '"';
              i += 1;
            } else {
              inQuotes = false;
            }
          } else {
            field += char;
          }
          continue;
        }
        if (char === '"') {
          inQuotes = true;
          continue;
        }
        if (char === ',') {
          pushField();
          continue;
        }
        if (char === '\n') {
          pushField();
          pushRow();
          continue;
        }
        if (char === '\r') {
          if (text[i + 1] === '\n') {
            i += 1;
          }
          pushField();
          pushRow();
          continue;
        }
        field += char;
      }
      if (field !== '' || currentRow.length) {
        pushField();
        pushRow();
      }
      if (inQuotes) {
        rows.__unclosedQuote = true;
        rows.__lineNumber = lineNumber;
      }
      return rows;
    };

    const validateCsvHeader = (header) => {
      const issues = [];
      if (!Array.isArray(header)) {
        issues.push('ヘッダー行が取得できませんでした。');
        return issues;
      }
      if (header.length !== CSV_COLUMNS.length) {
        issues.push(`列数が一致しません (期待: ${CSV_COLUMNS.length} 列 / 実際: ${header.length} 列)`);
      }
      const max = Math.max(header.length, CSV_COLUMNS.length);
      for (let idx = 0; idx < max; idx += 1) {
        const expected = CSV_COLUMNS[idx] ?? '(該当なし)';
        const actual = header[idx] ?? '(該当なし)';
        if (expected !== actual) {
          issues.push(`列${idx + 1}: 期待 "${expected}" / 実際 "${actual}"`);
        }
      }
      return issues;
    };

    const toNumberOrNull = (value) => {
      if (value === null || value === undefined) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;
      const num = Number(trimmed);
      return Number.isFinite(num) ? num : null;
    };

    const toIntegerOrNull = (value) => {
      const num = toNumberOrNull(value);
      if (num === null) return null;
      return Number.isInteger(num) ? num : null;
    };

    /*** error banner ***/
    const errorRoot = document.getElementById('error-root');
    const errorState = { logs: [], expanded: false, rollback: null };

    const renderErrorBanner = () => {
      if (!errorRoot) return;
      if (!errorState.logs.length) {
        errorRoot.classList.add('hidden');
        errorRoot.replaceChildren();
        return;
      }
      errorRoot.classList.remove('hidden');
      const container = createElem('div', { className: 'bg-red-900/90 text-red-50 px-4 py-3 shadow-lg border-b border-red-300' });
      const header = createElem('div', { className: 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between' });
      const title = createElem('div', { className: 'font-semibold', textContent: 'アプリでエラーが発生しました' });
      const actionWrap = createElem('div', { className: 'flex items-center gap-3' });
      const toggleBtn = createElem('button', {
        className: 'text-sm underline decoration-dotted',
        textContent: errorState.expanded ? '閉じる' : '詳細',
        attrs: { type: 'button' }
      });
      actionWrap.append(toggleBtn);
      if (typeof errorState.rollback === 'function') {
        const rollbackBtn = createElem('button', {
          className: 'text-sm font-semibold underline decoration-dotted text-red-100 hover:text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-200',
          textContent: '直前操作を取り消す',
          attrs: { type: 'button' }
        });
        rollbackBtn.addEventListener('click', () => {
          const handler = errorState.rollback;
          errorState.rollback = null;
          renderErrorBanner();
          if (handler) {
            try {
              handler();
            } catch (err) {
              pushError(`ロールバックに失敗しました: ${err.message || err}`);
            }
          }
        });
        actionWrap.append(rollbackBtn);
      }
      header.append(title, actionWrap);
      const logList = createElem('pre', { className: 'mt-2 text-xs bg-red-950/40 rounded-lg p-2 overflow-x-auto whitespace-pre-wrap' });
      logList.textContent = errorState.logs.map((log, idx) => `#${idx + 1}\n${log}`).join('\n\n');
      if (!errorState.expanded) logList.classList.add('hidden');
      toggleBtn.addEventListener('click', () => {
        errorState.expanded = !errorState.expanded;
        renderErrorBanner();
      });
      container.append(header, logList);
      errorRoot.replaceChildren(container);
    };

    const pushError = (message) => {
      errorState.logs.push(message);
      renderErrorBanner();
      if (typeof window.showError === 'function') {
        window.showError('アプリでエラーが発生しました', message);
      }
    };

    const showRecoverableError = (message, rollback) => {
      errorState.logs.push(message);
      errorState.rollback = typeof rollback === 'function' ? rollback : null;
      renderErrorBanner();
      if (typeof window.showError === 'function') {
        window.showError('アプリでエラーが発生しました', message);
      }
    };

    const clearRecoverableError = () => {
      errorState.rollback = null;
      renderErrorBanner();
    };

    const validationRoot = (() => {
      const base = createElem('div', {
        className: 'error-banner hidden',
        attrs: { id: 'validation-banner', role: 'alert', 'aria-live': 'assertive' }
      });
      if (errorRoot && errorRoot.parentNode) {
        errorRoot.insertAdjacentElement('afterend', base);
      } else {
        document.body.prepend(base);
      }
      return base;
    })();

    const validationState = { message: null };

    const renderValidationBanner = () => {
      if (!validationRoot) return;
      if (!validationState.message) {
        validationRoot.classList.add('hidden');
        validationRoot.replaceChildren();
        return;
      }
      validationRoot.classList.remove('hidden');
      const container = createElem('div', {
        className: 'bg-red-700 text-red-50 px-4 py-3 shadow-lg border-b border-red-300'
      });
      container.append(
        createElem('p', { className: 'text-sm font-semibold', textContent: validationState.message })
      );
      validationRoot.replaceChildren(container);
    };

    const showValidationError = (message) => {
      validationState.message = message;
      renderValidationBanner();
    };

    const clearValidationError = () => {
      validationState.message = null;
      renderValidationBanner();
    };

    window.addEventListener('error', (event) => {
      pushError(`${event.message}\n${event.filename || ''}:${event.lineno || ''}`);
    });
    window.addEventListener('unhandledrejection', (event) => {
      pushError(`Promiseエラー: ${event.reason}`);
    });

    /*** storage ***/
    const SCHEMA_VERSION = CSV_SCHEMA_VERSION;
    const STORAGE_NAMESPACE = 'muscle-app-core';
    const AUTO_BACKUP_KEY = `${STORAGE_NAMESPACE}:auto-backup`;
    class NamespacedStorage {
      constructor(namespace, version) {
        this.namespace = namespace;
        this.version = version;
      }
      _key(key) {
        return `${this.namespace}:${key}`;
      }
      _safeParse(raw) {
        try {
          return JSON.parse(raw);
        } catch (err) {
          return null;
        }
      }
      load(key, fallback) {
        const raw = localStorage.getItem(this._key(key));
        if (!raw) return cloneDeep(fallback);
        const parsed = this._safeParse(raw);
        if (!parsed || parsed.schema !== this.version) return cloneDeep(fallback);
        return parsed.data;
      }
      save(key, data) {
        const payload = JSON.stringify({ schema: this.version, data });
        localStorage.setItem(this._key(key), payload);
      }
      clearNamespace() {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (k && k.startsWith(`${this.namespace}:`)) keys.push(k);
        }
        keys.forEach((k) => localStorage.removeItem(k));
      }
    }

    const storage = new NamespacedStorage(STORAGE_NAMESPACE, SCHEMA_VERSION);

    const readAutoBackupSnapshot = () => {
      try {
        const raw = localStorage.getItem(AUTO_BACKUP_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return null;
        if (parsed.schemaVersion !== SCHEMA_VERSION) {
          return null;
        }
        return parsed;
      } catch (err) {
        return null;
      }
    };

    const createAutoBackupSnapshot = () => {
      if (!appData) return;
      try {
        const payload = {
          schemaVersion: SCHEMA_VERSION,
          device: getDeviceName(),
          savedAt: new Date().toISOString(),
          data: cloneDeep(appData)
        };
        localStorage.setItem(AUTO_BACKUP_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('自動バックアップの保存に失敗しました', err);
      }
    };

    const runSelfCheck = () => {
      const STATUS = Object.freeze({ PASS: 'pass', WARN: 'warn', FAIL: 'fail' });
      const LABELS = Object.freeze({
        [STATUS.PASS]: '良好',
        [STATUS.WARN]: '注意',
        [STATUS.FAIL]: '要対応'
      });

      const entries = [];
      let overall = STATUS.PASS;
      const snapshot = readAutoBackupSnapshot();
      const testFlags = (appData?.settings?.selfCheck?.testFlags) || {};
      const LOCK_PENDING_WARN_MS = 4000;
      const LOCK_PENDING_FAIL_MS = 15000;
      const BUFFER_WARN_MS = 5000;
      const BUFFER_FAIL_MS = 20000;

      const describeAge = (ms) => {
        if (typeof ms !== 'number' || !Number.isFinite(ms) || ms <= 0) return '1秒未満';
        if (ms < 1000) return '1秒未満';
        if (ms < 60000) return `約${Math.round(ms / 1000)}秒`;
        const minutes = ms / 60000;
        return `約${minutes.toFixed(minutes >= 10 ? 0 : 1)}分`;
      };

      const updateOverall = (status) => {
        if (status === STATUS.FAIL) {
          overall = STATUS.FAIL;
        } else if (status === STATUS.WARN && overall !== STATUS.FAIL) {
          overall = STATUS.WARN;
        }
      };

      const pushEntry = (title, status, detail) => {
        entries.push({ title, status, detail });
        updateOverall(status);
      };

      (() => {
        const status = initializationWarningCount > 0 ? STATUS.WARN : STATUS.PASS;
        const detail = initializationWarningCount > 0
          ? `初期化順序の警告: ${initializationWarningCount}件`
          : '初期化順序の警告は検出されていません。';
        pushEntry('初期化順序', status, detail);
      })();

      // 入力ロック監視
      (() => {
        const now = Date.now();
        const segments = [];
        let status = STATUS.PASS;
        const pendingDuration = typingState.pendingRender && typeof typingDiagnostics.pendingSince === 'number'
          ? Math.max(0, now - typingDiagnostics.pendingSince)
          : 0;
        segments.push(`ブロック回数: ${typingDiagnostics.blockedRenderCount}`);
        segments.push(`侵入回数: ${typingDiagnostics.breachCount}`);
        if (typingDiagnostics.lastBlockedAt) {
          segments.push(`最終ブロック: ${formatDate(typingDiagnostics.lastBlockedAt)}`);
        }
        if (typingDiagnostics.lastBlockedRoute) {
          segments.push(`最終ブロック画面: ${typingDiagnostics.lastBlockedRoute}`);
        }
        if (typingDiagnostics.lastBreachAt) {
          segments.push(`最終侵入: ${formatDate(typingDiagnostics.lastBreachAt)}`);
        }
        if (typingDiagnostics.lastBreachRoute) {
          segments.push(`最終侵入画面: ${typingDiagnostics.lastBreachRoute}`);
        }
        if (typingDiagnostics.breachCount > 0) {
          status = STATUS.FAIL;
        }
        if (typingState.pendingRender) {
          segments.push(`保留レンダー: ${describeAge(pendingDuration)}継続中`);
          if (pendingDuration > LOCK_PENDING_FAIL_MS) {
            status = STATUS.FAIL;
          } else if (status !== STATUS.FAIL && pendingDuration > LOCK_PENDING_WARN_MS) {
            status = STATUS.WARN;
          }
        } else {
          segments.push('保留レンダー: なし');
        }
        if (status !== STATUS.FAIL && testFlags.forceInputLockWarning) {
          status = STATUS.WARN;
          segments.push('テストフラグ: 入力ロック警告を強制しています。');
        }
        if (status === STATUS.PASS && typingDiagnostics.blockedRenderCount === 0) {
          segments.push('再描画試行は検出されていません。');
        }
        pushEntry('入力ロック監視', status, segments.join(' / '));
      })();

      // 未コミットバッファ
      (() => {
        const now = Date.now();
        const pending = Array.from(bufferedMutations.entries()).map(([key, entry]) => {
          const age = typeof entry?.timestamp === 'number' ? Math.max(0, now - entry.timestamp) : 0;
          const timerState = bufferTimers.has(key) ? bufferTimers.get(key) : undefined;
          let stage = 'タイマー未登録';
          if (timerState === null) stage = '入力編集中';
          else if (timerState) stage = 'コミット待機';
          else if (timerState === undefined) stage = 'タイマー未登録';
          else stage = '即時反映';
          return { key, age, stage };
        });
        let status = STATUS.PASS;
        let detail = '未コミットのバッファはありません。';
        if (pending.length > 0) {
          const failCount = pending.filter((item) => item.age > BUFFER_FAIL_MS).length;
          const warnCount = pending.filter((item) => item.age > BUFFER_WARN_MS).length;
          if (failCount > 0) {
            status = STATUS.FAIL;
          } else if (warnCount > 0) {
            status = STATUS.WARN;
          }
          const lines = pending.slice(0, 4).map((item) => {
            const seconds = item.age < 1000 ? '<1秒' : `約${Math.round(item.age / 1000)}秒`;
            return `${item.key}: ${seconds} (${item.stage})`;
          });
          if (pending.length > 4) {
            lines.push(`他${pending.length - 4}件のバッファがあります。`);
          }
          detail = `未コミット数: ${pending.length}\n${lines.join('\n')}`;
        }
        if (status !== STATUS.FAIL && testFlags.forceBufferWarning) {
          status = STATUS.WARN;
          detail = pending.length
            ? `${detail}\nテストフラグ: 未コミット警告を強制しています。`
            : 'テストフラグ: 未コミットバッファ警告を強制しています。';
        }
        pushEntry('未コミットバッファ', status, detail);
      })();

      // スキーマ整合
      (() => {
        let status = STATUS.PASS;
        let detail = '保存済みデータのスキーマは最新です。';
        try {
          const raw = localStorage.getItem(`${STORAGE_NAMESPACE}:${STORAGE_KEYS.DATA}`);
          if (!raw) {
            status = STATUS.WARN;
            detail = '保存済みデータが見つかりません。';
          } else {
            const parsed = JSON.parse(raw);
            if (!parsed || parsed.schema !== SCHEMA_VERSION) {
              status = STATUS.FAIL;
              detail = `期待スキーマ ${SCHEMA_VERSION} に一致しません。`;
            }
          }
        } catch (err) {
          status = STATUS.FAIL;
          detail = `検証中にエラー: ${err?.message || err}`;
        }
        pushEntry('スキーマ整合', status, detail);
      })();

      // 主要配列長
      (() => {
        let status = STATUS.PASS;
        const segments = [];
        const specs = [
          ['ワークアウト履歴', appData?.workouts],
          ['進行中の種目', appData?.currentWorkout?.exercises],
          ['テンプレート', appData?.templates],
          ['種目カタログ', appData?.settings?.exerciseCatalog]
        ];
        specs.forEach(([label, value]) => {
          if (!Array.isArray(value)) {
            status = STATUS.WARN;
            segments.push(`${label}: 不正な形式`);
          } else {
            segments.push(`${label}: ${value.length}`);
          }
        });
        pushEntry('主要配列長', status, segments.join(' / '));
      })();

      // 直近例外
      (() => {
        if (errorState.logs.length === 0) {
          pushEntry('直近例外', STATUS.PASS, '例外ログは記録されていません。');
        } else {
          const lastLog = errorState.logs[errorState.logs.length - 1];
          pushEntry('直近例外', STATUS.WARN, lastLog);
        }
      })();

      // 最後の保存時刻
      (() => {
        if (snapshot?.savedAt) {
          pushEntry('最後の保存時刻', STATUS.PASS, formatDate(snapshot.savedAt) || snapshot.savedAt);
        } else {
          pushEntry('最後の保存時刻', STATUS.WARN, '保存履歴が見つかりません。');
        }
      })();

      // バックアップ有無
      (() => {
        if (snapshot) {
          pushEntry('バックアップ有無', STATUS.PASS, '自動バックアップが利用可能です。');
        } else {
          pushEntry('バックアップ有無', STATUS.WARN, '自動バックアップが作成されていません。');
        }
      })();

      // 1RM が有限値か
      (() => {
        const invalid = [];
        const inspectWorkout = (workout, scopeLabel) => {
          if (!workout || !Array.isArray(workout.exercises)) return;
          workout.exercises.forEach((exercise) => {
            if (!Array.isArray(exercise?.sets)) return;
            exercise.sets.forEach((set, idx) => {
              const value = set?.oneRM;
              if (value === null || value === undefined || value === '') return;
              const numeric = Number(value);
              if (!Number.isFinite(numeric)) {
                invalid.push(`${scopeLabel} ${exercise?.name || exercise?.id || '未設定'} #${idx + 1}`);
              }
            });
          });
        };
        inspectWorkout(appData?.currentWorkout, '進行中');
        if (Array.isArray(appData?.workouts)) {
          appData.workouts.forEach((workout, idx) => inspectWorkout(workout, `履歴${idx + 1}`));
        }
        if (invalid.length) {
          pushEntry('1RM 整合性', STATUS.FAIL, `有限値ではない項目: ${invalid.slice(0, 5).join(', ')}${invalid.length > 5 ? ` 他${invalid.length - 5}件` : ''}`);
        } else {
          pushEntry('1RM 整合性', STATUS.PASS, 'すべて有限値または未計算です。');
        }
      })();

      // キー一意性
      (() => {
        const duplicates = [];
        const seenWorkouts = new Set();
        const seenExercises = new Set();
        const seenSupersets = new Set();
        const checkId = (scope, id) => {
          if (!id) {
            duplicates.push(`${scope}: ID 未設定`);
            return false;
          }
          return true;
        };
        const handleSet = (set, id, label) => {
          if (set.has(id)) {
            duplicates.push(`${label}: ${id}`);
          } else {
            set.add(id);
          }
        };
        const allWorkouts = [];
        if (appData?.currentWorkout) allWorkouts.push({ workout: appData.currentWorkout, scope: '進行中ワークアウト' });
        if (Array.isArray(appData?.workouts)) {
          appData.workouts.forEach((workout, idx) => {
            allWorkouts.push({ workout, scope: `履歴ワークアウト${idx + 1}` });
          });
        }
        allWorkouts.forEach(({ workout, scope }) => {
          if (!workout) return;
          if (checkId(scope, workout.id) && seenWorkouts.has(workout.id)) {
            duplicates.push(`${scope}: 重複ワークアウトID ${workout.id}`);
          }
          if (workout?.id) {
            handleSet(seenWorkouts, workout.id, '重複ワークアウトID');
          }
          if (Array.isArray(workout?.exercises)) {
            workout.exercises.forEach((exercise, idx) => {
              const exerciseScope = `${scope}の種目${idx + 1}`;
              if (checkId(exerciseScope, exercise?.id) && exercise?.id) {
                handleSet(seenExercises, exercise.id, '重複種目ID');
              }
            });
          }
          if (Array.isArray(workout?.supersets)) {
            workout.supersets.forEach((superset, idx) => {
              const supersetScope = `${scope}のスーパーセット${idx + 1}`;
              if (checkId(supersetScope, superset?.id) && superset?.id) {
                handleSet(seenSupersets, superset.id, '重複スーパーセットID');
              }
            });
          }
        });
        if (duplicates.length) {
          pushEntry('キー一意性', STATUS.FAIL, duplicates.slice(0, 5).join('\n') + (duplicates.length > 5 ? `\n他${duplicates.length - 5}件` : ''));
        } else {
          pushEntry('キー一意性', STATUS.PASS, '重複するIDは検出されませんでした。');
        }
      })();

      const summaryMessage = (() => {
        if (overall === STATUS.FAIL) return '重大な問題が検出されました。早急な対応を推奨します。';
        if (overall === STATUS.WARN) return '注意事項があります。詳細を確認してください。';
        return '重大な問題は検出されませんでした。';
      })();

      const reportLines = [
        `診断ステータス: ${LABELS[overall]}`,
        `診断時刻: ${formatDate(new Date().toISOString())}`,
        ...entries.map((entry) => `- ${entry.title}: ${LABELS[entry.status]} | ${entry.detail}`)
      ];

      return {
        status: overall,
        entries,
        summaryMessage,
        report: reportLines.join('\n'),
        labels: LABELS
      };
    };

    /*** modal api ***/
    const modalState = { activePromise: null, locked: false };

    const openModal = (buildContent, { cancelValue = null } = {}) => {
      if (modalState.locked) {
        return modalState.activePromise ?? Promise.resolve(cancelValue);
      }

      const body = document.body;
      const backdrop = createElem('div', { className: 'modal-backdrop' });
      const card = createElem('div', { className: 'modal-card relative' });
      backdrop.append(card);
      body.append(backdrop);
      body.classList.add('scroll-lock');

      modalState.locked = true;

      let resolvePromise;
      let rejectPromise;
      const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });

      modalState.activePromise = promise;

      let settled = false;
      let cleanupRan = false;

      const runCleanup = () => {
        if (cleanupRan) return;
        cleanupRan = true;
        document.removeEventListener('keydown', handleKeydown);
        backdrop.removeEventListener('click', handleOutsideClick);
        if (backdrop.parentNode) backdrop.remove();
        body.classList.remove('scroll-lock');
        modalState.activePromise = null;
        modalState.locked = false;
      };

      const finish = (value) => {
        if (settled) return;
        settled = true;
        runCleanup();
        resolvePromise(value);
      };

      const requestCancel = () => finish(cancelValue);

      const handleKeydown = (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          requestCancel();
        }
      };

      const handleOutsideClick = (event) => {
        if (event.target === backdrop) {
          requestCancel();
        }
      };

      const abortWithError = (error) => {
        if (settled) return;
        settled = true;
        runCleanup();
        rejectPromise(error);
      };

      document.addEventListener('keydown', handleKeydown);
      backdrop.addEventListener('click', handleOutsideClick);

      try {
        const { content, focus } = buildContent({ finish, cancel: requestCancel });
        if (content instanceof Node) {
          card.append(content);
        }
        if (typeof focus === 'function') {
          try {
            focus();
          } catch (focusError) {
            abortWithError(focusError);
          }
        }
      } catch (error) {
        abortWithError(error);
      }

      return promise;
    };

    const confirmAction = (message) => {
      return openModal(({ finish, cancel }) => {
        const header = createElem('div', { className: 'flex items-start justify-between gap-4 mb-4' });
        const closeBtn = createElem('button', {
          className: 'text-xl leading-none text-slate-400 hover:text-slate-700',
          textContent: '×',
          attrs: { type: 'button', 'aria-label': '閉じる' }
        });
        const requestCancel = () => cancel();
        closeBtn.addEventListener('click', requestCancel);
        header.append(
          createElem('p', { className: 'text-sm text-slate-800', textContent: message }),
          closeBtn
        );
        const btnWrap = createElem('div', { className: 'flex justify-end gap-2' });
        const cancelBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const okBtn = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'OK', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', requestCancel);
        okBtn.addEventListener('click', () => finish(true));
        btnWrap.append(cancelBtn, okBtn);
        const content = createElem('div', { children: [header, btnWrap] });
        return { content, focus: () => okBtn.focus() };
      }, { cancelValue: false }).then((value) => Boolean(value));
    };

    const pickFromList = (title, options) => {
      return openModal(({ finish, cancel }) => {
        const header = createElem('div', { className: 'mb-3 flex items-start justify-between gap-4' });
        const closeBtn = createElem('button', {
          className: 'text-xl leading-none text-slate-400 hover:text-slate-700',
          textContent: '×',
          attrs: { type: 'button', 'aria-label': '閉じる' }
        });
        const requestCancel = () => cancel();
        closeBtn.addEventListener('click', requestCancel);
        header.append(
          createElem('p', { className: 'text-sm font-semibold text-slate-800', textContent: title }),
          closeBtn
        );
        const list = createElem('div', { className: 'max-h-64 overflow-y-auto space-y-2' });
        options.forEach((opt) => {
          const btn = createElem('button', { className: 'w-full text-left px-3 py-2 rounded-lg border border-slate-200 hover:border-slate-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500', textContent: opt, attrs: { type: 'button' } });
          btn.addEventListener('click', () => finish(opt));
          list.append(btn);
        });
        const cancelBtn = createElem('button', { className: 'mt-4 btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', requestCancel);
        const firstButton = () => list.querySelector('button');
        const content = createElem('div', { children: [header, list, cancelBtn] });
        return { content, focus: () => { const btn = firstButton(); if (btn) btn.focus(); else cancelBtn.focus(); } };
      });
    };

    const promptText = (title, initialValue = '') => {
      return openModal(({ finish, cancel }) => {
        const label = createElem('label', { className: 'flex flex-col gap-2' });
        label.append(
          createElem('span', { className: 'text-sm font-semibold text-slate-800', textContent: title }),
          createElem('input', { className: 'input-base', attrs: { type: 'text' } })
        );
        const actions = createElem('div', { className: 'flex justify-end gap-2 mt-4' });
        const cancelBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const ok = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: '決定', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', cancel);
        const input = label.querySelector('input');
        if (initialValue) {
          input.value = initialValue;
          setTimeout(() => {
            input.setSelectionRange(0, input.value.length);
          }, 0);
        }
        ok.addEventListener('click', () => finish(input.value.trim() || null));
        actions.append(cancelBtn, ok);
        const content = createElem('div', { children: [label, actions] });
        return { content, focus: () => {
          input.focus();
          if (!initialValue) input.select();
        } };
      });
    };

    const showImportReport = (title, issues) => {
      const messages = Array.isArray(issues) && issues.length ? issues : ['詳細情報が見つかりませんでした。'];
      const backup = readAutoBackupSnapshot();
      return openModal(({ finish }) => {
        const header = createElem('div', { className: 'mb-3 flex items-start justify-between gap-4' });
        const heading = createElem('p', { className: 'text-sm font-semibold text-slate-800', textContent: title });
        const closeBtn = createElem('button', {
          className: 'text-xl leading-none text-slate-400 hover:text-slate-700',
          textContent: '×',
          attrs: { type: 'button', 'aria-label': '閉じる' }
        });
        closeBtn.addEventListener('click', () => finish());
        header.append(heading, closeBtn);

        const list = createElem('ul', { className: 'list-disc space-y-1 pl-5 text-sm text-slate-700 max-h-56 overflow-y-auto pr-1' });
        messages.slice(0, 50).forEach((msg) => {
          list.append(createElem('li', { textContent: msg }));
        });
        if (messages.length > 50) {
          list.append(createElem('li', { className: 'text-xs text-slate-500', textContent: `...ほか ${messages.length - 50} 件` }));
        }

        const backupInfo = backup
          ? createElem('div', {
              className: 'mt-3 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600',
              textContent: `最新の自動バックアップ: schema ${backup.schemaVersion ?? '-'} / device ${backup.device || '不明'} / 保存 ${backup.savedAt ? formatDate(backup.savedAt) : '不明'}`
            })
          : createElem('p', { className: 'mt-3 text-xs text-slate-500', textContent: '自動バックアップ情報はまだありません。' });

        const footer = createElem('div', { className: 'mt-4 flex justify-end' });
        const okBtn = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: '閉じる', attrs: { type: 'button' } });
        okBtn.addEventListener('click', () => finish());
        footer.append(okBtn);

        const content = createElem('div', { children: [header, list, backupInfo, footer] });
        return { content, focus: () => okBtn.focus() };
      });
    };

    /*** data model ***/
    const STORAGE_KEYS = Object.freeze({
      DATA: 'data'
    });

    const createInitialData = () => ({
      workouts: [],
      currentWorkout: {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        entryMode: 'superset',
        exercises: [],
        supersets: [],
        selectedPartKey: null
      },
      settings: {
        unit: 'kg',
        allowFreeInput: false,
        allowProvisionalValues: false,
        optionCatalogs: {
          exercise: cloneOptionEntries(DEFAULT_OPTION_CATALOGS.exercise),
          equipment: cloneOptionEntries(DEFAULT_OPTION_CATALOGS.equipment),
          attachment: cloneOptionEntries(DEFAULT_OPTION_CATALOGS.attachment),
          position: cloneOptionEntries(DEFAULT_OPTION_CATALOGS.position)
        },
        exerciseCatalog: DEFAULT_OPTION_CATALOGS.exercise.map((entry) => entry.key),
        lastSelectedPartKey: null,
        exercisePartHints: {},
        selfCheck: {
          testFlags: {
            forceInputLockWarning: false,
            forceBufferWarning: false
          }
        }
      },
      historyView: {
        exerciseKey: null
      },
      lastSupersetBlueprint: null,
      templates: []
    });

<!-- PATCH-START: SINGLE-AB-LABEL -->
    const WORKOUT_ENTRY_MODES = Object.freeze({ single: 'single', superset: 'superset' });
    const SUPERSET_GROUP_IDS = Object.freeze(['A', 'B']);
    const DEFAULT_SUPERSET_REST = 90;
    const generateSupersetLabel = (index, mode = WORKOUT_ENTRY_MODES.superset) => {
      const normalizedMode = mode === WORKOUT_ENTRY_MODES.single
        ? WORKOUT_ENTRY_MODES.single
        : WORKOUT_ENTRY_MODES.superset;
      const numericIndex = Math.max(0, Number(index) || 0);
      if (normalizedMode === WORKOUT_ENTRY_MODES.single) {
        return `Set ${numericIndex + 1}`;
      }
      const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let value = numericIndex;
      let label = '';
      while (value >= 0) {
        label = alphabet[value % alphabet.length] + label;
        value = Math.floor(value / alphabet.length) - 1;
      }
      return `Superset ${label}`;
    };
    const createSupersetId = () => `ss-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`;

    const normalizeEntryMode = (mode) => (mode === WORKOUT_ENTRY_MODES.single ? WORKOUT_ENTRY_MODES.single : WORKOUT_ENTRY_MODES.superset);
    const getGroupIdsForMode = (mode) => (mode === WORKOUT_ENTRY_MODES.single ? [null] : SUPERSET_GROUP_IDS);
<!-- PATCH-END: SINGLE-AB-LABEL -->

    const createSupersetSkeleton = ({
      id = createSupersetId(),
      label,
      restSeconds = DEFAULT_SUPERSET_REST,
      collapsed = false,
      mode = WORKOUT_ENTRY_MODES.superset
    } = {}) => {
      const entryMode = normalizeEntryMode(mode);
      return {
        id,
        label: typeof label === 'string' && label.trim()
          ? label
          : generateSupersetLabel(0, entryMode),
        restSeconds,
        collapsed,
        mode: entryMode,
        slots: getGroupIdsForMode(entryMode).map((groupId) => ({ groupId, exerciseId: null }))
      };
    };

    const normalizeSupersetSlots = (superset) => {
      if (!superset || typeof superset !== 'object') return;
      const mode = normalizeEntryMode(superset.mode);
      superset.mode = mode;
      const desiredGroupIds = getGroupIdsForMode(mode);
      if (!Array.isArray(superset.slots)) {
        const fallback = Array.isArray(superset.exerciseIds) ? superset.exerciseIds : [];
        superset.slots = desiredGroupIds.map((groupId, index) => ({
          groupId,
          exerciseId: fallback[index] || null
        }));
        return;
      }

      const normalized = superset.slots.map((slot) => ({
        groupId: slot?.groupId ?? (typeof slot?.role === 'string' ? slot.role : null),
        exerciseId: slot?.exerciseId ?? null
      }));

      const slots = [];
      const consumed = new Set();

      desiredGroupIds.forEach((groupId, index) => {
        let matchIndex = normalized.findIndex((slot, idx) => {
          if (consumed.has(idx)) return false;
          const candidateId = slot.groupId;
          if (groupId == null) {
            return candidateId == null;
          }
          return candidateId === groupId;
        });

        if (matchIndex === -1) {
          matchIndex = normalized.findIndex((slot, idx) => {
            if (consumed.has(idx)) return false;
            return slot.groupId == null;
          });
        }

        if (matchIndex === -1) {
          matchIndex = normalized.findIndex((slot, idx) => {
            if (consumed.has(idx)) return false;
            return typeof slot.groupId === 'string' && !desiredGroupIds.includes(slot.groupId);
          });
        }

        if (matchIndex !== -1) {
          consumed.add(matchIndex);
          const matched = normalized[matchIndex];
          slots.push({ groupId, exerciseId: matched.exerciseId });
        } else {
          slots.push({ groupId, exerciseId: null });
        }
      });

      superset.slots = slots;
    };

    const normalizeWorkout = (workout) => {
      if (!workout || typeof workout !== 'object') return;
      assertInitialized('createEmptySet', createEmptySet);
      ensureExerciseCatalogIntegrity();
      workout.entryMode = normalizeEntryMode(workout.entryMode);
      if (workout.selectedPartKey === undefined) {
        workout.selectedPartKey = null;
      } else {
        workout.selectedPartKey = normalizePartKey(workout.selectedPartKey);
      }
      if (!Array.isArray(workout.exercises)) workout.exercises = [];

      const exerciseMap = new Map();
      workout.exercises = workout.exercises.filter((exercise) => exercise && typeof exercise === 'object');
      workout.exercises.forEach((exercise) => {
        if (!exercise.id) {
          exercise.id = `ex-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`;
        }
        if (!Array.isArray(exercise.sets) || !exercise.sets.length) {
          exercise.sets = [normalizeSet({})];
        } else {
          exercise.sets = exercise.sets.map((set) => normalizeSet(set));
        }
        if (typeof exercise.groupId === 'string' && exercise.groupId.trim()) {
          exercise.groupId = exercise.groupId.trim();
        } else {
          exercise.groupId = null;
        }
        const nameSource = typeof exercise.nameKey === 'string' && exercise.nameKey
          ? exercise.nameKey
          : typeof exercise.name === 'string'
            ? exercise.name
            : '';
        const nameResult = ensureOptionEntry('exercise', nameSource, { allowCreate: true });
        exercise.nameKey = nameResult.key || null;
        exercise.name = nameResult.entry?.label || (typeof exercise.name === 'string' ? exercise.name : '');
        if (exercise.nameKey && !appData.settings.exerciseCatalog.includes(exercise.nameKey)) {
          appData.settings.exerciseCatalog.push(exercise.nameKey);
        }
        const equipmentResult = ensureOptionEntry('equipment', exercise.equipmentKey ?? exercise.equipment ?? '', {
          allowCreate: true
        });
        exercise.equipmentKey = equipmentResult.key || null;
        exercise.equipment = equipmentResult.entry?.label || '';
        const attachmentResult = ensureOptionEntry('attachment', exercise.attachmentKey ?? exercise.attachment ?? '', {
          allowCreate: true
        });
        exercise.attachmentKey = attachmentResult.key || null;
        exercise.attachment = attachmentResult.entry?.label || '';
        const positionResult = ensureOptionEntry('position', exercise.positionKey ?? exercise.position ?? '', {
          allowCreate: true
        });
        exercise.positionKey = positionResult.key || null;
        exercise.position = positionResult.entry?.label || '';
        exerciseMap.set(exercise.id, exercise);
      });

      if (!Array.isArray(workout.supersets)) {
        workout.supersets = workout.exercises.map((exercise, index) => {
          const superset = createSupersetSkeleton({
            id: createSupersetId(),
            label: generateSupersetLabel(index, WORKOUT_ENTRY_MODES.single),
            mode: WORKOUT_ENTRY_MODES.single
          });
          superset.slots[0].exerciseId = exercise?.id ?? null;
          return superset;
        });
      }

      workout.supersets = workout.supersets.filter((superset) => superset && typeof superset === 'object');
      workout.supersets.forEach((superset, index) => {
        if (!superset.id) superset.id = createSupersetId();
        const mode = normalizeEntryMode(superset.mode);
        superset.mode = mode;
        if (typeof superset.label !== 'string' || !superset.label.trim()) {
          superset.label = generateSupersetLabel(index, mode);
        }
        const restSeconds = Number(superset.restSeconds);
        superset.restSeconds = Number.isFinite(restSeconds)
          ? Math.max(10, Math.min(600, Math.round(restSeconds)))
          : DEFAULT_SUPERSET_REST;
        superset.collapsed = Boolean(superset.collapsed);
        normalizeSupersetSlots(superset);
        superset.slots.forEach((slot) => {
          if (!slot) return;
          if (slot.groupId != null && typeof slot.groupId !== 'string') {
            slot.groupId = String(slot.groupId);
          }
          if (slot.exerciseId && !exerciseMap.has(slot.exerciseId)) {
            slot.exerciseId = null;
          }
        });
      });

      const assigned = new Set();
      workout.supersets.forEach((superset) => {
        superset.slots.forEach((slot) => {
          if (!slot.exerciseId) return;
          const exercise = exerciseMap.get(slot.exerciseId);
          if (!exercise) {
            slot.exerciseId = null;
            return;
          }
          assigned.add(exercise.id);
          exercise.groupId = slot.groupId ?? null;
        });
      });

      workout.exercises.forEach((exercise) => {
        if (!assigned.has(exercise.id)) {
          exercise.groupId = null;
        }
      });

      workout.exercises.forEach((exercise) => {
        if (assigned.has(exercise.id)) return;
        let target = workout.supersets.find((superset) => superset.slots.some((slot) => !slot.exerciseId));
        if (!target) {
          target = createSupersetSkeleton({
            id: createSupersetId(),
            label: generateSupersetLabel(workout.supersets.length, WORKOUT_ENTRY_MODES.single),
            mode: WORKOUT_ENTRY_MODES.single
          });
          workout.supersets.push(target);
        }
        const slot = target.slots.find((item) => !item.exerciseId);
        if (slot) {
          slot.exerciseId = exercise.id;
          exercise.groupId = slot.groupId ?? null;
          assigned.add(exercise.id);
        }
      });
    };

    const loadData = () => {
      const stored = storage.load(STORAGE_KEYS.DATA, createInitialData());
      const base = createInitialData();
      const currentWorkout = {
        ...base.currentWorkout,
        ...(stored && typeof stored === 'object' ? stored.currentWorkout || {} : {})
      };
      const settings = {
        ...base.settings,
        ...(stored && typeof stored === 'object' ? stored.settings || {} : {})
      };
      const historyView = {
        ...base.historyView,
        ...(stored && typeof stored === 'object' ? stored.historyView || {} : {})
      };
      return {
        ...base,
        ...(stored && typeof stored === 'object' ? stored : {}),
        currentWorkout,
        settings,
        historyView
      };
    };

    let appData = loadData();
    if (!Array.isArray(appData.workouts)) appData.workouts = [];
    if (!appData.settings || typeof appData.settings !== 'object') {
      appData.settings = createInitialData().settings;
    }
    ensureOptionCatalogs(appData.settings);
    if (typeof appData.settings.allowFreeInput !== 'boolean') {
      appData.settings.allowFreeInput = false;
    }
    if (typeof appData.settings.allowProvisionalValues !== 'boolean') {
      appData.settings.allowProvisionalValues = false;
    }
    if (!appData.settings.selfCheck || typeof appData.settings.selfCheck !== 'object') {
      appData.settings.selfCheck = createInitialData().settings.selfCheck;
    }
    if (!appData.settings.selfCheck.testFlags || typeof appData.settings.selfCheck.testFlags !== 'object') {
      appData.settings.selfCheck.testFlags = { forceInputLockWarning: false, forceBufferWarning: false };
    } else {
      appData.settings.selfCheck.testFlags = {
        forceInputLockWarning: Boolean(appData.settings.selfCheck.testFlags.forceInputLockWarning),
        forceBufferWarning: Boolean(appData.settings.selfCheck.testFlags.forceBufferWarning)
      };
    }
    ensureExerciseCatalogIntegrity();
    normalizeExercisePartHints();
    appData.settings.lastSelectedPartKey = normalizePartKey(appData.settings.lastSelectedPartKey);
    if (!appData.historyView || typeof appData.historyView !== 'object') {
      appData.historyView = { exerciseKey: null };
    }
    if (appData.historyView.exerciseName && !appData.historyView.exerciseKey) {
      const { key } = ensureOptionEntry('exercise', appData.historyView.exerciseName, { allowCreate: true });
      appData.historyView.exerciseKey = key || null;
      delete appData.historyView.exerciseName;
    }
    if (appData.historyView.exerciseKey && !getExerciseLabelByKey(appData.historyView.exerciseKey)) {
      appData.historyView.exerciseKey = null;
    }
    normalizeWorkout(appData.currentWorkout);
    const initialPartKey = normalizePartKey(appData.currentWorkout.selectedPartKey)
      ?? appData.settings.lastSelectedPartKey
      ?? null;
    appData.currentWorkout.selectedPartKey = initialPartKey;
    appData.workouts.forEach((workout) => normalizeWorkout(workout));
    if (!Array.isArray(appData.templates)) appData.templates = [];
    createAutoBackupSnapshot();

    const persist = () => {
      storage.save(STORAGE_KEYS.DATA, appData);
      createAutoBackupSnapshot();
    };

    const resetData = () => {
      appData = createInitialData();
      oneRmMemo.clear();
      persist();
    };

    /*** 1RM memoization ***/
    const oneRmMemo = new Map();
    const compute1RM = (weight, reps) => {
      const w = safeNumber(weight);
      const r = safeNumber(reps);
      if (w === null || r === null || r <= 0 || w <= 0) return null;
      return Number((w * (1 + r / 30)).toFixed(2));
    };

    const getExerciseKey = (workoutId, exerciseId) => `${workoutId}:${exerciseId}`;

    const recomputeExercise = (workoutId, exercise) => {
      const key = getExerciseKey(workoutId, exercise.id);
      const analyses = exercise.sets.map((set) => applyProvisionalState(set));
      const signature = exercise.sets
        .map((set, idx) => {
          const marker = analyses[idx].isProvisional ? 'P' : 'F';
          return `${marker}:${set.weight ?? ''}|${set.reps ?? ''}`;
        })
        .join('::');
      const cached = oneRmMemo.get(key);
      if (cached && cached.signature === signature) {
        cached.values.forEach((val, idx) => {
          exercise.sets[idx].oneRM = analyses[idx].isProvisional ? null : val;
        });
        return;
      }
      const values = exercise.sets.map((set, idx) => {
        if (analyses[idx].isProvisional) return null;
        return compute1RM(set.weight, set.reps);
      });
      values.forEach((val, idx) => {
        exercise.sets[idx].oneRM = analyses[idx].isProvisional ? null : val;
      });
      oneRmMemo.set(key, { signature, values });
    };

    const recomputeAll = () => {
      appData.workouts.forEach((workout) => {
        workout.exercises.forEach((exercise) => recomputeExercise(workout.id, exercise));
      });
      appData.currentWorkout.exercises.forEach((exercise) => recomputeExercise(appData.currentWorkout.id, exercise));
    };
    recomputeAll();

    /*** router & state ***/
    const parseRoute = (hash) => {
      const normalized = (hash || '').trim();
      if (!normalized) return ROUTES.HOME;
      const matched = normalized.match(/^#\/?([a-z0-9_-]+)$/i);
      const route = matched ? matched[1].toLowerCase() : '';
      if (!route) return ROUTES.HOME;
      if (!ROUTE_VALUES.has(route)) return ROUTES.HOME;
      return route;
    };

    const buildHash = (route) => `#/${route}`;

    let appState = { route: SAFE_MODE ? ROUTES.WORKOUT : parseRoute(location.hash) };
    let lastStableState = { ...appState };
    let suppressHashEvent = false;
    let renderQueued = false;

    const requestRender = () => {
      if (renderQueued) return;
      renderQueued = true;
      queueMicrotask(() => {
        renderQueued = false;
        render(appState);
      });
    };

    const syncHashToRoute = (route) => {
      const target = buildHash(route);
      if (location.hash !== target) {
        suppressHashEvent = true;
        location.hash = target;
      }
    };

    const applyRoute = (route) => {
      const normalized = ROUTE_VALUES.has(route) ? route : ROUTES.HOME;
      const targetRoute = (() => {
        if (!SAFE_MODE) return normalized;
        if (normalized !== ROUTES.WORKOUT && typeof window.showError === 'function') {
          window.showError('安全モードが有効です', `現在は記録画面のみ利用できます (要求: ${normalized})`);
        }
        return ROUTES.WORKOUT;
      })();
      const previousState = { ...appState };
      const nextState = { ...appState, route: targetRoute };
      try {
        appState = nextState;
        render(appState);
        lastStableState = { ...appState };
        clearRecoverableError();
      } catch (err) {
        appState = previousState;
        syncHashToRoute(previousState.route);
        showRecoverableError(`画面の更新に失敗しました: ${err.message || err}`, () => {
          appState = { ...lastStableState };
          syncHashToRoute(lastStableState.route);
          render(appState);
        });
      }
    };

    const setHash = (route) => {
      const normalized = ROUTE_VALUES.has(route) ? route : ROUTES.HOME;
      if (SAFE_MODE && normalized !== ROUTES.WORKOUT) {
        if (typeof window.showError === 'function') {
          window.showError('安全モードが有効です', `現在は記録画面のみ利用できます (要求: ${normalized})`);
        }
        syncHashToRoute(ROUTES.WORKOUT);
        applyRoute(ROUTES.WORKOUT);
        return;
      }
      const target = buildHash(normalized);
      if (location.hash === target) {
        applyRoute(normalized);
        return;
      }
      suppressHashEvent = true;
      location.hash = target;
      applyRoute(normalized);
    };

    window.addEventListener('hashchange', () => {
      if (suppressHashEvent) {
        suppressHashEvent = false;
        return;
      }
      const route = parseRoute(location.hash);
      if (SAFE_MODE && route !== ROUTES.WORKOUT) {
        if (typeof window.showError === 'function') {
          window.showError('安全モードが有効です', `現在は記録画面のみ利用できます (要求: ${route})`);
        }
        syncHashToRoute(ROUTES.WORKOUT);
        applyRoute(ROUTES.WORKOUT);
        return;
      }
      applyRoute(route);
    });

    /*** chart manager ***/
    const createChartManager = (canvas) => {
      if (SAFE_MODE || typeof Chart === 'undefined' || !canvas) {
        return {
          update() {},
          destroy() {}
        };
      }
      const chart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: '推定1RM',
            data: [],
            borderColor: '#1d4ed8',
            backgroundColor: 'rgba(29, 78, 216, 0.15)',
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { color: '#1f2937' } },
            y: {
              ticks: { color: '#1f2937' },
              beginAtZero: true
            }
          },
          plugins: {
            legend: { labels: { color: '#1f2937', font: { weight: '600' } } }
          }
        }
      });
      return {
        update(labels, values) {
          chart.data.labels = labels;
          chart.data.datasets[0].data = values;
          chart.update();
        }
      };
    };

    const HISTORY_ITEM_GAP = 16;
    const DEFAULT_HISTORY_ITEM_HEIGHT = 320;
    const HISTORY_VIRTUAL_OVERSCAN = 6;
    const historyHeightCache = new Map();
    let historyListScrollTop = 0;

    let historyChartCanvas = null;
    let historyChartManager = null;
    let historyChartObserver = null;
    let historyChartHost = null;
    let historyChartPendingData = { labels: [], values: [] };

    const applyHistoryChartData = () => {
      if (!historyChartManager || !historyChartPendingData) return;
      const { labels, values } = historyChartPendingData;
      historyChartManager.update(labels, values);
    };

    const ensureHistoryChartObserver = () => {
      if (historyChartObserver || SAFE_MODE || typeof IntersectionObserver === 'undefined') return;
      historyChartObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          if (!historyChartCanvas) return;
          if (historyChartHost && entry.target !== historyChartHost) return;
          if (!historyChartManager) {
            historyChartManager = createChartManager(historyChartCanvas);
          }
          applyHistoryChartData();
          if (historyChartObserver && entry.target) {
            historyChartObserver.unobserve(entry.target);
          }
        });
      }, { threshold: 0.1 });
    };

    /*** render helpers ***/
    const appRoot = document.getElementById('app');
    const safeMode = createSafeModeController();
    safeMode.mount(appRoot);

    const heading = createElem('h1', { className: 'mb-6 text-2xl font-bold text-slate-900', textContent: '筋トレメモ' });
    const viewContainer = createElem('div', { className: 'space-y-6' });
    const viewHosts = {
      [ROUTES.HOME]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.HOME } }),
      [ROUTES.HISTORY]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.HISTORY } }),
      [ROUTES.SETTINGS]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.SETTINGS } }),
      [ROUTES.WORKOUT]: createElem('div', { className: 'space-y-6', attrs: { 'data-view': ROUTES.WORKOUT } })
    };
    Object.values(viewHosts).forEach((host) => {
      host.classList.add('hidden');
      viewContainer.append(host);
    });
    if (appRoot) {
      appRoot.append(heading, viewContainer);
    }

    const updateTabState = (activeRoute) => {
      document.querySelectorAll('.tab-button').forEach((tab) => {
        const route = tab.getAttribute('data-route');
        if (route === activeRoute) {
          tab.classList.add('text-blue-600', 'font-bold');
          tab.classList.remove('text-slate-800');
        } else {
          tab.classList.remove('text-blue-600', 'font-bold');
          tab.classList.add('text-slate-800');
        }
      });
    };

    const bindTabs = () => {
      document.querySelectorAll('.tab-button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const route = btn.getAttribute('data-route');
          if (SAFE_MODE && route !== ROUTES.WORKOUT) {
            if (typeof window.showError === 'function') {
              window.showError('安全モードが有効です', `現在は記録画面のみ利用できます (要求: ${route})`);
            }
            syncHashToRoute(ROUTES.WORKOUT);
            return;
          }
          if (ROUTE_VALUES.has(route)) setHash(route);
        });
      });
    };

    const createCard = (titleText, body, { headerNodes = [] } = {}) => {
      const headerChildren = [
        createElem('h2', { className: 'text-lg font-bold text-slate-800', textContent: titleText })
      ];
      headerNodes.forEach((node) => {
        if (node) headerChildren.push(node);
      });
      return createElem('section', {
        className: 'bg-white rounded-2xl shadow-sm border border-slate-200/70 p-5 mb-6',
        children: [
          createElem('header', {
            className: 'mb-4 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between',
            children: headerChildren
          }),
          body
        ]
      });
    };

    /*** actions ***/
      function createEmptySet() {
        return { weight: null, reps: null, oneRM: null, note: '', isProvisional: false };
      }

      function normalizeSet(input) {
        const base = createEmptySet();
        if (!input || typeof input !== 'object') {
          applyProvisionalState(base);
          return base;
        }
        const weight = safeNumber(input.weight);
        const reps = safeNumber(input.reps);
        if (weight !== null) base.weight = weight;
        if (reps !== null) base.reps = reps;
        base.note = typeof input.note === 'string' ? input.note : '';
        if (typeof input.isProvisional === 'boolean') {
          base.isProvisional = input.isProvisional;
        }
        applyProvisionalState(base);
        return base;
      }

    const workoutHasProvisionalSets = (workout) => {
      if (!workout || !Array.isArray(workout.exercises)) return false;
      return workout.exercises.some((exercise) =>
        Array.isArray(exercise?.sets) && exercise.sets.some((set) => Boolean(set?.isProvisional))
      );
    };

    const ensureExerciseCatalog = (name, partKey = null) => {
      const result = ensureOptionEntry('exercise', name, { allowCreate: true, partKey });
      if (!result.key) return null;
      ensureExerciseCatalogIntegrity();
      if (!appData.settings.exerciseCatalog.includes(result.key)) {
        appData.settings.exerciseCatalog.push(result.key);
      }
      return result.key;
    };

    const createExerciseEntity = (name, defaults = {}) => {
      const partKey = normalizePartKey(defaults.partKey) || getExercisePartByKey(defaults.nameKey) || null;
      const nameResult = ensureOptionEntry('exercise', defaults.nameKey ?? name ?? '', {
        allowCreate: true,
        partKey
      });
      const exercise = {
        id: `ex-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`,
        nameKey: nameResult.key || null,
        name: nameResult.entry?.label || (typeof name === 'string' ? normalizeLabelValue(name).trim() : ''),
        groupId: defaults.groupId ?? null,
        equipmentKey: null,
        equipment: '',
        attachmentKey: null,
        attachment: '',
        angle: defaults.angle ?? null,
        positionKey: null,
        position: '',
        performedOn: defaults.performedOn ?? getTodayDateValue(),
        intervalSeconds: defaults.intervalSeconds ?? null,
        sets: Array.isArray(defaults.sets) && defaults.sets.length
          ? defaults.sets.map((set) => normalizeSet(set))
          : [normalizeSet({})]
      };
      const equipmentResult = ensureOptionEntry('equipment', defaults.equipmentKey ?? defaults.equipment ?? '', {
        allowCreate: true
      });
      exercise.equipmentKey = equipmentResult.key || null;
      exercise.equipment = equipmentResult.entry?.label || '';
      const attachmentResult = ensureOptionEntry('attachment', defaults.attachmentKey ?? defaults.attachment ?? '', {
        allowCreate: true
      });
      exercise.attachmentKey = attachmentResult.key || null;
      exercise.attachment = attachmentResult.entry?.label || '';
      const positionResult = ensureOptionEntry('position', defaults.positionKey ?? defaults.position ?? '', {
        allowCreate: true
      });
      exercise.positionKey = positionResult.key || null;
      exercise.position = positionResult.entry?.label || '';
      if (exercise.nameKey && appData?.settings) {
        ensureExerciseCatalogIntegrity();
        if (!appData.settings.exerciseCatalog.includes(exercise.nameKey)) {
          appData.settings.exerciseCatalog.push(exercise.nameKey);
        }
      }
      return exercise;
    };

    const getExerciseOptionsForPart = (partKey) => {
      const normalized = normalizePartKey(partKey);
      const hints = (appData.settings && typeof appData.settings.exercisePartHints === 'object')
        ? appData.settings.exercisePartHints
        : {};
      const catalog = getOptionCatalog('exercise');
      const matched = [];
      const fallback = [];
      const seen = new Set();
      catalog.forEach((entry) => {
        if (!entry || !entry.key) return;
        const entryPart = normalizePartKey(entry.partKey) || normalizePartKey(hints[entry.key]);
        if (normalized) {
          if (entryPart === normalized) {
            if (!seen.has(entry.key)) {
              seen.add(entry.key);
              matched.push(entry);
            }
          } else if (!fallback.some((item) => item.key === entry.key)) {
            fallback.push(entry);
          }
        } else if (!seen.has(entry.key)) {
          seen.add(entry.key);
          matched.push(entry);
        }
      });
      const source = normalized && matched.length === 0 ? fallback : matched;
      const sorted = source.slice().sort((a, b) => a.label.localeCompare(b.label, 'ja'));
      return sorted;
    };

    const getActivePartKey = () => normalizePartKey(appData?.currentWorkout?.selectedPartKey);

    const recordExercisePartHint = (name, partKey) => {
      const normalized = normalizePartKey(partKey);
      if (!normalized) return;
      const result = ensureOptionEntry('exercise', name, { allowCreate: true, partKey: normalized });
      if (!result.key) return;
      if (!appData.settings.exercisePartHints || typeof appData.settings.exercisePartHints !== 'object') {
        appData.settings.exercisePartHints = {};
      }
      appData.settings.exercisePartHints[result.key] = normalized;
    };

    const refreshSupersetLabels = () => {
      appData.currentWorkout.supersets.forEach((superset, index) => {
        const mode = normalizeEntryMode(superset?.mode ?? appData.currentWorkout.entryMode);
        superset.mode = mode;
        superset.label = generateSupersetLabel(index, mode);
      });
    };

    const setCurrentWorkoutEntryMode = (mode) => {
      const nextMode = normalizeEntryMode(mode);
      if (appData.currentWorkout.entryMode === nextMode) return;
      appData.currentWorkout.entryMode = nextMode;
      persist();
      requestRender();
    };

    const setSelectedPartKey = (partKey) => {
      let normalized = normalizePartKey(partKey);
      const current = getActivePartKey();
      if (current === normalized) {
        if (normalized !== null) {
          normalized = null;
        } else {
          return;
        }
      }
      appData.currentWorkout.selectedPartKey = normalized;
      appData.settings.lastSelectedPartKey = normalized;
      persist();
      requestRender();
    };

    const addSuperset = () => {
      const index = appData.currentWorkout.supersets.length;
      const mode = normalizeEntryMode(appData.currentWorkout.entryMode);
      const label = generateSupersetLabel(index, mode);
      const superset = createSupersetSkeleton({
        id: createSupersetId(),
        label,
        restSeconds: DEFAULT_SUPERSET_REST,
        collapsed: false,
        mode
      });
      appData.currentWorkout.supersets.push(superset);
      refreshSupersetLabels();
      persist();
      requestRender();
    };

    const getExerciseById = (exerciseId) => appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);

    const getSupersetById = (supersetId) => appData.currentWorkout.supersets.find((sup) => sup.id === supersetId);

    const findExerciseContext = (exerciseId) => {
      const exercise = getExerciseById(exerciseId);
      if (!exercise) return null;
      const superset = appData.currentWorkout.supersets.find((item) =>
        item.slots.some((slot) => slot.exerciseId === exerciseId)
      );
      const slot = superset ? superset.slots.find((slot) => slot.exerciseId === exerciseId) : null;
      return { exercise, superset, slot };
    };

    const resolveBindingValue = (binding) => {
      if (!binding) return '';
      if (typeof binding.read === 'function') {
        return binding.read();
      }
      if (binding.type === 'superset') {
        const superset = getSupersetById(binding.supersetId);
        const value = superset ? superset[binding.field] : '';
        return value == null ? '' : value;
      }
      if (binding.type === 'exercise') {
        const context = findExerciseContext(binding.exerciseId);
        const exercise = context ? context.exercise : null;
        const value = exercise ? exercise[binding.field] : '';
        return value == null ? '' : value;
      }
      if (binding.type === 'set') {
        const context = findExerciseContext(binding.exerciseId);
        const exercise = context ? context.exercise : null;
        const set = exercise && Array.isArray(exercise.sets) ? exercise.sets[binding.setIndex] : null;
        const value = set ? set[binding.field] : '';
        return value == null ? '' : value;
      }
      return '';
    };

    const applyTypingPatch = () => {
      if (!typingState.active || !typingState.element || !typingState.binding) return false;
      if (!typingState.element.isConnected) {
        typingState.active = false;
        typingState.binding = null;
        typingState.element = null;
        typingState.route = null;
        typingState.pendingRender = false;
        typingDiagnostics.pendingSince = null;
        typingState.composing = false;
        return false;
      }
      const binding = typingState.binding;
      const applyFn = typeof binding.apply === 'function' ? binding.apply : applyInputValue;
      applyFn(typingState.element, resolveBindingValue(binding));
      if (typeof binding.sync === 'function') {
        try {
          binding.sync();
        } catch (err) {
          /* sync best effort */
        }
      }
      return true;
    };

    const ensureSupersetParity = (superset) => {
      if (!superset) return false;
      const lengths = superset.slots.map((slot) => {
        if (!slot.exerciseId) return 0;
        const exercise = getExerciseById(slot.exerciseId);
        return exercise ? exercise.sets.length : 0;
      });
      const targetLength = Math.max(1, ...lengths);
      let mutated = false;
      superset.slots.forEach((slot) => {
        if (!slot.exerciseId) return;
        const exercise = getExerciseById(slot.exerciseId);
        if (!exercise) return;
        while (exercise.sets.length < targetLength) {
          const newSet = createEmptySet();
          applyProvisionalState(newSet);
          exercise.sets.push(newSet);
          mutated = true;
        }
      });
      return mutated;
    };

    const addSupersetRound = (supersetId) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      ensureSupersetParity(superset);
      superset.slots.forEach((slot) => {
        if (!slot.exerciseId) return;
        const exercise = getExerciseById(slot.exerciseId);
        if (!exercise) return;
        const newSet = createEmptySet();
        applyProvisionalState(newSet);
        exercise.sets.push(newSet);
        recomputeExercise(appData.currentWorkout.id, exercise);
      });
      persist();
      requestRender();
    };

    const duplicateSupersetRound = (supersetId, setIndex) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      ensureSupersetParity(superset);
      superset.slots.forEach((slot) => {
        if (!slot.exerciseId) return;
        const exercise = getExerciseById(slot.exerciseId);
        if (!exercise) return;
        const baseSet = exercise.sets[setIndex];
        if (!baseSet) return;
        const cloned = createEmptySet();
        cloned.weight = baseSet.weight;
        cloned.reps = baseSet.reps;
        cloned.note = baseSet.note;
        applyProvisionalState(cloned);
        exercise.sets.splice(setIndex + 1, 0, cloned);
        recomputeExercise(appData.currentWorkout.id, exercise);
      });
      persist();
      requestRender();
    };

    const removeSupersetRound = (supersetId, setIndex) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      const remainingLengths = [];
      superset.slots.forEach((slot) => {
        if (!slot.exerciseId) return;
        const exercise = getExerciseById(slot.exerciseId);
        if (!exercise) return;
        if (exercise.sets.length <= 1) return;
        exercise.sets.splice(setIndex, 1);
        recomputeExercise(appData.currentWorkout.id, exercise);
        remainingLengths.push(exercise.sets.length);
      });
      if (!remainingLengths.length) return;
      persist();
      requestRender();
    };

    const duplicateSuperset = (supersetId) => {
      const source = getSupersetById(supersetId);
      if (!source) return;
      const clone = createSupersetSkeleton({
        id: createSupersetId(),
        label: source.label,
        restSeconds: source.restSeconds,
        collapsed: false,
        mode: source.mode
      });
      source.slots.forEach((slot, slotIndex) => {
        if (!slot.exerciseId) return;
        const exercise = getExerciseById(slot.exerciseId);
        if (!exercise) return;
        ensureExerciseCatalog(exercise.nameKey ?? exercise.name, getExercisePartByKey(exercise.nameKey));
        const newExercise = createExerciseEntity(exercise.nameKey ?? exercise.name, {
          equipmentKey: exercise.equipmentKey,
          attachmentKey: exercise.attachmentKey,
          angle: exercise.angle,
          positionKey: exercise.positionKey,
          intervalSeconds: exercise.intervalSeconds,
          sets: exercise.sets.map((set) => ({ weight: set.weight, reps: set.reps, note: set.note }))
        });
        appData.currentWorkout.exercises.push(newExercise);
        const targetSlot = clone.slots.find((entry) => entry.groupId === slot.groupId) || clone.slots[slotIndex];
        if (targetSlot) {
          targetSlot.exerciseId = newExercise.id;
          newExercise.groupId = targetSlot.groupId ?? null;
        }
        recomputeExercise(appData.currentWorkout.id, newExercise);
      });
      const insertIndex = appData.currentWorkout.supersets.indexOf(source) + 1;
      appData.currentWorkout.supersets.splice(insertIndex, 0, clone);
      refreshSupersetLabels();
      persist();
      requestRender();
    };

    const deleteSuperset = async (supersetId) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      if (!(await confirmAction('このスーパーセットを削除しますか？'))) return;
      const exerciseIds = superset.slots.map((slot) => slot.exerciseId).filter(Boolean);
      appData.currentWorkout.exercises = appData.currentWorkout.exercises.filter((exercise) => !exerciseIds.includes(exercise.id));
      appData.currentWorkout.supersets = appData.currentWorkout.supersets.filter((item) => item.id !== supersetId);
      stopSupersetTimer(supersetId);
      supersetTimers.delete(supersetId);
      refreshSupersetLabels();
      persist();
      requestRender();
    };

    const toggleSupersetCollapsed = (supersetId) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      superset.collapsed = !superset.collapsed;
      persist();
      requestRender();
    };

    const setSupersetSlotExercise = (supersetId, groupId, rawValue) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      const slot = superset.slots.find((item) => item.groupId === groupId);
      if (!slot) return;
      const trimmed = typeof rawValue === 'string' ? rawValue.trim() : '';
      if (!trimmed) {
        if (slot.exerciseId) {
          const removed = removeExerciseFromSuperset(slot.exerciseId);
          if (removed) {
            persist();
            requestRender();
          }
        }
        return;
      }
      const { key } = ensureOptionEntry('exercise', trimmed, {
        allowCreate: appData.settings.allowFreeInput,
        partKey: getActivePartKey()
      });
      if (!key) return;
      const activePart = getActivePartKey();
      const resolvedPart = activePart || getExercisePartByKey(key);
      if (resolvedPart) {
        recordExercisePartHint(key, resolvedPart);
      }
      ensureExerciseCatalog(key, resolvedPart);
      let exercise = slot.exerciseId ? getExerciseById(slot.exerciseId) : null;
      if (exercise) {
        exercise.nameKey = key;
        exercise.name = getExerciseLabelByKey(key) || exercise.name;
        recomputeExercise(appData.currentWorkout.id, exercise);
      } else {
        exercise = createExerciseEntity(key, { partKey: resolvedPart });
        appData.currentWorkout.exercises.push(exercise);
        slot.exerciseId = exercise.id;
        exercise.groupId = slot.groupId ?? null;
        recomputeExercise(appData.currentWorkout.id, exercise);
      }
      persist();
      requestRender();
    };

    const commitSupersetField = (supersetId, field, rawValue) => {
      const superset = getSupersetById(supersetId);
      if (!superset) {
        return { success: false, message: '対象のスーパーセットが見つかりません。' };
      }
      if (field === 'restSeconds') {
        const num = safeNumber(rawValue);
        if (num === null) {
          return { success: false, message: '休憩秒数には数値を入力してください。' };
        }
        const value = Math.max(10, Math.min(600, Math.round(num)));
        superset.restSeconds = value;
        persist();
        return { success: true, rerender: false };
      }
      if (field === 'collapsed') {
        superset.collapsed = Boolean(rawValue);
        persist();
        return { success: true, rerender: true };
      }
      return { success: false, message: '不明なフィールドです。' };
    };

    const scheduleSupersetFieldUpdate = (supersetId, field, value) => {
      const key = `superset:${supersetId}:${field}`;
      scheduleBufferedCommit(key, value, (payload) => commitSupersetField(supersetId, field, payload));
    };

    const removeExerciseFromSuperset = (exerciseId) => {
      const context = findExerciseContext(exerciseId);
      if (!context) return false;
      const { superset, slot } = context;
      appData.currentWorkout.exercises = appData.currentWorkout.exercises.filter((exercise) => exercise.id !== exerciseId);
      if (superset && slot) {
        slot.exerciseId = null;
        const hasExercise = superset.slots.some((entry) => entry.exerciseId);
        if (!hasExercise) {
          appData.currentWorkout.supersets = appData.currentWorkout.supersets.filter((item) => item.id !== superset.id);
        }
      }
      refreshSupersetLabels();
      return true;
    };

    const captureWorkoutBlueprint = (workout, { includeSetValues = false } = {}) => {
      if (!workout || !Array.isArray(workout.supersets)) return [];
      const exerciseMap = new Map((workout.exercises || []).map((exercise) => [exercise.id, exercise]));
      return workout.supersets.map((superset) => ({
        label: superset?.label ?? '',
        restSeconds: superset?.restSeconds,
        mode: normalizeEntryMode(superset?.mode),
        slots: Array.isArray(superset?.slots)
          ? superset.slots.map((slot) => {
              const exercise = slot?.exerciseId ? exerciseMap.get(slot.exerciseId) : null;
              const base = {
                groupId: slot?.groupId ?? (typeof slot?.role === 'string' ? slot.role : null),
                partKey: exercise ? getExercisePartByKey(exercise.nameKey) : null,
                nameKey: exercise?.nameKey ?? null,
                name: exercise ? exercise.name : null,
                equipmentKey: exercise?.equipmentKey ?? null,
                equipment: exercise?.equipment ?? '',
                attachmentKey: exercise?.attachmentKey ?? null,
                attachment: exercise?.attachment ?? '',
                angle: exercise?.angle ?? null,
                positionKey: exercise?.positionKey ?? null,
                position: exercise?.position ?? '',
                intervalSeconds: exercise?.intervalSeconds ?? null
              };
              if (includeSetValues) {
                base.sets = Array.isArray(exercise?.sets)
                  ? exercise.sets.map((set) => ({
                      weight: set?.weight ?? null,
                      reps: set?.reps ?? null,
                      note: set?.note ?? ''
                    }))
                  : [];
              } else {
                base.setCount = exercise?.sets?.length ?? 1;
              }
              return base;
            })
          : []
      }));
    };

    const buildSupersetBlueprint = (workout) => captureWorkoutBlueprint(workout, { includeSetValues: false });

    const buildWorkoutTemplateBlueprint = (workout) => captureWorkoutBlueprint(workout, { includeSetValues: true });

    const restoreSupersetBlueprint = () => {
      const blueprint = appData.lastSupersetBlueprint;
      if (!Array.isArray(blueprint) || !blueprint.length) return;
      blueprint.forEach((config, index) => {
        const mode = normalizeEntryMode(config?.mode);
        const superset = createSupersetSkeleton({
          id: createSupersetId(),
          label: generateSupersetLabel(index, mode),
          restSeconds: Number.isFinite(Number(config?.restSeconds))
            ? Math.max(10, Math.min(600, Math.round(Number(config.restSeconds))))
            : DEFAULT_SUPERSET_REST,
          collapsed: false,
          mode
        });
        config.slots.forEach((slotConfig) => {
          if (!slotConfig || !slotConfig.nameKey && !slotConfig.name) return;
          const partKey = normalizePartKey(slotConfig.partKey)
            || (slotConfig.nameKey ? getExercisePartByKey(slotConfig.nameKey) : null);
          const exerciseKey = slotConfig.nameKey ?? slotConfig.name;
          ensureExerciseCatalog(exerciseKey, partKey);
          const exercise = createExerciseEntity(exerciseKey, {
            partKey,
            equipmentKey: slotConfig.equipmentKey ?? slotConfig.equipment ?? '',
            attachmentKey: slotConfig.attachmentKey ?? slotConfig.attachment ?? '',
            angle: slotConfig.angle,
            positionKey: slotConfig.positionKey ?? slotConfig.position ?? '',
            intervalSeconds: slotConfig.intervalSeconds
          });
          const desiredCount = Array.isArray(slotConfig.sets) && slotConfig.sets.length
            ? slotConfig.sets.length
            : Math.max(1, Number(slotConfig.setCount) || 1);
          while (exercise.sets.length < desiredCount) {
            const newSet = createEmptySet();
            applyProvisionalState(newSet);
            exercise.sets.push(newSet);
          }
          appData.currentWorkout.exercises.push(exercise);
          const groupId = slotConfig.groupId ?? (typeof slotConfig.role === 'string' ? slotConfig.role : null);
          const slotIndex = superset.slots.findIndex((slot) => slot.groupId === groupId);
          if (slotIndex !== -1) {
            superset.slots[slotIndex].exerciseId = exercise.id;
            exercise.groupId = superset.slots[slotIndex].groupId ?? null;
          }
          recomputeExercise(appData.currentWorkout.id, exercise);
        });
        appData.currentWorkout.supersets.push(superset);
      });
      refreshSupersetLabels();
    };

    const supersetTimers = new Map();

    const getSupersetTimerState = (supersetId) => {
      let state = supersetTimers.get(supersetId);
      if (!state) {
        state = { active: false, remaining: 0, intervalId: null, updater: null };
        supersetTimers.set(supersetId, state);
      }
      return state;
    };

    const stopSupersetTimer = (supersetId) => {
      const state = supersetTimers.get(supersetId);
      if (!state) return;
      if (state.intervalId) {
        clearInterval(state.intervalId);
        state.intervalId = null;
      }
      state.active = false;
      state.remaining = 0;
      if (typeof state.updater === 'function') {
        state.updater(0, false);
      }
    };

    const startSupersetTimer = (supersetId) => {
      const superset = getSupersetById(supersetId);
      if (!superset) return;
      const state = getSupersetTimerState(supersetId);
      if (state.active) {
        stopSupersetTimer(supersetId);
        return;
      }
      const duration = Math.max(10, Number(superset.restSeconds) || DEFAULT_SUPERSET_REST);
      state.active = true;
      state.remaining = duration;
      if (typeof state.updater === 'function') {
        state.updater(state.remaining, true);
      }
      if (state.intervalId) {
        clearInterval(state.intervalId);
      }
      state.intervalId = setInterval(() => {
        state.remaining -= 1;
        if (typeof state.updater === 'function') {
          state.updater(state.remaining, state.active);
        }
        if (state.remaining <= 0) {
          stopSupersetTimer(supersetId);
        }
      }, 1000);
    };

    const attachTimerUpdater = (supersetId, updater) => {
      const state = getSupersetTimerState(supersetId);
      state.updater = updater;
      updater(state.remaining, state.active);
    };

    const resetAllSupersetTimers = () => {
      supersetTimers.forEach((_, key) => stopSupersetTimer(key));
      supersetTimers.clear();
    };

    const sanitizeTemplateSets = (sets) => {
      if (!Array.isArray(sets)) return [];
      return sets.map((set) => normalizeSet(set));
    };

    const createWorkoutFromBlueprint = (blueprint, { startedAt = Date.now() } = {}) => {
      if (!Array.isArray(blueprint) || !blueprint.length) return null;
      const workout = {
        id: `current-${Date.now()}`,
        startedAt,
        entryMode: WORKOUT_ENTRY_MODES.superset,
        exercises: [],
        supersets: [],
        selectedPartKey: normalizePartKey(appData?.settings?.lastSelectedPartKey)
      };
      const today = getTodayDateValue();
      blueprint.forEach((config, index) => {
        if (!config) return;
        const mode = normalizeEntryMode(config?.mode);
        const superset = createSupersetSkeleton({
          id: createSupersetId(),
          label:
            typeof config.label === 'string' && config.label.trim()
              ? config.label.trim()
              : generateSupersetLabel(workout.supersets.length, mode),
          restSeconds: (() => {
            const value = safeNumber(config.restSeconds);
            if (value === null) return DEFAULT_SUPERSET_REST;
            return Math.max(10, Math.min(600, Math.round(value)));
          })(),
          collapsed: false,
          mode
        });
        const slotMap = new Map(superset.slots.map((slot) => [slot.groupId, slot]));
        if (Array.isArray(config.slots)) {
          config.slots.forEach((slotConfig) => {
            if (!slotConfig) return;
            const groupId = slotConfig.groupId ?? (typeof slotConfig.role === 'string' ? slotConfig.role : null);
            const slot = slotMap.get(groupId);
            if (!slot) return;
            if (!slotConfig.nameKey && !slotConfig.name) return;
            const partKey = normalizePartKey(slotConfig.partKey)
              || (slotConfig.nameKey ? getExercisePartByKey(slotConfig.nameKey) : null);
            const exerciseKey = slotConfig.nameKey ?? slotConfig.name;
            ensureExerciseCatalog(exerciseKey, partKey);
            const sanitizedSets = sanitizeTemplateSets(slotConfig.sets);
            const desiredSets = sanitizedSets.length
              ? sanitizedSets
              : Array.from(
                  { length: Math.max(1, Number(slotConfig.setCount) || 1) },
                  () => {
                    const newSet = createEmptySet();
                    applyProvisionalState(newSet);
                    return newSet;
                  }
                );
            const exercise = createExerciseEntity(exerciseKey, {
              partKey,
              equipmentKey: slotConfig.equipmentKey ?? slotConfig.equipment ?? '',
              attachmentKey: slotConfig.attachmentKey ?? slotConfig.attachment ?? '',
              angle: slotConfig.angle,
              positionKey: slotConfig.positionKey ?? slotConfig.position ?? '',
              intervalSeconds: slotConfig.intervalSeconds,
              performedOn: today,
              sets: desiredSets
            });
            workout.exercises.push(exercise);
            exercise.groupId = slot.groupId ?? null;
            slot.exerciseId = exercise.id;
            recomputeExercise(workout.id, exercise);
          });
        }
        workout.supersets.push(superset);
      });
      if (blueprint.length) {
        workout.entryMode = normalizeEntryMode(blueprint[0]?.mode);
      }
      workout.supersets = workout.supersets.filter((superset) =>
        superset.slots.some((slot) => slot.exerciseId)
      );
      if (!workout.supersets.length) return null;
      normalizeWorkout(workout);
      workout.exercises.forEach((exercise) => recomputeExercise(workout.id, exercise));
      return workout;
    };

    const replaceCurrentWorkout = (nextWorkout) => {
      if (!nextWorkout) return false;
      resetAllSupersetTimers();
      appData.currentWorkout = nextWorkout;
      normalizeWorkout(appData.currentWorkout);
      appData.currentWorkout.startedAt = nextWorkout.startedAt ?? Date.now();
      appData.currentWorkout.selectedPartKey = normalizePartKey(appData.currentWorkout.selectedPartKey)
        ?? appData.settings.lastSelectedPartKey
        ?? null;
      appData.currentWorkout.exercises.forEach((exercise) => recomputeExercise(appData.currentWorkout.id, exercise));
      appData.lastSupersetBlueprint = buildSupersetBlueprint(appData.currentWorkout);
      persist();
      requestRender();
      clearValidationError();
      return true;
    };

    const buildTemplateEntity = (name, blueprint) => ({
      id: `tpl-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`,
      name,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      blueprint
    });

    const getTemplateById = (templateId) => appData.templates.find((tpl) => tpl.id === templateId);

    const applyTemplateById = (templateId) => {
      const template = getTemplateById(templateId);
      if (!template || !Array.isArray(template.blueprint)) {
        showValidationError('テンプレートを読み込めませんでした。');
        return;
      }
      const nextWorkout = createWorkoutFromBlueprint(template.blueprint, { startedAt: Date.now() });
      if (!nextWorkout) {
        showValidationError('テンプレートに有効な構成がありません。');
        return;
      }
      if (replaceCurrentWorkout(nextWorkout)) {
        template.updatedAt = Date.now();
        persist();
      }
    };

    const startWorkoutFromLastHistory = () => {
      if (!appData.workouts.length) {
        showValidationError('前回の履歴がありません。');
        return;
      }
      const lastWorkout = cloneDeep(appData.workouts[0]);
      normalizeWorkout(lastWorkout);
      const blueprint = buildWorkoutTemplateBlueprint(lastWorkout);
      const nextWorkout = createWorkoutFromBlueprint(blueprint, { startedAt: Date.now() });
      if (!nextWorkout) {
        showValidationError('前回の構成を読み込めませんでした。');
        return;
      }
      replaceCurrentWorkout(nextWorkout);
    };

    const saveCurrentWorkoutAsTemplate = async () => {
      if (!appData.currentWorkout.supersets.length) {
        showValidationError('保存できるスーパーセットがありません。');
        return;
      }
      const name = await promptText('テンプレート名を入力');
      if (!name) return;
      const blueprint = buildWorkoutTemplateBlueprint(appData.currentWorkout);
      if (!Array.isArray(blueprint) || !blueprint.length) {
        showValidationError('テンプレートに保存できる構成が見つかりませんでした。');
        return;
      }
      const existing = appData.templates.find((tpl) => tpl.name === name);
      if (existing) {
        const ok = await confirmAction(`「${name}」を上書きしますか？`);
        if (!ok) return;
        existing.blueprint = blueprint;
        existing.updatedAt = Date.now();
        persist();
        requestRender();
        clearValidationError();
        return;
      }
      const template = buildTemplateEntity(name, blueprint);
      appData.templates.push(template);
      persist();
      requestRender();
      clearValidationError();
    };

    const renameTemplate = async (templateId) => {
      const template = getTemplateById(templateId);
      if (!template) return;
      const value = await promptText('テンプレート名を変更', template.name);
      if (!value) return;
      if (appData.templates.some((tpl) => tpl.id !== templateId && tpl.name === value)) {
        showValidationError('同じ名前のテンプレートが既に存在します。');
        return;
      }
      template.name = value;
      template.updatedAt = Date.now();
      persist();
      requestRender();
      clearValidationError();
    };

    const deleteTemplate = async (templateId) => {
      const template = getTemplateById(templateId);
      if (!template) return;
      const ok = await confirmAction(`テンプレート「${template.name}」を削除しますか？`);
      if (!ok) return;
      appData.templates = appData.templates.filter((tpl) => tpl.id !== templateId);
      persist();
      requestRender();
      clearValidationError();
    };

    const getSortedTemplates = () =>
      appData.templates
        .slice()
        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));

    const pickTemplateId = async (title) => {
      if (!appData.templates.length) {
        showValidationError('保存されたテンプレートはまだありません。');
        return null;
      }
      const sorted = getSortedTemplates();
      const selection = await pickFromList(title, sorted.map((tpl) => tpl.name));
      if (!selection) return null;
      const target = sorted.find((tpl) => tpl.name === selection);
      return target ? target.id : null;
    };

    const overwriteTemplateWithCurrentWorkout = async (templateId) => {
      const template = getTemplateById(templateId);
      if (!template) return;
      if (!appData.currentWorkout.supersets.length) {
        showValidationError('上書きできるスーパーセットがありません。');
        return;
      }
      const blueprint = buildWorkoutTemplateBlueprint(appData.currentWorkout);
      if (!Array.isArray(blueprint) || !blueprint.length) {
        showValidationError('テンプレートに保存できる構成が見つかりませんでした。');
        return;
      }
      const ok = await confirmAction(`テンプレート「${template.name}」を上書きしますか？`);
      if (!ok) return;
      template.blueprint = blueprint;
      template.updatedAt = Date.now();
      persist();
      requestRender();
      clearValidationError();
    };

    const supersetFocusRegistry = new Map();
    const setCollapseMemory = new Map();
    const buildSetCollapseKey = (supersetId, groupId, index) => `${supersetId}:${groupId ?? 'solo'}:${index}`;
    const getSetCollapsedState = (key, defaultValue = false) => {
      if (!setCollapseMemory.has(key)) {
        setCollapseMemory.set(key, Boolean(defaultValue));
      }
      return Boolean(setCollapseMemory.get(key));
    };
    const setSetCollapsedState = (key, collapsed) => {
      setCollapseMemory.set(key, Boolean(collapsed));
    };

    const registerSupersetFocusInput = (supersetId, input) => {
      if (!input) return;
      if (!supersetFocusRegistry.has(supersetId)) {
        supersetFocusRegistry.set(supersetId, []);
      }
      supersetFocusRegistry.get(supersetId).push(input);
    };

    const bindSupersetFocusNavigation = (supersetId, input) => {
      input.addEventListener('keydown', (event) => {
        if (event.key !== 'Enter') return;
        const list = supersetFocusRegistry.get(supersetId) || [];
        const index = list.indexOf(input);
        if (index === -1) return;
        event.preventDefault();
        const next = event.shiftKey ? list[index - 1] : list[index + 1];
        if (next) {
          next.focus();
        }
      });
    };

    const typingDiagnostics = {
      blockedRenderCount: 0,
      lastBlockedRoute: null,
      lastBlockedAt: null,
      breachCount: 0,
      lastBreachRoute: null,
      lastBreachAt: null,
      pendingSince: null
    };

    const typingBindings = new WeakMap();
    const typingState = {
      active: false,
      binding: null,
      element: null,
      route: null,
      pendingRender: false,
      composing: false
    };

    const registerTypingTarget = (element, binding) => {
      if (!element || !binding) return;
      typingBindings.set(element, binding);
    };

    const applyInputValue = (element, value) => {
      if (!element) return;
      const next = value == null ? '' : String(value);
      if (element.value === next) return;
      const { selectionStart, selectionEnd } = element;
      element.value = next;
      if (document.activeElement === element) {
        try {
          const start = typeof selectionStart === 'number' ? Math.min(selectionStart, next.length) : next.length;
          const end = typeof selectionEnd === 'number' ? Math.min(selectionEnd, next.length) : next.length;
          if (typeof element.setSelectionRange === 'function') {
            element.setSelectionRange(start, end);
          }
        } catch (err) {
          /* selection adjustment best effort */
        }
      }
    };

    const INPUT_BUFFER_DELAY = 300;
    const bufferedMutations = new Map();
    const bufferTimers = new Map();

    const armBufferedCommit = (key) => {
      if (!bufferedMutations.has(key)) return;
      const timer = setTimeout(() => {
        bufferTimers.delete(key);
        attemptBufferedCommit(key);
      }, INPUT_BUFFER_DELAY);
      bufferTimers.set(key, timer);
    };

    const handleCommitOutcome = (key, outcome) => {
      if (!outcome || typeof outcome !== 'object') {
        showValidationError('入力値を保存できませんでした。');
        return;
      }
      if (!outcome.success) {
        showValidationError(outcome.message || '入力値が正しくありません。');
        return;
      }
      bufferedMutations.delete(key);
      clearValidationError();
      if (typingState.binding && typingState.binding.key === key) {
        applyTypingPatch();
      }
      if (outcome.rerender) {
        requestRender();
      }
    };

    const attemptBufferedCommit = (key) => {
      const entry = bufferedMutations.get(key);
      if (!entry) return;
      const { executor, value } = entry;
      try {
        const result = executor(value);
        if (result && typeof result.then === 'function') {
          result.then((resolved) => handleCommitOutcome(key, resolved)).catch((err) => {
            showValidationError(`保存処理でエラーが発生しました: ${err?.message || err}`);
          });
        } else {
          handleCommitOutcome(key, result);
        }
      } catch (err) {
        showValidationError(`保存処理でエラーが発生しました: ${err?.message || err}`);
      }
    };

    const scheduleBufferedCommit = (key, value, executor) => {
      bufferedMutations.set(key, { value, executor, timestamp: Date.now() });
      if (bufferTimers.has(key)) {
        const handle = bufferTimers.get(key);
        if (handle) {
          clearTimeout(handle);
        }
        bufferTimers.delete(key);
      }
      if (typingState.composing) {
        bufferTimers.set(key, null);
        return;
      }
      armBufferedCommit(key);
    };

    const pauseBufferedCommitsForComposition = () => {
      typingState.composing = true;
      bufferTimers.forEach((handle, key) => {
        if (handle) {
          clearTimeout(handle);
          bufferTimers.set(key, null);
        }
      });
    };

    const resumeBufferedCommitsAfterComposition = () => {
      typingState.composing = false;
      bufferTimers.forEach((handle, key) => {
        if (handle === null) {
          armBufferedCommit(key);
        }
      });
    };

    document.addEventListener('focusin', (event) => {
      const binding = typingBindings.get(event.target);
      if (binding) {
        typingState.active = true;
        typingState.binding = binding;
        typingState.element = event.target;
        typingState.route = appState.route;
        typingState.pendingRender = false;
        typingDiagnostics.pendingSince = null;
        typingState.composing = false;
        return;
      }
      if (event.target === typingState.element) {
        typingState.active = false;
        typingState.binding = null;
        typingState.element = null;
        typingState.route = null;
        typingState.pendingRender = false;
        typingDiagnostics.pendingSince = null;
        typingState.composing = false;
      }
    });

    document.addEventListener('focusout', (event) => {
      if (event.target !== typingState.element) return;
      const shouldRender = typingState.pendingRender;
      typingState.active = false;
      typingState.binding = null;
      typingState.element = null;
      typingState.route = null;
      typingState.pendingRender = false;
      typingDiagnostics.pendingSince = null;
      typingState.composing = false;
      if (shouldRender) {
        queueMicrotask(() => requestRender());
      }
    });

    document.addEventListener('compositionstart', (event) => {
      if (event.target !== typingState.element) return;
      pauseBufferedCommitsForComposition();
    });

    document.addEventListener('compositionend', (event) => {
      if (event.target !== typingState.element) return;
      resumeBufferedCommitsAfterComposition();
    });

    const commitSetField = (exerciseId, setIndex, field, rawValue) => {
      const context = findExerciseContext(exerciseId);
      if (!context) {
        return { success: false, message: '対象の種目が見つかりません。' };
      }
      const exercise = context.exercise;
      const set = exercise.sets[setIndex];
      if (!set) {
        return { success: false, message: '対象のセットが見つかりません。' };
      }
      if (field === 'weight' || field === 'reps') {
        const allowProvisional = Boolean(appData?.settings?.allowProvisionalValues);
        const num = safeNumber(rawValue);
        if (num === null) {
          if (!allowProvisional) {
            const label = field === 'weight' ? '重量' : '回数';
            return { success: false, message: `${label}には数値を入力してください。` };
          }
          set[field] = null;
        } else {
          set[field] = num;
        }
        applyProvisionalState(set);
        recomputeExercise(appData.currentWorkout.id, exercise);
        persist();
        return { success: true, rerender: true };
      }
      if (field === 'note') {
        set[field] = typeof rawValue === 'string' ? rawValue : '';
        persist();
        return { success: true, rerender: false };
      }
      return { success: false, message: '不明なフィールドです。' };
    };

    const commitExerciseField = (exerciseId, field, rawValue) => {
      const context = findExerciseContext(exerciseId);
      if (!context) {
        return { success: false, message: '対象の種目が見つかりません。' };
      }
      const exercise = context.exercise;
      if (field === 'angle' || field === 'intervalSeconds') {
        if (rawValue === '' || rawValue === null || rawValue === undefined) {
          exercise[field] = null;
          persist();
          return { success: true, rerender: field === 'intervalSeconds' };
        }
        const num = safeNumber(rawValue);
        if (num === null) {
          const label = field === 'angle' ? '角度' : 'インターバル';
          return { success: false, message: `${label}には数値を入力してください。` };
        }
        exercise[field] = num;
        persist();
        return { success: true, rerender: field === 'intervalSeconds' };
      }
      if (field === 'performedOn') {
        exercise[field] = rawValue || '';
        persist();
        return { success: true, rerender: false };
      }
      if (field === 'equipment' || field === 'attachment' || field === 'position') {
        if (rawValue === '' || rawValue === null || rawValue === undefined) {
          exercise[field] = '';
          exercise[`${field}Key`] = null;
          persist();
          return { success: true, rerender: false };
        }
        const { key, entry, created } = ensureOptionEntry(field, rawValue, {
          allowCreate: appData.settings.allowFreeInput
        });
        if (!key) {
          return { success: false, message: '選択した値を保存できませんでした。' };
        }
        exercise[field] = entry?.label || exercise[field] || '';
        exercise[`${field}Key`] = key;
        persist();
        return { success: true, rerender: Boolean(created) };
      }
      return { success: false, message: '不明なフィールドです。' };
    };

    const scheduleSetFieldUpdate = (exerciseId, setIndex, field, value) => {
      const key = `set:${exerciseId}:${setIndex}:${field}`;
      scheduleBufferedCommit(key, value, (payload) => commitSetField(exerciseId, setIndex, field, payload));
    };

    const scheduleExerciseFieldUpdate = (exerciseId, field, value) => {
      const key = `exercise:${exerciseId}:${field}`;
      scheduleBufferedCommit(key, value, (payload) => commitExerciseField(exerciseId, field, payload));
    };

    const addSet = (exerciseId) => {
      const context = findExerciseContext(exerciseId);
      if (!context) return;
      if (context.superset) {
        addSupersetRound(context.superset.id);
        return;
      }
      const newSet = createEmptySet();
      applyProvisionalState(newSet);
      context.exercise.sets.push(newSet);
      recomputeExercise(appData.currentWorkout.id, context.exercise);
      persist();
      requestRender();
    };

    const duplicateSet = (exerciseId, setIndex) => {
      const context = findExerciseContext(exerciseId);
      if (!context) return;
      if (context.superset) {
        duplicateSupersetRound(context.superset.id, setIndex);
        return;
      }
      const baseSet = context.exercise.sets[setIndex];
      if (!baseSet) return;
      const cloned = createEmptySet();
      cloned.weight = baseSet.weight;
      cloned.reps = baseSet.reps;
      cloned.note = baseSet.note;
      applyProvisionalState(cloned);
      context.exercise.sets.splice(setIndex + 1, 0, cloned);
      recomputeExercise(appData.currentWorkout.id, context.exercise);
      persist();
      requestRender();
    };

    const deleteExercise = async (exerciseId) => {
      if (!(await confirmAction('この種目を削除しますか？'))) return;
      if (!removeExerciseFromSuperset(exerciseId)) return;
      persist();
      requestRender();
    };

    const finishWorkout = async () => {
      if (!appData.currentWorkout.exercises.length) return;
      const confirmed = await confirmAction('現在のワークアウトを完了として保存しますか？');
      if (!confirmed) return;
      const workoutCopy = cloneDeep(appData.currentWorkout);
      workoutCopy.id = `wo-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`;
      workoutCopy.completedAt = Date.now();
      normalizeWorkout(workoutCopy);
      workoutCopy.exercises.forEach((exercise) => recomputeExercise(workoutCopy.id, exercise));
      appData.workouts.unshift(workoutCopy);
      appData.lastSupersetBlueprint = buildSupersetBlueprint(appData.currentWorkout);
      resetAllSupersetTimers();
      appData.currentWorkout = {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: [],
        supersets: [],
        selectedPartKey: appData.settings.lastSelectedPartKey ?? null
      };
      restoreSupersetBlueprint();
      persist();
      requestRender();
    };

    const deleteWorkout = async (workoutId) => {
      const ok = await confirmAction('選択した履歴を削除しますか？');
      if (!ok) return;
      appData.workouts = appData.workouts.filter((wk) => wk.id !== workoutId);
      persist();
      requestRender();
    };

    const createHistoryWorkoutNode = (workout, workoutIndex, totalWorkouts) => {
      const item = createElem('article', { className: 'rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
      item.dataset.historyIndex = String(workoutIndex);
      const header = createElem('div', { className: 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between' });
      const timestamp = formatDate(workout.completedAt || workout.startedAt);
      header.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: timestamp }));
      const deleteBtn = createElem('button', {
        className: 'self-start text-xs font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500',
        textContent: '削除',
        attrs: { type: 'button' }
      });
      deleteBtn.addEventListener('click', () => deleteWorkout(workout.id));
      header.append(deleteBtn);
      item.append(header);

      workout.exercises.forEach((exercise) => {
        const exerciseBlock = createElem('div', { className: 'mt-4 space-y-3 rounded-xl border border-slate-200 bg-slate-50 p-4' });
        exerciseBlock.append(createElem('h4', { className: 'text-base font-bold text-slate-900', textContent: exercise.name }));
        const metaItems = [
          { label: '器具', value: exercise.equipment },
          { label: 'アタッチメント', value: exercise.attachment },
          { label: '角度 (°)', value: exercise.angle != null ? `${exercise.angle}°` : null },
          { label: 'スタンス / ポジション', value: exercise.position },
          { label: '実施日', value: exercise.performedOn },
          { label: 'インターバル (秒)', value: exercise.intervalSeconds != null ? `${exercise.intervalSeconds}秒` : null }
        ].filter((entry) => entry.value !== null && entry.value !== undefined && entry.value !== '');
        if (metaItems.length) {
          const metaList = createElem('ul', { className: 'grid grid-cols-1 gap-2 text-sm text-slate-800 sm:grid-cols-2' });
          metaItems.forEach(({ label, value }) => {
            const meta = createElem('li', { className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 shadow-sm' });
            meta.append(
              createElem('p', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-800', textContent: label }),
              createElem('p', { className: 'text-sm font-medium text-slate-900', textContent: value })
            );
            metaList.append(meta);
          });
          exerciseBlock.append(metaList);
        }
        const setsList = createElem('ul', { className: 'space-y-2' });
        exercise.sets.forEach((set, index) => {
          const isProvisional = Boolean(set?.isProvisional);
          const weightLabel = set?.weight ?? '-';
          const repsLabel = set?.reps ?? '-';
          const oneRmLabel = set?.oneRM ?? '-';
          const suffix = isProvisional ? ' ※暫定' : '';
          const notePart = set?.note ? ` / ${set.note}` : '';
          const info = `#${index + 1} 重量: ${weightLabel}${appData.settings.unit} / 回数: ${repsLabel} / 推定1RM: ${oneRmLabel}${suffix}${notePart}`;
          setsList.append(
            createElem('li', {
              className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-800 shadow-sm',
              textContent: info
            })
          );
        });
        const trendBtn = createElem('button', {
          className: 'text-xs font-semibold text-blue-700 underline decoration-dotted hover:text-blue-800',
          textContent: '推移を表示',
          attrs: { type: 'button' }
        });
        trendBtn.addEventListener('click', () => {
          appData.historyView.exerciseKey = exercise.nameKey ?? null;
          requestRender();
        });
        exerciseBlock.append(setsList, trendBtn);
        item.append(exerciseBlock);
      });

      if (workoutIndex !== totalWorkouts - 1) {
        item.style.marginBottom = `${HISTORY_ITEM_GAP}px`;
      }
      return item;
    };

    const createHistoryVirtualList = (workouts) => {
      const count = workouts.length;
      const viewport = createElem('div', { className: 'relative max-h-[70vh] overflow-y-auto' });
      const spacer = createElem('div', { className: 'relative w-full' });
      const inner = createElem('div', { className: 'absolute inset-x-0 top-0' });
      spacer.append(inner);
      viewport.append(spacer);

      if (!count) {
        spacer.style.height = '0px';
        historyListScrollTop = 0;
        return viewport;
      }

      const cachedHeights = Array.from(historyHeightCache.values());
      const averageHeight = cachedHeights.length
        ? Math.max(160, Math.round(cachedHeights.reduce((sum, value) => sum + value, 0) / cachedHeights.length))
        : DEFAULT_HISTORY_ITEM_HEIGHT;
      const itemHeights = workouts.map((workout) => {
        const cached = historyHeightCache.get(workout.id);
        return cached && cached > 0 ? cached : averageHeight;
      });
      const positions = new Array(count + 1).fill(0);
      for (let i = 0; i < count; i += 1) {
        const blockHeight = itemHeights[i] + (i === count - 1 ? 0 : HISTORY_ITEM_GAP);
        positions[i + 1] = positions[i] + blockHeight;
      }
      let totalHeight = positions[count];
      spacer.style.height = `${totalHeight}px`;

      let renderedStart = -1;
      let renderedEnd = -1;
      let measurementScheduled = false;

      const recomputePositions = (startIndex = 0) => {
        if (startIndex < 0) startIndex = 0;
        for (let i = startIndex; i < count; i += 1) {
          const blockHeight = itemHeights[i] + (i === count - 1 ? 0 : HISTORY_ITEM_GAP);
          positions[i + 1] = positions[i] + blockHeight;
        }
        totalHeight = positions[count];
        spacer.style.height = `${totalHeight}px`;
      };

      const measureRenderedItems = () => {
        let changedFrom = count;
        Array.from(inner.children).forEach((child) => {
          const index = Number(child.dataset.historyIndex);
          if (!Number.isFinite(index)) return;
          const rect = child.getBoundingClientRect();
          const measured = Math.max(0, Math.round(rect.height));
          if (!measured || Math.abs(measured - itemHeights[index]) <= 1) return;
          itemHeights[index] = measured;
          historyHeightCache.set(workouts[index].id, measured);
          if (index < changedFrom) changedFrom = index;
        });
        if (changedFrom < count) {
          recomputePositions(changedFrom);
          renderedStart = -1;
          renderViewport();
        }
      };

      const scheduleMeasurement = () => {
        if (measurementScheduled) return;
        measurementScheduled = true;
        requestAnimationFrame(() => {
          measurementScheduled = false;
          measureRenderedItems();
        });
      };

      const renderViewport = () => {
        const scrollTop = viewport.scrollTop;
        const viewportHeight = viewport.clientHeight || 1;
        let start = 0;
        while (start < count && positions[start + 1] <= scrollTop) {
          start += 1;
        }
        start = Math.max(0, start - HISTORY_VIRTUAL_OVERSCAN);
        let end = start;
        const targetBottom = scrollTop + viewportHeight;
        while (end < count && positions[end] < targetBottom) {
          end += 1;
        }
        end = Math.min(count, end + HISTORY_VIRTUAL_OVERSCAN);
        if (end <= start) {
          end = Math.min(count, start + 1);
        }
        if (start === renderedStart && end === renderedEnd) return;
        renderedStart = start;
        renderedEnd = end;
        const fragment = document.createDocumentFragment();
        for (let index = start; index < end; index += 1) {
          fragment.append(createHistoryWorkoutNode(workouts[index], index, count));
        }
        inner.style.transform = `translateY(${positions[start]}px)`;
        inner.replaceChildren(fragment);
        scheduleMeasurement();
      };

      const handleScroll = () => {
        historyListScrollTop = viewport.scrollTop;
        renderViewport();
      };
      viewport.addEventListener('scroll', handleScroll, { passive: true });

      setTimeout(() => {
        const maxScroll = Math.max(totalHeight - viewport.clientHeight, 0);
        const target = Math.min(historyListScrollTop, maxScroll);
        if (Number.isFinite(target)) {
          viewport.scrollTop = target;
        }
        renderViewport();
      }, 0);

      return viewport;
    };

    const clearAllData = async () => {
      const ok = await confirmAction('すべてのデータを初期化します。よろしいですか？');
      if (!ok) return;
      storage.clearNamespace();
      resetData();
      requestRender();
    };

    const changeUnit = (unit) => {
      appData.settings.unit = unit;
      persist();
      requestRender();
    };

    const exportData = () => {
      const baseMeta = {
        schemaVersion: SCHEMA_VERSION,
        device: getDeviceName(),
        exportedAt: new Date().toISOString()
      };
      const rows = [];
      const pushRow = (data) => {
        const row = createCsvRow();
        Object.assign(row, baseMeta, data);
        rows.push(row);
      };

      pushRow({ recordType: CSV_RECORD_TYPES.META });
      pushRow({ recordType: CSV_RECORD_TYPES.SETTINGS, unit: appData.settings.unit });
      appData.settings.exerciseCatalog.forEach((entry) => {
        const label = getExerciseLabelByKey(entry) || entry;
        pushRow({
          recordType: CSV_RECORD_TYPES.CATALOG,
          catalogEntry: entry,
          exercise: label,
          exerciseKey: entry
        });
      });
      pushRow({
        recordType: CSV_RECORD_TYPES.HISTORY_VIEW,
        exercise: appData.historyView.exerciseKey ? getExerciseLabelByKey(appData.historyView.exerciseKey) : '',
        exerciseKey: appData.historyView.exerciseKey ?? ''
      });

      const workoutDateValue = (workout, exercise) => {
        if (exercise?.performedOn) return exercise.performedOn;
        if (workout?.completedAt) return workout.completedAt;
        if (workout?.startedAt) return workout.startedAt;
        return '';
      };

      const addWorkoutRows = (workout, state, order) => {
        if (!workout || !workout.id) return;
        pushRow({
          recordType: CSV_RECORD_TYPES.WORKOUT,
          workoutState: state,
          workoutId: workout.id,
          workoutStartedAt: workout.startedAt ?? '',
          workoutCompletedAt: workout.completedAt ?? '',
          workoutOrder: order,
          date: workoutDateValue(workout)
        });
        workout.exercises.forEach((exercise) => {
        pushRow({
          recordType: CSV_RECORD_TYPES.EXERCISE,
          workoutState: state,
          workoutId: workout.id,
          exerciseId: exercise.id,
          part: (() => {
            const part = getExercisePartByKey(exercise.nameKey);
            const def = part ? getPartDefinition(part) : null;
            return def ? def.label : '';
          })(),
          partKey: getExercisePartByKey(exercise.nameKey) ?? '',
          exercise: exercise.name ?? '',
          exerciseKey: exercise.nameKey ?? '',
          equipment: exercise.equipment ?? '',
          equipmentKey: exercise.equipmentKey ?? '',
          attachment: exercise.attachment ?? '',
          attachmentKey: exercise.attachmentKey ?? '',
          angle: exercise.angle ?? '',
          position: exercise.position ?? '',
          positionKey: exercise.positionKey ?? '',
          performedOn: exercise.performedOn ?? '',
          intervalSeconds: exercise.intervalSeconds ?? '',
          date: workoutDateValue(workout, exercise)
        });
          exercise.sets.forEach((set, index) => {
            pushRow({
              recordType: CSV_RECORD_TYPES.SET,
              workoutState: state,
              workoutId: workout.id,
              exerciseId: exercise.id,
              setIndex: index,
              setType: 'standard',
              weight: set.weight ?? '',
              reps: set.reps ?? '',
              oneRM: set.oneRM ?? '',
              note: set.note ?? '',
              unit: appData.settings.unit,
              date: workoutDateValue(workout, exercise)
            });
          });
        });
      };

      appData.workouts.forEach((workout, index) => addWorkoutRows(workout, 'history', index));
      addWorkoutRows(appData.currentWorkout, 'current', 'current');

      const csv = serializeCsvRows(rows);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const timestamp = baseMeta.exportedAt.replace(/[-:]/g, '').replace(/\..*$/, '');
      const fileName = `muscle-app-export-${timestamp || Date.now()}.csv`;
      const url = URL.createObjectURL(blob);
      const link = createElem('a', { attrs: { href: url, download: fileName } });
      document.body.append(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    };

    const restoreAppDataFromCsv = (rows) => {
      const issues = [];
      const base = createInitialData();
      const restoreSettings = base.settings;
      ensureOptionCatalogs(restoreSettings);
      const group = rows.reduce((acc, row) => {
        const type = row.recordType || '';
        if (!acc[type]) acc[type] = [];
        acc[type].push(row);
        return acc;
      }, {});

      const metaRow = (group[CSV_RECORD_TYPES.META] || [])[0];
      if (!metaRow) {
        issues.push('meta 行が見つかりません。');
      }
      const schemaValue = metaRow ? toIntegerOrNull(metaRow.schemaVersion) : null;
      if (schemaValue === null) {
        issues.push('SCHEMA_VERSION が解釈できません。');
      } else if (schemaValue !== SCHEMA_VERSION) {
        issues.push(`SCHEMA_VERSION が一致しません (期待: ${SCHEMA_VERSION} / 実際: ${schemaValue}).`);
      }

      const settingsRow = (group[CSV_RECORD_TYPES.SETTINGS] || [])[0];
      if (!settingsRow) {
        issues.push('settings 行が不足しています。');
      }
      const unit = (settingsRow?.unit || '').trim();
      const allowedUnits = new Set(['kg', 'lb']);
      if (!unit) {
        issues.push('単位 (unit) が指定されていません。');
      } else if (!allowedUnits.has(unit)) {
        issues.push(`サポートされていない単位です: ${unit}`);
      }

      const catalogEntrySet = new Set();
      const catalogEntries = [];
      (group[CSV_RECORD_TYPES.CATALOG] || []).forEach((row) => {
        const raw = (row.exerciseKey || row.catalogEntry || row.exercise || '').trim();
        if (!raw) return;
        const result = ensureOptionEntry('exercise', raw, { allowCreate: true, settingsOverride: restoreSettings });
        if (result.key && !catalogEntrySet.has(result.key)) {
          catalogEntrySet.add(result.key);
          catalogEntries.push(result.key);
        }
      });
      const historyViewRow = (group[CSV_RECORD_TYPES.HISTORY_VIEW] || [])[0];
      const historyExerciseRaw = historyViewRow
        ? (historyViewRow.exerciseKey || historyViewRow.exerciseId || historyViewRow.exercise || '').trim()
        : '';
      const historyExerciseEntry = historyExerciseRaw
        ? ensureOptionEntry('exercise', historyExerciseRaw, { allowCreate: true, settingsOverride: restoreSettings }).key
        : null;

      const workoutContainers = new Map();
      const exerciseContainers = new Map();
      const historyWorkouts = [];
      let currentWorkoutContainer = null;

      const workoutRows = group[CSV_RECORD_TYPES.WORKOUT] || [];
      workoutRows.forEach((row) => {
        const line = row.__line || '?';
        const state = (row.workoutState || '').trim();
        if (!state) {
          issues.push(`行${line}: workoutState が空です。`);
          return;
        }
        if (state !== 'history' && state !== 'current') {
          issues.push(`行${line}: 未対応の workoutState '${state}' です。`);
          return;
        }
        const workoutId = (row.workoutId || '').trim();
        if (!workoutId) {
          issues.push(`行${line}: workoutId がありません。`);
          return;
        }
        const startedAtRaw = row.workoutStartedAt;
        const startedAt = toIntegerOrNull(startedAtRaw);
        if (startedAt === null) {
          issues.push(`行${line}: workoutStartedAt が数値ではありません。`);
        }
        const completedAtRaw = row.workoutCompletedAt;
        let completedAt = null;
        if (completedAtRaw && String(completedAtRaw).trim()) {
          const parsed = toIntegerOrNull(completedAtRaw);
          if (parsed === null) {
            issues.push(`行${line}: workoutCompletedAt が数値ではありません。`);
          } else {
            completedAt = parsed;
          }
        }
        const orderRaw = row.workoutOrder;
        let orderValue = null;
        if (state === 'history') {
          const parsedOrder = toIntegerOrNull(orderRaw);
          if (parsedOrder === null) {
            issues.push(`行${line}: workoutOrder が数値ではありません。`);
          } else {
            orderValue = parsedOrder;
          }
        }
        const key = `${state}:${workoutId}`;
        if (workoutContainers.has(key)) {
          issues.push(`行${line}: workoutId '${workoutId}' が重複しています。`);
          return;
        }
        const workout = {
          id: workoutId,
          startedAt: startedAt ?? Date.now(),
          completedAt: completedAt,
          exercises: []
        };
        const container = { workout, state, order: orderValue ?? Number.MAX_SAFE_INTEGER, line };
        workoutContainers.set(key, container);
        if (state === 'history') {
          historyWorkouts.push(container);
        } else if (state === 'current') {
          currentWorkoutContainer = container;
        }
      });

      const exerciseRows = group[CSV_RECORD_TYPES.EXERCISE] || [];
      exerciseRows.forEach((row) => {
        const line = row.__line || '?';
        const state = (row.workoutState || '').trim();
        if (!state) {
          issues.push(`行${line}: workoutState が空です。`);
          return;
        }
        const workoutId = (row.workoutId || '').trim();
        if (!workoutId) {
          issues.push(`行${line}: workoutId がありません。`);
          return;
        }
        const key = `${state}:${workoutId}`;
        const workoutContainer = workoutContainers.get(key);
        if (!workoutContainer) {
          issues.push(`行${line}: 対応するワークアウト (${key}) が見つかりません。`);
          return;
        }
        const exerciseId = (row.exerciseId || '').trim();
        if (!exerciseId) {
          issues.push(`行${line}: exerciseId がありません。`);
          return;
        }
        const angleRaw = row.angle;
        const angle = toNumberOrNull(angleRaw);
        if (angleRaw && String(angleRaw).trim() && angle === null) {
          issues.push(`行${line}: angle が数値ではありません。`);
        }
        const intervalRaw = row.intervalSeconds;
        const intervalSeconds = toNumberOrNull(intervalRaw);
        if (intervalRaw && String(intervalRaw).trim() && intervalSeconds === null) {
          issues.push(`行${line}: intervalSeconds が数値ではありません。`);
        }
        const nameResult = ensureOptionEntry('exercise', row.exerciseKey || row.exercise || '', {
          allowCreate: true,
          settingsOverride: restoreSettings,
          partKey: row.partKey || row.part
        });
        const equipmentResult = ensureOptionEntry('equipment', row.equipmentKey || row.equipment || '', {
          allowCreate: true,
          settingsOverride: restoreSettings
        });
        const attachmentResult = ensureOptionEntry('attachment', row.attachmentKey || row.attachment || '', {
          allowCreate: true,
          settingsOverride: restoreSettings
        });
        const positionResult = ensureOptionEntry('position', row.positionKey || row.position || '', {
          allowCreate: true,
          settingsOverride: restoreSettings
        });
        const exercise = {
          id: exerciseId,
          name: nameResult.entry?.label || row.exercise || '',
          nameKey: nameResult.key || null,
          equipment: equipmentResult.entry?.label || '',
          equipmentKey: equipmentResult.key || null,
          attachment: attachmentResult.entry?.label || '',
          attachmentKey: attachmentResult.key || null,
          angle: angle === null ? null : angle,
          position: positionResult.entry?.label || '',
          positionKey: positionResult.key || null,
          performedOn: row.performedOn || '',
          intervalSeconds: intervalSeconds === null ? null : intervalSeconds,
          sets: []
        };
        const partKey = normalizePartKey(row.partKey || row.part);
        if (partKey && exercise.nameKey) {
          restoreSettings.exercisePartHints[exercise.nameKey] = partKey;
        }
        workoutContainer.workout.exercises.push(exercise);
        const exerciseKey = `${key}:${exerciseId}`;
        exerciseContainers.set(exerciseKey, { exercise, line });
      });

      const setRows = group[CSV_RECORD_TYPES.SET] || [];
      setRows.forEach((row) => {
        const line = row.__line || '?';
        const state = (row.workoutState || '').trim();
        if (!state) {
          issues.push(`行${line}: workoutState が空です。`);
          return;
        }
        const workoutId = (row.workoutId || '').trim();
        if (!workoutId) {
          issues.push(`行${line}: workoutId がありません。`);
          return;
        }
        const exerciseId = (row.exerciseId || '').trim();
        if (!exerciseId) {
          issues.push(`行${line}: exerciseId がありません。`);
          return;
        }
        const exerciseKey = `${state}:${workoutId}:${exerciseId}`;
        const container = exerciseContainers.get(exerciseKey);
        if (!container) {
          issues.push(`行${line}: exerciseId '${exerciseId}' に対応する種目が見つかりません。`);
          return;
        }
        const setIndex = toIntegerOrNull(row.setIndex);
        if (setIndex === null || setIndex < 0) {
          issues.push(`行${line}: setIndex が不正です。`);
          return;
        }
        const setType = (row.setType || '').trim();
        if (!CSV_ALLOWED_SET_TYPES.has(setType)) {
          issues.push(`行${line}: 未対応の setType '${setType}' です。`);
        }
        if (row.unit && unit && row.unit !== unit) {
          issues.push(`行${line}: 単位が一致しません (期待: ${unit} / 実際: ${row.unit})。`);
        }
        const weight = toNumberOrNull(row.weight);
        if (row.weight && String(row.weight).trim() && weight === null) {
          issues.push(`行${line}: weight が数値ではありません。`);
        }
        const reps = toNumberOrNull(row.reps);
        if (row.reps && String(row.reps).trim()) {
          if (reps === null) {
            issues.push(`行${line}: reps が数値ではありません。`);
          } else if (!Number.isInteger(reps)) {
            issues.push(`行${line}: reps は整数である必要があります。`);
          }
        }
        const oneRM = toNumberOrNull(row.oneRM);
        if (row.oneRM && String(row.oneRM).trim() && oneRM === null) {
          issues.push(`行${line}: oneRM が数値ではありません。`);
        }
        const targetSets = container.exercise.sets;
        if (!targetSets[setIndex]) {
          targetSets[setIndex] = {
            weight: weight === null ? null : weight,
            reps: reps === null ? null : reps,
            oneRM: oneRM === null ? null : oneRM,
            note: row.note != null ? String(row.note) : ''
          };
        } else {
          issues.push(`行${line}: setIndex ${setIndex} が重複しています。`);
        }
      });

      exerciseContainers.forEach(({ exercise, line }) => {
        for (let idx = 0; idx < exercise.sets.length; idx += 1) {
          if (!exercise.sets[idx]) {
            issues.push(`行${line}: セット #${idx} のデータが不足しています。`);
            exercise.sets.splice(idx, 1);
            idx -= 1;
          }
        }
      });

      if (!currentWorkoutContainer) {
        issues.push('現在のワークアウト情報が不足しています。');
      }

      historyWorkouts.sort((a, b) => {
        if (a.order === b.order) return a.line - b.line;
        return a.order - b.order;
      });

      const data = {
        workouts: historyWorkouts.map((item) => item.workout),
        currentWorkout: currentWorkoutContainer ? currentWorkoutContainer.workout : base.currentWorkout,
        settings: {
          ...base.settings,
          unit: unit || base.settings.unit,
          optionCatalogs: restoreSettings.optionCatalogs,
          exerciseCatalog: catalogEntries.length ? catalogEntries : restoreSettings.exerciseCatalog,
          exercisePartHints: restoreSettings.exercisePartHints
        },
        historyView: {
          exerciseKey: historyExerciseEntry
        },
        templates: base.templates
      };

      return { issues, data };
    };

    const importData = async (file) => {
      if (!file) return;
      try {
        const text = await file.text();
        const parsedRows = parseCsvContent(text);
        if (parsedRows.__unclosedQuote) {
          const line = parsedRows.__lineNumber || '?';
          showImportReport('CSVの解析に失敗しました', [`行${line}: クォートが正しく閉じられていません。`]);
          return;
        }
        if (!parsedRows.length) {
          showImportReport('インポートを中止しました', ['CSVにデータが含まれていません。']);
          return;
        }
        const header = parsedRows.shift();
        const headerIssues = validateCsvHeader(header);
        if (headerIssues.length) {
          showImportReport('ヘッダーが一致しません', headerIssues);
          return;
        }
        const rowLengthIssues = [];
        const rows = [];
        parsedRows.forEach((cells, index) => {
          if (cells.length !== header.length) {
            rowLengthIssues.push(`行${index + 2}: 列数が ${cells.length} 列です (期待: ${header.length} 列)。`);
            return;
          }
          const row = createCsvRow();
          header.forEach((col, colIndex) => {
            row[col] = cells[colIndex] ?? '';
          });
          row.__line = index + 2;
          rows.push(row);
        });
        if (rowLengthIssues.length) {
          showImportReport('列数が一致しません', rowLengthIssues);
          return;
        }
        const { issues, data } = restoreAppDataFromCsv(rows);
        if (issues.length) {
          showImportReport('インポートを中止しました', issues);
          return;
        }
        oneRmMemo.clear();
        appData = data;
        if (!Array.isArray(appData.templates)) appData.templates = [];
        if (!appData.settings || typeof appData.settings !== 'object') {
          appData.settings = createInitialData().settings;
        }
        if (!Array.isArray(appData.settings.exerciseCatalog)) {
          appData.settings.exerciseCatalog = createInitialData().settings.exerciseCatalog.slice();
        }
        if (!appData.settings.exercisePartHints || typeof appData.settings.exercisePartHints !== 'object') {
          appData.settings.exercisePartHints = {};
        }
        ensureOptionCatalogs(appData.settings);
        ensureExerciseCatalogIntegrity();
        normalizeExercisePartHints();
        appData.settings.lastSelectedPartKey = normalizePartKey(appData.settings.lastSelectedPartKey);
        normalizeWorkout(appData.currentWorkout);
        appData.currentWorkout.selectedPartKey = normalizePartKey(appData.currentWorkout.selectedPartKey)
          ?? appData.settings.lastSelectedPartKey
          ?? null;
        appData.workouts.forEach((workout) => normalizeWorkout(workout));
        recomputeAll();
        persist();
        requestRender();
      } catch (err) {
        pushError(`読み込みに失敗しました: ${err?.message || err}`);
      }
    };

    /*** route renderers ***/
    let optionControlSequence = 0;

    const createOptionControl = ({ field, valueKey = null, partKey = null, placeholder = '選択してください', onCommit }) => {
      const allowFreeInput = Boolean(appData?.settings?.allowFreeInput);
      const currentLabel = valueKey
        ? (field === 'exercise' ? getExerciseLabelByKey(valueKey) : getOptionLabel(field, valueKey))
        : '';
      if (allowFreeInput) {
        optionControlSequence += 1;
        const controlId = `option-${field}-${optionControlSequence}`;
        const input = createElem('input', {
          className: 'input-base text-sm text-slate-900',
          attrs: { list: controlId, placeholder }
        });
        if (currentLabel) input.value = currentLabel;
        const datalist = createElem('datalist', { attrs: { id: controlId } });
        const entries = field === 'exercise' ? getExerciseOptionsForPart(partKey) : getOptionCatalog(field);
        const seen = new Set();
        entries.forEach((entry) => {
          if (!entry || !entry.label || seen.has(entry.label)) return;
          seen.add(entry.label);
          datalist.append(createElem('option', { attrs: { value: entry.label } }));
        });
        if (currentLabel && !seen.has(currentLabel)) {
          datalist.append(createElem('option', { attrs: { value: currentLabel } }));
        }
        input.addEventListener('change', () => {
          onCommit(input.value.trim());
        });
        return createElem('div', { children: [input, datalist] });
      }
      const select = createElem('select', {
        className: 'select-base text-sm text-slate-900 bg-white'
      });
      select.append(createElem('option', { value: '', textContent: placeholder }));
      const entries = field === 'exercise' ? getExerciseOptionsForPart(partKey) : getOptionCatalog(field);
      entries.forEach((entry) => {
        select.append(createElem('option', { value: entry.key, textContent: entry.label }));
      });
      select.value = valueKey || '';
      select.addEventListener('change', (event) => {
        onCommit(event.target.value);
      });
      return select;
    };

<!-- PATCH-START: UI-DENSITY -->
    const createExerciseMetaPanel = (exercise) => {
      const metaPanel = createElem('div', { className: 'space-y-3 rounded-xl border border-slate-200 bg-slate-50 p-4' });

      const equipmentRow = createElem('div', { className: 'grid grid-cols-1 gap-x-3 gap-y-2 md:grid-cols-2' });
      const equipmentControl = createOptionControl({
        field: 'equipment',
        valueKey: exercise.equipmentKey,
        placeholder: '器具を選択',
        onCommit: (value) => scheduleExerciseFieldUpdate(exercise.id, 'equipment', value)
      });
      const equipmentField = createFieldWrapper('器具', '使用した器具を入力します。', '使用した器具の種類を記録しましょう。', equipmentControl);

      const attachmentControl = createOptionControl({
        field: 'attachment',
        valueKey: exercise.attachmentKey,
        placeholder: 'アタッチメントを選択',
        onCommit: (value) => scheduleExerciseFieldUpdate(exercise.id, 'attachment', value)
      });
      const attachmentField = createFieldWrapper('アタッチメント', '利用したアタッチメントを記録します。', 'ケーブルハンドルなどをメモできます。', attachmentControl);
      equipmentRow.append(equipmentField, attachmentField);
      metaPanel.append(equipmentRow);

      const angleRow = createElem('div', { className: 'grid grid-cols-1 gap-x-3 gap-y-2 md:grid-cols-2' });
      const angleInput = createElem('input', {
        className: 'input-base text-slate-900 placeholder-slate-400',
        attrs: { type: 'number', inputmode: 'decimal', min: '0', max: '180', step: '1', placeholder: '例: 30' },
        value: exercise.angle ?? ''
      });
      angleInput.addEventListener('input', (event) => {
        scheduleExerciseFieldUpdate(exercise.id, 'angle', event.target.value);
      });
      registerTypingTarget(angleInput, {
        key: `exercise:${exercise.id}:angle`,
        type: 'exercise',
        exerciseId: exercise.id,
        field: 'angle',
        apply: (el, value) => applyInputValue(el, value)
      });
      const angleField = createFieldWrapper('角度 (°)', 'ベンチやマシンの角度を記録します。', '角度の変化を記録してフォームを比較。', angleInput);

      const positionControl = createOptionControl({
        field: 'position',
        valueKey: exercise.positionKey,
        placeholder: 'スタンス / ポジションを選択',
        onCommit: (value) => scheduleExerciseFieldUpdate(exercise.id, 'position', value)
      });
      const positionField = createFieldWrapper('スタンス / ポジション', '足幅やグリップ幅などを記録します。', 'スタンスやポジションの工夫を書き残しましょう。', positionControl);
      angleRow.append(angleField, positionField);
      metaPanel.append(angleRow);

      const scheduleRow = createElem('div', { className: 'grid grid-cols-1 gap-x-3 gap-y-2 md:grid-cols-2' });
      const performedOnInput = createElem('input', {
        className: 'input-base text-slate-900',
        attrs: { type: 'date', min: '2000-01-01', max: '2099-12-31', step: '1' },
        value: exercise.performedOn ?? ''
      });
      performedOnInput.addEventListener('input', (event) => {
        scheduleExerciseFieldUpdate(exercise.id, 'performedOn', event.target.value);
      });
      registerTypingTarget(performedOnInput, {
        key: `exercise:${exercise.id}:performedOn`,
        type: 'exercise',
        exerciseId: exercise.id,
        field: 'performedOn',
        apply: (el, value) => applyInputValue(el, value)
      });
      const performedOnField = createFieldWrapper('実施日', 'トレーニングを行った日付です。', '後から見返すために日付を残せます。', performedOnInput);

      const intervalInput = createElem('input', {
        className: 'input-base text-slate-900 placeholder-slate-400',
        attrs: { type: 'number', inputmode: 'numeric', min: '0', max: '600', step: '5', placeholder: '例: 90' },
        value: exercise.intervalSeconds ?? ''
      });
      intervalInput.addEventListener('input', (event) => {
        scheduleExerciseFieldUpdate(exercise.id, 'intervalSeconds', event.target.value);
      });
      registerTypingTarget(intervalInput, {
        key: `exercise:${exercise.id}:intervalSeconds`,
        type: 'exercise',
        exerciseId: exercise.id,
        field: 'intervalSeconds',
        apply: (el, value) => applyInputValue(el, value)
      });
      const intervalField = createFieldWrapper('インターバル (秒)', 'セット間の休憩秒数を記録します。', 'タイマーで計測した秒数を入力。', intervalInput);
      scheduleRow.append(performedOnField, intervalField);
      metaPanel.append(scheduleRow);

      return metaPanel;
    };
<!-- PATCH-END: UI-DENSITY -->

    const buildHomeView = () => {
      const nodes = [];

      const quickBody = createElem('div', { className: 'space-y-5' });
      const quickActions = createElem('div', { className: 'flex flex-col gap-3 sm:flex-row' });

      const startLastBtn = createElem('button', {
        className:
          'btn-primary flex-1 rounded-xl px-4 py-3 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500',
        textContent: '前回コピーで開始',
        attrs: { type: 'button' }
      });
      if (!appData.workouts.length) {
        startLastBtn.disabled = true;
        startLastBtn.classList.add('cursor-not-allowed', 'opacity-60');
        startLastBtn.setAttribute('title', '前回の履歴がありません。');
      }
      startLastBtn.addEventListener('click', startWorkoutFromLastHistory);

      const saveTemplateBtn = createElem('button', {
        className:
          'btn-muted flex-1 rounded-xl border border-slate-300 px-4 py-3 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500',
        textContent: 'テンプレートを保存',
        attrs: { type: 'button' }
      });
      if (!appData.currentWorkout.supersets.length) {
        saveTemplateBtn.disabled = true;
        saveTemplateBtn.classList.add('cursor-not-allowed', 'opacity-60');
        saveTemplateBtn.setAttribute('title', '保存できるスーパーセットがありません。');
      }
      saveTemplateBtn.addEventListener('click', saveCurrentWorkoutAsTemplate);

      quickActions.append(startLastBtn, saveTemplateBtn);
      quickBody.append(quickActions);

      const templateSection = createElem('div', { className: 'space-y-3' });
      templateSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: 'テンプレート' }));

      if (!appData.templates.length) {
        templateSection.append(
          createElem('p', {
            className: 'text-sm text-slate-700',
            textContent: '保存されたテンプレートはまだありません。'
          })
        );
      } else {
        const list = createElem('div', { className: 'space-y-3' });
        const sortedTemplates = getSortedTemplates();
        sortedTemplates.forEach((template) => {
          const item = createElem('article', { className: 'space-y-3 rounded-2xl border border-slate-200 bg-white p-4 shadow-sm' });
          const header = createElem('div', { className: 'flex flex-col gap-1 sm:flex-row sm:items-center sm:justify-between' });
          header.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: template.name }));
          const updatedText = template.updatedAt ? `最終更新: ${formatDate(template.updatedAt)}` : '最終更新: -';
          header.append(createElem('span', { className: 'text-xs text-slate-600', textContent: updatedText }));
          item.append(header);

          const blueprint = Array.isArray(template.blueprint) ? template.blueprint : [];
          let exerciseCount = 0;
          let totalSets = 0;
          blueprint.forEach((config) => {
            if (!Array.isArray(config?.slots)) return;
            config.slots.forEach((slot) => {
              if (slot?.name) exerciseCount += 1;
              if (Array.isArray(slot?.sets) && slot.sets.length) {
                totalSets += slot.sets.length;
              } else if (Number.isFinite(Number(slot?.setCount))) {
                totalSets += Math.max(0, Number(slot.setCount));
              }
            });
          });
          const supersetCount = blueprint.length;
          item.append(
            createElem('p', {
              className: 'text-xs text-slate-600',
              textContent: `スーパーセット ${supersetCount} / 種目 ${exerciseCount} / 総セット ${totalSets}`
            })
          );

          const buttonRow = createElem('div', { className: 'flex flex-wrap gap-2' });
          const loadBtn = createElem('button', {
            className: 'btn-primary rounded-lg px-3 py-2 text-xs font-semibold shadow-sm sm:text-sm',
            textContent: '呼び出す',
            attrs: { type: 'button' }
          });
          loadBtn.addEventListener('click', () => applyTemplateById(template.id));
          buttonRow.append(loadBtn);

          const renameBtn = createElem('button', {
            className: 'btn-muted rounded-lg px-3 py-2 text-xs font-semibold sm:text-sm',
            textContent: '名前を変更',
            attrs: { type: 'button' }
          });
          renameBtn.addEventListener('click', () => renameTemplate(template.id));
          buttonRow.append(renameBtn);

          const deleteBtn = createElem('button', {
            className:
              'text-xs font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500 sm:text-sm',
            textContent: '削除',
            attrs: { type: 'button' }
          });
          deleteBtn.addEventListener('click', () => deleteTemplate(template.id));
          buttonRow.append(deleteBtn);

          item.append(buttonRow);
          list.append(item);
        });
        templateSection.append(list);
      }

      quickBody.append(templateSection);
      nodes.push(createCard('クイックスタート', quickBody));

      const workout = appData.currentWorkout;
      const cardBody = createElem('div', { className: 'space-y-5' });
      const partSelector = (() => {
        const section = createElem('section', { className: 'space-y-2' });
        section.append(
          createElem('h3', { className: 'text-sm font-semibold text-slate-900', textContent: '記録する部位' })
        );
        const select = createElem('select', {
          className: 'select-base text-sm font-semibold text-slate-900 bg-white',
          attrs: { name: 'part-selector' }
        });
        const placeholder = createElem('option', { textContent: '未選択', value: '' });
        select.append(placeholder);
        EXERCISE_PARTS.forEach((part) => {
          select.append(createElem('option', { textContent: part.label, value: part.key }));
        });
        select.value = getActivePartKey() || '';
        select.addEventListener('change', (event) => {
          const value = event.target.value || null;
          setSelectedPartKey(value);
        });
        const info = createElem('p', {
          className: 'text-xs text-slate-600',
          textContent: '部位を選ぶと候補が絞り込まれます。'
        });
        section.append(select, info);
        return section;
      })();
      cardBody.append(partSelector);
      const toggleContainer = (() => {
        const wrapper = createElem('div', {
          className: 'inline-flex items-center rounded-full border border-slate-300 bg-slate-100 p-1 text-xs font-semibold'
        });
        const createToggleButton = (mode, label) => {
          const active = workout.entryMode === mode;
          const btn = createElem('button', {
            className: `rounded-full px-3 py-1 transition ${
              active
                ? 'bg-slate-900 text-white shadow-sm'
                : 'text-slate-600 hover:text-slate-900'
            }`,
            attrs: { type: 'button', 'aria-pressed': active ? 'true' : 'false' },
            textContent: label
          });
          btn.addEventListener('click', () => setCurrentWorkoutEntryMode(mode));
          return btn;
        };
        wrapper.append(
          createToggleButton(WORKOUT_ENTRY_MODES.single, 'Single'),
          createToggleButton(WORKOUT_ENTRY_MODES.superset, 'Superset')
        );
        return wrapper;
      })();
      const headerInfo = createElem('p', {
        className: 'rounded-xl border border-slate-300 bg-slate-50 px-4 py-3 text-sm text-slate-800',
        textContent: `開始: ${formatDate(workout.startedAt)}`
      });
      cardBody.append(headerInfo);
      if (workoutHasProvisionalSets(workout)) {
        cardBody.append(
          createElem('p', {
            className: 'provisional-warning rounded-xl px-4 py-3 text-sm font-semibold',
            textContent: '暫定値が含まれているセットがあります。内容を確認し、必要に応じて値を入力してください。'
          })
        );
      }
      if (!workout.supersets.length) {
        const emptyMessage = workout.entryMode === WORKOUT_ENTRY_MODES.single
          ? '種目を追加して記録を始めましょう。'
          : 'スーパーセットを追加して記録を始めましょう。';
        cardBody.append(
          createElem('p', {
            className: 'text-sm leading-relaxed text-slate-800',
            textContent: emptyMessage
          })
        );
      } else {
        workout.supersets.forEach((superset) => {
          supersetFocusRegistry.set(superset.id, []);
          const parityMutated = ensureSupersetParity(superset);
          if (parityMutated) {
            superset.slots.forEach((slot) => {
              if (!slot.exerciseId) return;
              const exercise = getExerciseById(slot.exerciseId);
              if (exercise) {
                recomputeExercise(appData.currentWorkout.id, exercise);
              }
            });
            persist();
          }
          const slotExercises = superset.slots.map((slot) => ({
            slot,
            exercise: slot.exerciseId ? getExerciseById(slot.exerciseId) : null
          }));
          const roundCount = Math.max(0, ...slotExercises.map(({ exercise }) => (exercise ? exercise.sets.length : 0)));
          const supCard = createElem('section', { className: 'space-y-3 rounded-2xl border border-slate-300 bg-white p-4 shadow-sm' });
          const headerRow = createElem('div', { className: 'flex flex-col gap-2 md:flex-row md:items-center md:justify-between' });
          const toggleBtn = createElem('button', {
            className: 'flex items-center gap-2 text-left text-lg font-bold leading-snug text-slate-900 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500',
            attrs: { type: 'button' }
          });
          const caret = createElem('span', { className: 'text-xl text-slate-600', textContent: superset.collapsed ? '▸' : '▾' });
          const titleLabel = createElem('span', { textContent: superset.label });
          toggleBtn.append(caret, titleLabel);
          toggleBtn.addEventListener('click', () => toggleSupersetCollapsed(superset.id));
          headerRow.append(toggleBtn);
          headerRow.append(
            createElem('span', {
              className: 'text-sm font-semibold text-slate-700',
              textContent: `${roundCount} ラウンド`
            })
          );
          supCard.append(headerRow);

          const controls = createElem('div', { className: 'flex flex-wrap items-center gap-2 text-sm leading-snug' });
          const restInput = createElem('input', {
            className: 'input-base w-24 text-sm',
            attrs: { type: 'number', min: '10', max: '600', step: '5' },
            value: superset.restSeconds ?? DEFAULT_SUPERSET_REST
          });
          const timerBtn = createElem('button', {
            className: 'btn-primary rounded-lg px-3 py-2 text-sm font-semibold shadow-sm',
            attrs: { type: 'button' },
            textContent: `休憩 ${superset.restSeconds}秒`
          });
          attachTimerUpdater(superset.id, (remaining, active) => {
            if (active) {
              timerBtn.textContent = `残り ${Math.max(0, remaining)}秒`;
              timerBtn.classList.add('animate-pulse');
            } else {
              const base = restInput.value || superset.restSeconds;
              timerBtn.textContent = `休憩 ${base}秒`;
              timerBtn.classList.remove('animate-pulse');
            }
          });
          timerBtn.addEventListener('click', () => startSupersetTimer(superset.id));
          restInput.addEventListener('input', (event) => {
            const value = event.target.value;
            scheduleSupersetFieldUpdate(superset.id, 'restSeconds', value);
            const parsed = safeNumber(value);
            if (parsed !== null) {
              const sup = getSupersetById(superset.id);
              if (sup) {
                sup.restSeconds = Math.max(10, Math.min(600, Math.round(parsed)));
              }
            }
            timerBtn.textContent = `休憩 ${value || superset.restSeconds}秒`;
          });
          registerTypingTarget(restInput, {
            key: `superset:${superset.id}:restSeconds`,
            type: 'superset',
            supersetId: superset.id,
            field: 'restSeconds',
            apply: (el, value) => applyInputValue(el, value),
            sync: () => {
              const sup = getSupersetById(superset.id);
              const fallback = sup?.restSeconds ?? DEFAULT_SUPERSET_REST;
              const display = restInput.value || fallback;
              timerBtn.textContent = `休憩 ${display}秒`;
            }
          });
          const restLabel = createElem('label', { className: 'flex w-28 flex-col gap-1 text-[0.65rem] font-semibold uppercase tracking-wide text-slate-500 leading-snug' });
          restLabel.append(
            createElem('span', { className: 'text-slate-600', textContent: '休憩プリセット' }),
            restInput
          );
          const addRoundBtn = createElem('button', {
            className: 'btn-muted rounded-lg border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100',
            attrs: { type: 'button' },
            textContent: 'セット追加'
          });
          addRoundBtn.addEventListener('click', () => addSupersetRound(superset.id));
          const duplicateBtn = createElem('button', {
            className: 'btn-muted rounded-lg border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100',
            attrs: { type: 'button' },
            textContent: superset.mode === WORKOUT_ENTRY_MODES.single ? '複製' : 'グループ複製'
          });
          duplicateBtn.addEventListener('click', () => duplicateSuperset(superset.id));
          const deleteBtn = createElem('button', {
            className: 'text-sm font-semibold text-red-700 underline decoration-dotted hover:text-red-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500',
            attrs: { type: 'button' },
            textContent: '削除'
          });
          deleteBtn.addEventListener('click', () => deleteSuperset(superset.id));
          controls.append(timerBtn, restLabel, addRoundBtn, duplicateBtn, deleteBtn);
          supCard.append(controls);

          const body = createElem('div', { className: 'space-y-3' });
          if (superset.collapsed) body.classList.add('hidden');
          const hasExercises = slotExercises.some(({ exercise }) => exercise);
          if (!hasExercises) {
            body.append(
              createElem('p', {
                className: 'text-sm leading-snug text-slate-700',
                textContent: 'このスーパーセットにはまだ種目が設定されていません。'
              })
            );
          } else if (roundCount <= 0) {
            body.append(
              createElem('p', {
                className: 'text-sm leading-snug text-slate-700',
                textContent: 'セットを追加して記録を開始しましょう。'
              })
            );
          }
          const roundsContainer = createElem('div', { className: 'space-y-3' });
          const iterationCount = Math.max(roundCount, 1);
          for (let index = 0; index < iterationCount; index += 1) {
                const round = createElem('div', {
                  className: 'space-y-3 rounded-2xl border border-slate-200 bg-white p-3 shadow-sm',
                  attrs: { title: '長押しでこのラウンドを複製できます' }
                });
                registerLongPress(round, () => duplicateSupersetRound(superset.id, index));
                const roundHeader = createElem('div', { className: 'flex items-center justify-between text-sm font-semibold leading-snug text-slate-800' });
                roundHeader.append(createElem('span', { textContent: `ラウンド ${index + 1}` }));
                const canRemove = slotExercises.some(({ exercise }) => exercise && exercise.sets.length > 1);
                const removeBtn = createElem('button', {
                  className: 'text-xs font-semibold leading-snug text-red-700 underline decoration-dotted hover:text-red-800',
                  attrs: { type: 'button' },
                  textContent: 'ラウンド削除'
                });
                if (!canRemove) {
                  removeBtn.disabled = true;
                  removeBtn.classList.add('cursor-not-allowed', 'opacity-60');
                } else {
                  removeBtn.addEventListener('click', () => removeSupersetRound(superset.id, index));
                }
                roundHeader.append(removeBtn);
                round.append(roundHeader);

                const slotGrid = createElem('div', {
                  className: 'grid grid-cols-1 gap-x-3 gap-y-3 md:grid-cols-2'
                });
                const weightInputs = [];
                const repsInputs = [];
                const noteInputs = [];
                slotExercises.forEach(({ slot, exercise }) => {
                  const slotCard = createElem('div', {
                    className:
                      superset.mode === WORKOUT_ENTRY_MODES.single
                        ? 'rounded-2xl border border-slate-200 bg-white shadow-sm overflow-hidden'
                        : 'rounded-2xl border border-slate-200 bg-slate-50 shadow-sm overflow-hidden'
                  });
                  const slotTitle = superset.mode === WORKOUT_ENTRY_MODES.single
                    ? exercise
                      ? exercise.name
                      : '未設定'
                    : `${slot.groupId ?? '種目'}: ${exercise ? exercise.name : '未設定'}`;
                  const collapseKey = buildSetCollapseKey(superset.id, slot.groupId, index);
                  const baseSet = exercise?.sets?.[index];
                  const hasWeightValue = baseSet && baseSet.weight !== null && baseSet.weight !== undefined && baseSet.weight !== '';
                  const hasRepsValue = baseSet && baseSet.reps !== null && baseSet.reps !== undefined && baseSet.reps !== '';
                  const defaultCollapsed = Boolean(hasWeightValue || hasRepsValue);
                  const isCollapsed = getSetCollapsedState(collapseKey, defaultCollapsed);
                  const details = createElem('details', { className: 'group' });
                  if (!isCollapsed) {
                    details.setAttribute('open', '');
                  }
                  const summary = createElem('summary', {
                    className: 'flex items-center justify-between gap-3 px-3 py-2 text-sm font-semibold leading-snug text-slate-900 cursor-pointer focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500'
                  });
                  const summaryContent = createElem('div', { className: 'flex flex-col gap-0.5 leading-snug' });
                  const summaryTitle = createElem('span', { textContent: slotTitle });
                  const summaryStats = createElem('span', {
                    className: 'text-xs font-medium leading-snug text-slate-500',
                    textContent: exercise ? '' : '未設定'
                  });
                  summaryContent.append(summaryTitle, summaryStats);
                  const summaryCaret = createElem('span', {
                    className: 'text-lg text-slate-500 transition-transform duration-150',
                    textContent: isCollapsed ? '▸' : '▾'
                  });
                  summary.append(summaryContent, summaryCaret);
                  details.append(summary);
                  const detailBody = createElem('div', { className: 'grid grid-cols-1 gap-x-3 gap-y-2 px-3 pb-3 pt-2 md:grid-cols-2' });
                  const exerciseControl = createOptionControl({
                    field: 'exercise',
                    valueKey: exercise?.nameKey ?? null,
                    partKey: getActivePartKey() || getExercisePartByKey(exercise?.nameKey),
                    placeholder: '種目を選択',
                    onCommit: (value) => setSupersetSlotExercise(superset.id, slot.groupId, value)
                  });
                  const exerciseField = createFieldWrapper('種目', 'この枠で記録する種目を選択します。', '自由入力を有効にすると候補にない名称も追加できます。', exerciseControl);
                  exerciseField.classList.add('md:col-span-2');
                  detailBody.append(exerciseField);
                  if (!exercise) {
                    const helper = createElem('p', {
                      className: 'md:col-span-2 rounded-xl border border-dashed border-slate-200 bg-slate-50 px-3 py-2 text-xs font-semibold leading-snug text-slate-600',
                      textContent: '種目を設定すると入力できるようになります。'
                    });
                    detailBody.append(helper);
                  } else {
                    const set = exercise.sets[index];
                    let oneRmLabel = null;
                    const provisionalWarning = createElem('p', {
                      className: 'provisional-warning hidden rounded-lg px-3 py-2 text-xs font-semibold leading-snug md:col-span-2',
                      textContent: '暫定値のため集計と推定1RMには含まれません。'
                    });
                    const formatSummaryPart = (value, suffix = '') => {
                      if (value === null || value === undefined || value === '') return '--';
                      return `${value}${suffix}`;
                    };
                    const syncProvisionalVisuals = () => {
                      const context = findExerciseContext(exercise.id);
                      const currentSet = context?.exercise?.sets?.[index] || set;
                      const status = analyzeSetCompletion(currentSet);
                      applyProvisionalHighlight(weightInput, status.missingWeight);
                      applyProvisionalHighlight(repsInput, status.missingReps);
                      if (status.isProvisional) {
                        provisionalWarning.classList.remove('hidden');
                        summaryStats.classList.add('text-amber-600');
                      } else {
                        provisionalWarning.classList.add('hidden');
                        summaryStats.classList.remove('text-amber-600');
                      }
                      const contextForSummary = context?.exercise?.sets?.[index] || set;
                      const summaryParts = [
                        formatSummaryPart(contextForSummary?.weight, appData.settings.unit),
                        formatSummaryPart(contextForSummary?.reps, '回'),
                        formatSummaryPart(exercise.intervalSeconds, '秒')
                      ];
                      summaryStats.textContent = summaryParts.join(' / ');
                    };
                    const updateOneRmLabel = () => {
                      if (!oneRmLabel) return;
                      const context = findExerciseContext(exercise.id);
                      const currentSet = context?.exercise?.sets?.[index];
                      const value = currentSet?.oneRM;
                      oneRmLabel.textContent = value ? `推定1RM: ${value} ${appData.settings.unit}` : '推定1RM: -';
                    };
                    const syncDerivedState = () => {
                      updateOneRmLabel();
                      syncProvisionalVisuals();
                    };
                    const weightInput = createElem('input', {
                      className: 'input-base text-slate-900 placeholder-slate-400',
                      attrs: { type: 'number', inputmode: 'decimal', min: '0', step: '0.5' },
                      value: set?.weight ?? ''
                    });
                    weightInput.addEventListener('input', (event) => {
                      scheduleSetFieldUpdate(exercise.id, index, 'weight', event.target.value);
                    });
                    registerTypingTarget(weightInput, {
                      key: `set:${exercise.id}:${index}:weight`,
                      type: 'set',
                      exerciseId: exercise.id,
                      setIndex: index,
                      field: 'weight',
                      apply: (el, value) => applyInputValue(el, value),
                      sync: syncDerivedState
                    });
                    const weightField = createFieldWrapper(`重量 (${appData.settings.unit})`, 'このセットで扱った重量です。', '小数点も入力できます。', weightInput);
                    detailBody.append(weightField);
                    weightInputs.push(weightInput);

                    const repsInput = createElem('input', {
                      className: 'input-base text-slate-900 placeholder-slate-400',
                      attrs: { type: 'number', inputmode: 'numeric', min: '0', step: '1' },
                      value: set?.reps ?? ''
                    });
                    repsInput.addEventListener('input', (event) => {
                      scheduleSetFieldUpdate(exercise.id, index, 'reps', event.target.value);
                    });
                    registerTypingTarget(repsInput, {
                      key: `set:${exercise.id}:${index}:reps`,
                      type: 'set',
                      exerciseId: exercise.id,
                      setIndex: index,
                      field: 'reps',
                      apply: (el, value) => applyInputValue(el, value),
                      sync: syncDerivedState
                    });
                    const repsField = createFieldWrapper('回数', '完了した反復回数を入力します。', '失敗した場合は実際の回数を。', repsInput);
                    detailBody.append(repsField);
                    repsInputs.push(repsInput);

                    const noteInput = createElem('textarea', {
                      className: 'input-base min-h-[3rem] text-slate-900 placeholder-slate-400',
                      attrs: { rows: '2', placeholder: 'フォームや感覚をメモ' }
                    });
                    noteInput.value = set?.note || '';
                    noteInput.addEventListener('input', (event) => {
                      scheduleSetFieldUpdate(exercise.id, index, 'note', event.target.value);
                    });
                    registerTypingTarget(noteInput, {
                      key: `set:${exercise.id}:${index}:note`,
                      type: 'set',
                      exerciseId: exercise.id,
                      setIndex: index,
                      field: 'note',
                      apply: (el, value) => applyInputValue(el, value),
                      sync: updateOneRmLabel
                    });
                    const noteField = createFieldWrapper('セットメモ', '気づいたことや次回の課題を記録します。', 'フォームやRPEを自由に入力。', noteInput);
                    noteField.classList.add('md:col-span-2');
                    detailBody.append(noteField);
                    noteInputs.push(noteInput);

                    oneRmLabel = createElem('p', {
                      className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-medium leading-snug text-slate-800 md:col-span-2',
                      textContent: set?.oneRM ? `推定1RM: ${set.oneRM} ${appData.settings.unit}` : '推定1RM: -'
                    });
                    syncDerivedState();
                    detailBody.append(oneRmLabel);
                    detailBody.append(provisionalWarning);
                  }
                  details.append(detailBody);
                  details.addEventListener('toggle', () => {
                    const collapsedNow = !details.open;
                    setSetCollapsedState(collapseKey, collapsedNow);
                    summaryCaret.textContent = collapsedNow ? '▸' : '▾';
                  });
                  details.addEventListener('focusin', () => {
                    if (!details.open) {
                      details.open = true;
                      summaryCaret.textContent = '▾';
                      setSetCollapsedState(collapseKey, false);
                    }
                  });
                  slotCard.append(details);
                  slotGrid.append(slotCard);
                });
                weightInputs.forEach((input) => {
                  registerSupersetFocusInput(superset.id, input);
                  bindSupersetFocusNavigation(superset.id, input);
                });
                repsInputs.forEach((input) => {
                  registerSupersetFocusInput(superset.id, input);
                  bindSupersetFocusNavigation(superset.id, input);
                });
                noteInputs.forEach((input) => {
                  registerSupersetFocusInput(superset.id, input);
                  bindSupersetFocusNavigation(superset.id, input);
                });
                round.append(slotGrid);
                roundsContainer.append(round);
          }
          body.append(roundsContainer);

          const metaGrid = createElem('div', {
            className: 'grid grid-cols-1 gap-x-3 gap-y-3 md:grid-cols-2'
          });
          slotExercises.forEach(({ slot, exercise }) => {
            if (!exercise) return;
            const wrapper = createElem('div', { className: 'space-y-2 leading-snug' });
            wrapper.append(
              createElem('h4', {
                className: 'text-sm font-semibold leading-snug text-slate-900',
                textContent:
                  superset.mode === WORKOUT_ENTRY_MODES.single
                    ? exercise.name
                    : `${slot.groupId ?? '種目'}: ${exercise.name}`
              })
            );
            wrapper.append(createExerciseMetaPanel(exercise));
            metaGrid.append(wrapper);
          });
          if (metaGrid.children.length) {
            body.append(metaGrid);
          }
          supCard.append(body);
          cardBody.append(supCard);
        });
      }
      const addExerciseLabel = workout.entryMode === WORKOUT_ENTRY_MODES.single ? '種目を追加' : 'スーパーセットを追加';
      const latestSuperset = workout.supersets[workout.supersets.length - 1] || null;
      const actionBarContainer = createElem('div', { className: 'pointer-events-auto mx-auto max-w-3xl' });
      const actionBar = createElem('div', {
        className: 'grid grid-cols-1 gap-2 rounded-2xl border border-slate-300 bg-white/95 p-2 shadow-xl backdrop-blur-sm sm:grid-cols-3'
      });
      const saveBtn = createElem('button', {
        className: 'btn-primary w-full rounded-xl px-3 py-2 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500',
        textContent: '保存',
        attrs: { type: 'button', title: '完了して履歴へ' }
      });
      saveBtn.addEventListener('click', finishWorkout);
      const addBtn = createElem('button', {
        className: 'btn-muted w-full rounded-xl border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500',
        textContent: '追加',
        attrs: { type: 'button', title: addExerciseLabel }
      });
      addBtn.addEventListener('click', addSuperset);
      const duplicateBtn = createElem('button', {
        className: 'btn-muted w-full rounded-xl border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-900 shadow-sm hover:bg-slate-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500',
        textContent: '複製',
        attrs: {
          type: 'button',
          title: latestSuperset ? `${latestSuperset.label} を複製` : '複製できるスーパーセットがありません。'
        }
      });
      if (latestSuperset) {
        duplicateBtn.addEventListener('click', () => duplicateSuperset(latestSuperset.id));
      } else {
        duplicateBtn.disabled = true;
        duplicateBtn.classList.add('cursor-not-allowed', 'opacity-60');
      }
      actionBar.append(saveBtn, addBtn, duplicateBtn);
      actionBarContainer.append(actionBar);
      scheduleActionBar([actionBarContainer]);
      nodes.push(createCard('現在のワークアウト', cardBody, { headerNodes: [toggleContainer] }));
      return nodes;
    };

    const buildHistoryView = () => {
      const nodes = [];
      const cardBody = createElem('div', { className: 'space-y-6' });
      if (!appData.workouts.length) {
        historyListScrollTop = 0;
        cardBody.append(createElem('p', { className: 'text-sm text-slate-800', textContent: '履歴はまだありません。' }));
      } else {
        cardBody.append(createHistoryVirtualList(appData.workouts));
      }

      if (!historyChartCanvas) {
        historyChartCanvas = createElem('canvas');
      }
      const chartContainer = createElem('div', { className: 'mt-6 h-64 relative' });
      chartContainer.append(historyChartCanvas);
      cardBody.append(chartContainer);

      if (historyChartObserver && historyChartHost && historyChartHost !== chartContainer) {
        historyChartObserver.unobserve(historyChartHost);
      }
      historyChartHost = chartContainer;

      const exerciseKey = appData.historyView.exerciseKey;
      if (exerciseKey) {
        const exerciseLabel = getExerciseLabelByKey(exerciseKey) || '';
        const dataset = [];
        appData.workouts.slice().reverse().forEach((workout) => {
          workout.exercises
            .filter((ex) => (ex.nameKey ? ex.nameKey === exerciseKey : ex.name === exerciseLabel))
            .forEach((exercise) => {
              const validSets = exercise.sets.filter(
                (set) => !set.isProvisional && Number.isFinite(Number(set.oneRM))
              );
              if (!validSets.length) return;
              const best = Math.max(...validSets.map((set) => Number(set.oneRM)));
              dataset.push({ date: workout.completedAt || workout.startedAt, value: best });
            });
        });
        historyChartPendingData = {
          labels: dataset.map((d) => formatDate(d.date)),
          values: dataset.map((d) => d.value)
        };
      } else {
        historyChartPendingData = { labels: [], values: [] };
      }

      if (historyChartManager) {
        applyHistoryChartData();
      } else {
        ensureHistoryChartObserver();
        if (historyChartObserver) {
          historyChartObserver.observe(chartContainer);
        }
      }

      nodes.push(createCard('ワークアウト履歴', cardBody));
      return nodes;
    };

<!-- PATCH-START: WORKOUT-RENDER -->
    const buildWorkoutView = () => {
      const nodes = [];
      const cardBody = createElem('div', { className: 'space-y-6' });
      if (!appData.workouts.length) {
        cardBody.append(createElem('p', { className: 'text-sm text-slate-800', textContent: '保存済みのワークアウトはありません。' }));
      } else {
        const latest = appData.workouts[0];
        cardBody.append(createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: `最新の完了日時: ${formatDate(latest.completedAt || latest.startedAt)}` }));
        latest.exercises.forEach((exercise) => {
          const block = createElem('div', { className: 'space-y-3 rounded-2xl border border-slate-300 bg-white p-5 shadow-sm' });
          block.append(createElem('h3', { className: 'text-base font-bold text-slate-900', textContent: exercise.name }));
          const metaItems = [
            { label: '器具', value: exercise.equipment },
            { label: 'アタッチメント', value: exercise.attachment },
            { label: '角度 (°)', value: exercise.angle != null ? `${exercise.angle}°` : null },
            { label: 'スタンス / ポジション', value: exercise.position },
            { label: '実施日', value: exercise.performedOn },
            { label: 'インターバル (秒)', value: exercise.intervalSeconds != null ? `${exercise.intervalSeconds}秒` : null }
          ].filter((item) => item.value !== null && item.value !== undefined && item.value !== '');
          if (metaItems.length) {
            const metaList = createElem('ul', { className: 'grid grid-cols-1 gap-2 text-sm text-slate-800 sm:grid-cols-2' });
            metaItems.forEach(({ label, value }) => {
              const meta = createElem('li', { className: 'rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 shadow-sm' });
              meta.append(
                createElem('p', { className: 'text-xs font-semibold uppercase tracking-wide text-slate-800', textContent: label }),
                createElem('p', { className: 'text-sm font-medium text-slate-900', textContent: value })
              );
              metaList.append(meta);
            });
            block.append(metaList);
          }
          const list = createElem('ul', { className: 'space-y-2' });
          exercise.sets.forEach((set, idx) => {
            const isProvisional = Boolean(set?.isProvisional);
            const weightLabel = set?.weight ?? '-';
            const repsLabel = set?.reps ?? '-';
            const oneRmLabel = set?.oneRM ?? '-';
            const suffix = isProvisional ? ' ※暫定' : '';
            list.append(
              createElem('li', {
                className: 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-800 shadow-sm',
                textContent: `#${idx + 1} 重量:${weightLabel}${appData.settings.unit} / 回数:${repsLabel} / 推定1RM:${oneRmLabel}${suffix}`
              })
            );
          });
          block.append(list);
          cardBody.append(block);
        });
      }
      nodes.push(createCard('最新のワークアウト', cardBody));
      return nodes;
    };
<!-- PATCH-END: WORKOUT-RENDER -->

    const buildSettingsView = () => {
      const nodes = [];
      const cardBody = createElem('div', { className: 'space-y-6' });
      const unitSection = createElem('div', { className: 'space-y-3' });
      unitSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '単位設定' }));
      const unitOptions = ['kg', 'lb'];
      const unitWrap = createElem('div', { className: 'flex gap-3' });
      unitOptions.forEach((unit) => {
        const label = createElem('label', { className: 'inline-flex items-center gap-2 text-sm text-slate-800 font-semibold' });
        const input = createElem('input', { attrs: { type: 'radio', name: 'unit', value: unit } });
        if (appData.settings.unit === unit) input.checked = true;
        input.addEventListener('change', () => changeUnit(unit));
        label.append(input, createElem('span', { textContent: unit }));
        unitWrap.append(label);
      });
      unitSection.append(unitWrap);
      cardBody.append(unitSection);

      const inputModeSection = createElem('div', { className: 'space-y-2' });
      inputModeSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '入力モード' }));
      const freeInputLabel = createElem('label', { className: 'inline-flex items-center gap-3 text-sm font-semibold text-slate-800' });
      const freeInputToggle = createElem('input', { attrs: { type: 'checkbox' } });
      freeInputToggle.checked = Boolean(appData.settings.allowFreeInput);
      freeInputToggle.addEventListener('change', (event) => {
        appData.settings.allowFreeInput = Boolean(event.target.checked);
        persist();
        requestRender();
      });
      freeInputLabel.append(freeInputToggle, createElem('span', { textContent: '自由入力を許可' }));
      inputModeSection.append(
        freeInputLabel,
        createElem('p', {
          className: 'text-xs text-slate-600',
          textContent: 'ONにすると候補にない名称も追加できます。保存時は正規化され、内部キーの一意性が保たれます。'
        })
      );
      cardBody.append(inputModeSection);

      const provisionalSection = createElem('div', { className: 'space-y-2' });
      provisionalSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '暫定値の扱い' }));
      const provisionalLabel = createElem('label', { className: 'inline-flex items-center gap-3 text-sm font-semibold text-slate-800' });
      const provisionalToggle = createElem('input', { attrs: { type: 'checkbox' } });
      provisionalToggle.checked = Boolean(appData.settings.allowProvisionalValues);
      provisionalToggle.addEventListener('change', (event) => {
        appData.settings.allowProvisionalValues = Boolean(event.target.checked);
        recomputeAll();
        persist();
        requestRender();
      });
      provisionalLabel.append(provisionalToggle, createElem('span', { textContent: '暫定値を許容' }));
      provisionalSection.append(
        provisionalLabel,
        createElem('p', {
          className: 'text-xs text-slate-600',
          textContent: 'ONにすると重量や回数が未入力でも保存できます。暫定値は集計と推定1RMから除外され、次回編集時に注意喚起されます。'
        })
      );
      cardBody.append(provisionalSection);

      const catalogSection = createElem('div', { className: 'space-y-3' });
      catalogSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '登録済み種目' }));
      const list = createElem('ul', { className: 'space-y-2' });
      appData.settings.exerciseCatalog.forEach((key) => {
        const label = getExerciseLabelByKey(key) || key;
        list.append(createElem('li', { className: 'text-sm text-slate-800 px-3 py-2 bg-slate-100 rounded-lg border border-slate-200', textContent: label }));
      });
      catalogSection.append(list);
      cardBody.append(catalogSection);

      const templateManagerSection = (() => {
        const section = createElem('div', { className: 'space-y-3' });
        section.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: 'プリセット管理' }));
        section.append(
          createElem('p', {
            className: 'text-xs text-slate-600',
            textContent: 'テンプレートの保存や呼び出しを設定タブから操作できます。'
          })
        );
        section.append(
          createElem('p', {
            className: 'rounded-xl border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600',
            textContent: `保存済みプリセット: ${appData.templates.length}件`
          })
        );

        const actions = createElem('div', { className: 'grid gap-2 sm:grid-cols-2' });
        const createActionButton = (label, handler, { variant = 'primary', disabled = false, tooltip = null } = {}) => {
          const baseClass =
            variant === 'primary'
              ? 'btn-primary rounded-xl px-4 py-2 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500'
              : 'btn-muted rounded-xl px-4 py-2 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500';
          const button = createElem('button', { className: baseClass, textContent: label, attrs: { type: 'button' } });
          if (disabled) {
            button.disabled = true;
            button.classList.add('cursor-not-allowed', 'opacity-60');
            if (tooltip) button.setAttribute('title', tooltip);
          } else {
            button.addEventListener('click', handler);
          }
          return button;
        };

        const hasTemplates = appData.templates.length > 0;
        const hasCurrentWorkout = appData.currentWorkout.supersets.length > 0;

        actions.append(
          createActionButton('プリセットを保存', saveCurrentWorkoutAsTemplate, {
            variant: 'primary',
            disabled: !hasCurrentWorkout,
            tooltip: '保存できるスーパーセットがありません。'
          }),
          createActionButton(
            'プリセットを呼び出す',
            async () => {
              const templateId = await pickTemplateId('呼び出すテンプレートを選択');
              if (!templateId) return;
              applyTemplateById(templateId);
            },
            {
              variant: 'muted',
              disabled: !hasTemplates,
              tooltip: '保存されたテンプレートがありません。'
            }
          ),
          createActionButton(
            'プリセットを上書き',
            async () => {
              const templateId = await pickTemplateId('上書きするテンプレートを選択');
              if (!templateId) return;
              await overwriteTemplateWithCurrentWorkout(templateId);
            },
            {
              variant: 'muted',
              disabled: !hasTemplates || !hasCurrentWorkout,
              tooltip: !hasTemplates
                ? '保存されたテンプレートがありません。'
                : '上書きできるスーパーセットがありません。'
            }
          ),
          createActionButton(
            'プリセットを削除',
            async () => {
              const templateId = await pickTemplateId('削除するテンプレートを選択');
              if (!templateId) return;
              await deleteTemplate(templateId);
            },
            {
              variant: 'muted',
              disabled: !hasTemplates,
              tooltip: '保存されたテンプレートがありません。'
            }
          )
        );
        section.append(actions);

        if (!hasTemplates) {
          section.append(
            createElem('p', { className: 'text-xs text-slate-600', textContent: '保存済みのプリセットはまだありません。' })
          );
        } else {
          const list = createElem('ul', { className: 'space-y-2' });
          getSortedTemplates().forEach((template) => {
            const item = createElem('li', {
              className: 'rounded-xl border border-slate-200 bg-white px-3 py-2 shadow-sm'
            });
            item.append(
              createElem('p', { className: 'text-sm font-semibold text-slate-900', textContent: template.name }),
              createElem('p', {
                className: 'text-xs text-slate-600',
                textContent: template.updatedAt ? `最終更新: ${formatDate(template.updatedAt)}` : '最終更新: -'
              })
            );
            list.append(item);
          });
          section.append(list);
        }

        return section;
      })();
      cardBody.append(templateManagerSection);

      const importExportSection = createElem('div', { className: 'space-y-3' });
      importExportSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: 'バックアップ' }));
      const exportBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'エクスポート', attrs: { type: 'button' } });
      exportBtn.addEventListener('click', exportData);
      const importLabel = createElem('label', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold inline-flex items-center justify-center gap-2 w-fit cursor-pointer' });
      importLabel.append(createElem('span', { textContent: 'インポート' }));
      const input = createElem('input', { attrs: { type: 'file', accept: '.csv,text/csv' } });
      input.classList.add('hidden');
      input.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        importData(file);
        event.target.value = '';
      });
      importLabel.append(input);
      importExportSection.append(createElem('div', { className: 'flex gap-3', children: [exportBtn, importLabel] }));
      cardBody.append(importExportSection);

      const selfCheckSection = (() => {
        const section = createElem('div', { className: 'space-y-4' });
        section.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '自己診断' }));

        const bannerClassMap = {
          pass: 'bg-green-50 border-green-200 text-green-900',
          warn: 'bg-yellow-50 border-yellow-200 text-yellow-900',
          fail: 'bg-red-50 border-red-200 text-red-900'
        };
        const badgeClassMap = {
          pass: 'bg-green-100 text-green-800 border-green-200',
          warn: 'bg-yellow-100 text-yellow-800 border-yellow-300',
          fail: 'bg-red-100 text-red-800 border-red-300'
        };

        const actionRow = createElem('div', { className: 'flex flex-wrap items-center gap-3' });
        const runBtn = createElem('button', {
          className: 'btn-primary rounded-xl px-4 py-2 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500',
          textContent: '自己診断を実行',
          attrs: { type: 'button' }
        });
        const copyBtn = createElem('button', {
          className: 'btn-muted rounded-xl px-4 py-2 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-500',
          textContent: '診断レポートをコピー',
          attrs: { type: 'button' }
        });
        actionRow.append(runBtn, copyBtn);
        section.append(actionRow);

        const banner = createElem('div', {
          className: 'rounded-2xl border px-4 py-3 text-sm font-semibold bg-slate-100 text-slate-800'
        });
        section.append(banner);

        const list = createElem('ul', { className: 'space-y-3' });
        section.append(list);

        const testCard = createElem('div', {
          className: 'space-y-2 rounded-2xl border border-dashed border-slate-300 bg-slate-50 px-4 py-3'
        });
        testCard.append(
          createElem('p', {
            className: 'text-[11px] font-semibold uppercase tracking-wide text-slate-500',
            textContent: 'テスト用トグル'
          })
        );

        const latestFlags = appData.settings.selfCheck?.testFlags || {};
        const makeTestToggle = (labelText, flagKey) => {
          const label = createElem('label', {
            className: 'flex items-center gap-3 text-xs font-semibold text-slate-700'
          });
          const input = createElem('input', { attrs: { type: 'checkbox' } });
          input.checked = Boolean(latestFlags[flagKey]);
          input.addEventListener('change', (event) => {
            if (!appData.settings.selfCheck || typeof appData.settings.selfCheck !== 'object') {
              appData.settings.selfCheck = { testFlags: {} };
            }
            if (!appData.settings.selfCheck.testFlags || typeof appData.settings.selfCheck.testFlags !== 'object') {
              appData.settings.selfCheck.testFlags = {};
            }
            appData.settings.selfCheck.testFlags[flagKey] = Boolean(event.target.checked);
            persist();
            runDiagnostics();
          });
          label.append(input, createElem('span', { textContent: labelText }));
          return label;
        };

        testCard.append(
          makeTestToggle('入力ロック警告を強制', 'forceInputLockWarning'),
          makeTestToggle('未コミット検知を強制', 'forceBufferWarning'),
          createElem('p', {
            className: 'text-[11px] text-slate-500',
            textContent: 'ONにすると意図的に警告を発火させて挙動を確認できます。'
          })
        );
        section.append(testCard);

        let latestResult = null;

        const applyResult = (result) => {
          latestResult = result;
          const statusKey = bannerClassMap[result.status] ? result.status : 'pass';
          banner.className = `rounded-2xl border px-4 py-3 text-sm font-semibold ${bannerClassMap[statusKey] || bannerClassMap.pass}`;
          banner.textContent = result.summaryMessage;
          list.innerHTML = '';
          result.entries.forEach((entry) => {
            const item = createElem('li', { className: 'rounded-2xl border border-slate-200 bg-white px-4 py-3 shadow-sm' });
            const header = createElem('div', { className: 'flex items-start justify-between gap-3' });
            header.append(
              createElem('span', { className: 'text-sm font-semibold text-slate-900', textContent: entry.title }),
              createElem('span', {
                className: `inline-flex items-center rounded-full border px-2 py-0.5 text-xs font-bold uppercase tracking-wide ${badgeClassMap[entry.status] || badgeClassMap.pass}`,
                textContent: result.labels[entry.status] || result.labels.pass
              })
            );
            const detail = createElem('p', {
              className: 'mt-2 whitespace-pre-wrap text-sm text-slate-700 break-words',
              textContent: entry.detail
            });
            item.append(header, detail);
            list.append(item);
          });
        };

        const runDiagnostics = () => {
          if (SAFE_MODE) {
            const result = {
              status: 'warn',
              summaryMessage: '安全モードでは自己診断をスキップしています',
              entries: [],
              labels: { warn: 'SKIP', pass: 'PASS', fail: 'FAIL' },
              report: ''
            };
            applyResult(result);
            return;
          }
          const result = runSelfCheck();
          applyResult(result);
        };

        runBtn.addEventListener('click', () => {
          runDiagnostics();
        });

        copyBtn.addEventListener('click', async () => {
          const report = latestResult?.report;
          if (!report) return;
          try {
            await navigator.clipboard.writeText(report);
            const original = copyBtn.textContent;
            copyBtn.textContent = 'コピーしました';
            copyBtn.disabled = true;
            setTimeout(() => {
              copyBtn.textContent = original;
              copyBtn.disabled = false;
            }, 2000);
          } catch (err) {
            pushError(`クリップボードへのコピーに失敗しました: ${err?.message || err}`);
          }
        });

        runDiagnostics();

        return section;
      })();
      cardBody.append(selfCheckSection);

      const dangerSection = createElem('div', { className: 'space-y-3' });
      dangerSection.append(createElem('h3', { className: 'text-base font-semibold text-red-700', textContent: 'データ初期化' }));
      const clearBtn = createElem('button', { className: 'bg-red-700 hover:bg-red-800 text-white px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'すべて削除', attrs: { type: 'button' } });
      clearBtn.addEventListener('click', clearAllData);
      dangerSection.append(clearBtn);
      cardBody.append(dangerSection);

      nodes.push(createCard('設定', cardBody));
      return nodes;
    };

    const viewBuilders = {
      [ROUTES.HOME]: buildHomeView,
      [ROUTES.HISTORY]: buildHistoryView,
      [ROUTES.SETTINGS]: buildSettingsView,
      [ROUTES.WORKOUT]: buildWorkoutView
    };

<!-- PATCH-START: BOOT-SAFE -->
    const render = (state) => {
      optionControlSequence = 0;
      scheduledActionBarContent = null;
      if (!appRoot) return;
      const route = ROUTE_VALUES.has(state.route) ? state.route : ROUTES.HOME;
      updateTabState(route);
      Object.entries(viewHosts).forEach(([key, host]) => {
        if (key === route) {
          host.classList.remove('hidden');
        } else {
          host.classList.add('hidden');
        }
      });
      const host = viewHosts[route] || viewHosts[ROUTES.HOME];
      const typingLockActive = typingState.active && typingState.route === route;
      if (typingLockActive) {
        const patched = applyTypingPatch();
        if (patched) {
          const nowIso = new Date().toISOString();
          typingState.pendingRender = true;
          typingDiagnostics.pendingSince = Date.now();
          typingDiagnostics.blockedRenderCount += 1;
          typingDiagnostics.lastBlockedRoute = route;
          typingDiagnostics.lastBlockedAt = nowIso;
          return;
        }
        if (typingState.active && typingState.route === route) {
          const nowIso = new Date().toISOString();
          typingDiagnostics.breachCount += 1;
          typingDiagnostics.lastBreachRoute = route;
          typingDiagnostics.lastBreachAt = nowIso;
        }
        typingState.pendingRender = false;
        typingDiagnostics.pendingSince = null;
      } else {
        typingState.pendingRender = false;
        typingDiagnostics.pendingSince = null;
      }
      const builder = viewBuilders[route] || viewBuilders[ROUTES.HOME];
      const result = builder ? builder() : [];
      const nodes = Array.isArray(result) ? result : (result ? [result] : []);
      host.replaceChildren(...nodes);
      applyScheduledActionBar(route);
    };

    const SAFE_MODE_ACTIVE = (() => {
      try {
        const params = new URLSearchParams(window.location.search);
        if (params.get('safe') === '1') return true;
      } catch (_) {}
      const hash = window.location.hash || '';
      if (/^#\/?safe$/i.test(hash)) return true;
      return SAFE_MODE;
    })();

    if (SAFE_MODE_ACTIVE && !SAFE_MODE) {
      if (typeof disableServiceWorkerOnce === 'function') {
        disableServiceWorkerOnce();
      }
      if (typeof window.Chart !== 'undefined') {
        try { window.Chart = undefined; } catch (_) {}
      }
      if (typeof window.IntersectionObserver !== 'undefined') {
        try { window.IntersectionObserver = undefined; } catch (_) {}
      }
    }

    const RECOVERY_BUILD_TAG = (() => {
      const now = new Date();
      const year = String(now.getFullYear());
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      return `FIX-BOOT-RECOVERY-${year}${month}${day}`;
    })();

    let tabsBound = false;
    let bootWatchdogId = null;

    const ensureHostStructure = () => {
      const bodyEl = document.body;
      if (!bodyEl) return null;
      let errbar = document.getElementById('errbar');
      if (!errbar) {
        errbar = document.createElement('div');
        errbar.id = 'errbar';
        bodyEl.insertBefore(errbar, bodyEl.firstChild || null);
      }
      errbar.setAttribute('aria-live', 'assertive');
      let host = appRoot || document.getElementById('app');
      if (!host) {
        host = document.createElement('main');
        host.id = 'app';
        bodyEl.appendChild(host);
      }
      return host;
    };

    const applyVisibilityGuarantees = (host) => {
      const htmlEl = document.documentElement;
      [htmlEl, document.body, host].forEach((node) => {
        if (!node) return;
        node.style.setProperty('display', 'block');
        node.style.setProperty('visibility', 'visible');
        node.style.setProperty('opacity', '1');
        node.style.setProperty('overflow-y', 'auto');
      });
    };

    const updateBuildIdentifiers = (tag, host) => {
      document.title = `BUILD_TAG=${tag}`;
      const htmlEl = document.documentElement;
      if (htmlEl) htmlEl.setAttribute('data-build-tag', tag);
      const bodyEl = document.body;
      if (bodyEl) bodyEl.setAttribute('data-build-tag', tag);
      const scope = host || appRoot || document.getElementById('app');
      const buildLabel = scope?.querySelector('.safe-mode-shell span.text-xs.text-slate-500');
      if (buildLabel) {
        buildLabel.textContent = `BUILD: ${tag}`;
      }
    };

    const clearBootWatchdog = () => {
      if (bootWatchdogId !== null) {
        window.clearTimeout(bootWatchdogId);
        bootWatchdogId = null;
      }
    };

    const mountBootTimeoutUi = () => {
      const host = appRoot || document.getElementById('app');
      if (!host || host.dataset.fullAppReady === '1') return;
      if (host.querySelector('.boot-timeout-fallback')) return;
      const fallback = createElem('div', {
        className: 'boot-timeout-fallback bg-white rounded-2xl shadow-sm p-4 sm:p-5 flex flex-col gap-3'
      });
      fallback.append(
        createElem('h2', { className: 'text-base font-semibold text-slate-900', textContent: '安全モードの起動に失敗しました' }),
        createElem('p', { className: 'text-sm text-slate-600', textContent: '初期化がタイムアウトしたため、簡易UIを表示しています。' })
      );
      host.append(fallback);
    };

    const startBootWatchdog = () => {
      clearBootWatchdog();
      bootWatchdogId = window.setTimeout(() => {
        const host = appRoot || document.getElementById('app');
        if (host && host.dataset.fullAppReady === '1') {
          bootWatchdogId = null;
          return;
        }
        bootWatchdogId = null;
        mountBootTimeoutUi();
        if (typeof window.showError === 'function') {
          window.showError('Boot timeout');
        }
        safeMode.onRenderFailure(new Error('Boot timeout'));
      }, SAFE_BOOT_TIMEOUT);
    };

    const mountAppSkeleton = () => {
      const host = ensureHostStructure();
      if (!host) {
        throw new Error('アプリのルート要素が見つかりません');
      }
      applyVisibilityGuarantees(host);
      if (!tabsBound) {
        bindTabs();
        tabsBound = true;
      }
      safeMode.mount(host);
      updateBuildIdentifiers(RECOVERY_BUILD_TAG, host);
      return host;
    };

    const renderSafeWorkout = () => {
      if (SAFE_MODE_ACTIVE && appState.route !== ROUTES.WORKOUT) {
        appState = { ...appState, route: ROUTES.WORKOUT };
      }
      syncHashToRoute(appState.route);
      render(appState);
      lastStableState = { ...appState };
      clearBootWatchdog();
      safeMode.onRenderSuccess();
    };

    const boot = () => {
      mountAppSkeleton();
      renderSafeWorkout();
    };

    startBootWatchdog();
    try {
      boot();
    } catch (err) {
      clearBootWatchdog();
      const detail = err?.stack || String(err);
      if (typeof window.showError === 'function') {
        window.showError('Boot crash', detail);
      }
      pushError(`初期化に失敗しました: ${err.message || err}`);
      ensureHostStructure();
      applyVisibilityGuarantees(appRoot || document.getElementById('app'));
      updateBuildIdentifiers(RECOVERY_BUILD_TAG);
      mountBootTimeoutUi();
      safeMode.onRenderFailure(err instanceof Error ? err : new Error(detail));
    }
<!-- PATCH-END: BOOT-SAFE -->
  })();
  </script>
</body>
</html>
