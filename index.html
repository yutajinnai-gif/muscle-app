<!DOCTYPE html>
<html lang="ja" class="bg-slate-100">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>筋トレメモ | BUILD_TAG=CORE-20240309</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha384-Jl0nO9r2yZS3AuNEqFOtPiou0IZ6Tn6PvxI6Bfq5lHppZArYrusS4x+h0/pk3jfb" crossorigin="anonymous"></script>
  <style>
    body { font-size: 16px; min-height: 100vh; }
    .scroll-lock { overflow: hidden; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.45); display: flex; align-items: center; justify-content: center; padding: 1.5rem; backdrop-filter: blur(2px); }
    .modal-card { max-width: 22rem; width: 100%; background: white; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 25px 50px -12px rgba(15, 23, 42, 0.25); }
    .error-banner { position: fixed; inset-inline: 0; top: 0; z-index: 50; }
    .tab-nav { position: fixed; bottom: 0; inset-inline: 0; background: white; border-top: 1px solid rgba(51, 65, 85, 0.2); padding: 0.5rem 0; display: flex; justify-content: space-around; }
    .main-content { padding-bottom: 4.5rem; padding-top: 4.5rem; }
    .btn-primary { background-color: #1f2937; color: white; }
    .btn-primary:hover { background-color: #111827; }
    .btn-muted { background-color: white; color: #1f2937; border: 1px solid rgba(30,41,59,0.3); }
    .input-base { border: 1px solid rgba(51,65,85,0.35); border-radius: 0.75rem; padding: 0.6rem 0.75rem; font-size: 1rem; width: 100%; background-color: white; color: #111827; }
    .input-base:focus { outline: 2px solid rgba(30, 64, 175, 0.6); outline-offset: 2px; }
  </style>
</head>
<body class="text-slate-900">
  <div id="error-root" class="error-banner hidden"></div>
  <main id="app" class="max-w-3xl mx-auto main-content"></main>
  <nav class="tab-nav">
    <button data-route="home" class="tab-button flex-1 text-sm font-semibold text-slate-600">ホーム</button>
    <button data-route="history" class="tab-button flex-1 text-sm font-semibold text-slate-600">履歴</button>
    <button data-route="workout" class="tab-button flex-1 text-sm font-semibold text-slate-600">記録</button>
    <button data-route="settings" class="tab-button flex-1 text-sm font-semibold text-slate-600">設定</button>
  </nav>
  <script>
  (function(){
    'use strict';

    /*** utils ***/
    const ROUTES = Object.freeze({
      HOME: 'home',
      HISTORY: 'history',
      SETTINGS: 'settings',
      WORKOUT: 'workout'
    });
    const ROUTE_VALUES = new Set(Object.values(ROUTES));

    const createElem = (tag, opts = {}) => {
      const el = document.createElement(tag);
      if (opts.className) el.className = opts.className;
      if (opts.textContent !== undefined) el.textContent = opts.textContent;
      if (opts.html !== undefined) el.innerHTML = opts.html;
      if (opts.attrs) Object.entries(opts.attrs).forEach(([k, v]) => el.setAttribute(k, v));
      if (opts.value !== undefined) el.value = opts.value;
      if (opts.children) opts.children.forEach(child => el.appendChild(child));
      return el;
    };

    const formatDate = (value) => {
      try {
        return new Intl.DateTimeFormat('ja-JP', { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));
      } catch (err) {
        return '';
      }
    };

    const safeNumber = (value) => {
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };

    const cloneDeep = (obj) => structuredClone(obj);

    /*** error banner ***/
    const errorRoot = document.getElementById('error-root');
    const errorState = { logs: [], expanded: false };

    const renderErrorBanner = () => {
      if (!errorRoot) return;
      if (!errorState.logs.length) {
        errorRoot.classList.add('hidden');
        errorRoot.replaceChildren();
        return;
      }
      errorRoot.classList.remove('hidden');
      const container = createElem('div', { className: 'bg-red-900/90 text-red-50 px-4 py-3 shadow-lg border-b border-red-300' });
      const header = createElem('div', { className: 'flex items-center justify-between gap-2' });
      const toggleBtn = createElem('button', {
        className: 'text-sm underline decoration-dotted',
        textContent: errorState.expanded ? '閉じる' : '詳細',
        attrs: { type: 'button' }
      });
      header.append(
        createElem('div', { className: 'font-semibold', textContent: 'アプリでエラーが発生しました' }),
        toggleBtn
      );
      const logList = createElem('pre', { className: 'mt-2 text-xs bg-red-950/40 rounded-lg p-2 overflow-x-auto whitespace-pre-wrap' });
      logList.textContent = errorState.logs.map((log, idx) => `#${idx + 1}\n${log}`).join('\n\n');
      if (!errorState.expanded) logList.classList.add('hidden');
      toggleBtn.addEventListener('click', () => {
        errorState.expanded = !errorState.expanded;
        renderErrorBanner();
      });
      container.append(header, logList);
      errorRoot.replaceChildren(container);
    };

    const pushError = (message) => {
      errorState.logs.push(message);
      renderErrorBanner();
    };

    window.addEventListener('error', (event) => {
      pushError(`${event.message}\n${event.filename || ''}:${event.lineno || ''}`);
    });
    window.addEventListener('unhandledrejection', (event) => {
      pushError(`Promiseエラー: ${event.reason}`);
    });

    /*** storage ***/
    const SCHEMA_VERSION = 1;
    const STORAGE_NAMESPACE = 'muscle-app-core';
    class NamespacedStorage {
      constructor(namespace, version) {
        this.namespace = namespace;
        this.version = version;
      }
      _key(key) {
        return `${this.namespace}:${key}`;
      }
      _safeParse(raw) {
        try {
          return JSON.parse(raw);
        } catch (err) {
          return null;
        }
      }
      load(key, fallback) {
        const raw = localStorage.getItem(this._key(key));
        if (!raw) return cloneDeep(fallback);
        const parsed = this._safeParse(raw);
        if (!parsed || parsed.schema !== this.version) return cloneDeep(fallback);
        return parsed.data;
      }
      save(key, data) {
        const payload = JSON.stringify({ schema: this.version, data });
        localStorage.setItem(this._key(key), payload);
      }
      clearNamespace() {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (k && k.startsWith(`${this.namespace}:`)) keys.push(k);
        }
        keys.forEach((k) => localStorage.removeItem(k));
      }
    }

    const storage = new NamespacedStorage(STORAGE_NAMESPACE, SCHEMA_VERSION);

    /*** modal api ***/
    const modalState = { locked: false };

    const closeModal = (backdrop, outerResolve, value) => {
      if (!backdrop) return;
      backdrop.classList.add('opacity-0');
      setTimeout(() => {
        backdrop.remove();
        document.body.classList.remove('scroll-lock');
        modalState.locked = false;
        outerResolve(value);
      }, 120);
    };

    const openModal = (buildContent) => {
      if (modalState.locked) return Promise.resolve(null);
      modalState.locked = true;
      document.body.classList.add('scroll-lock');
      const backdrop = createElem('div', { className: 'modal-backdrop' });
      const card = createElem('div', { className: 'modal-card' });
      backdrop.append(card);
      document.body.append(backdrop);
      return new Promise((outerResolve) => {
        const finish = (value) => {
          document.removeEventListener('keydown', keyHandler);
          closeModal(backdrop, outerResolve, value);
        };
        const keyHandler = (event) => {
          if (event.key === 'Escape') finish(null);
        };
        document.addEventListener('keydown', keyHandler);
        backdrop.addEventListener('click', (event) => {
          if (event.target === backdrop) finish(null);
        });
        const { content, focus } = buildContent(finish);
        card.append(content);
        if (typeof focus === 'function') focus();
      });
    };

    const confirmAction = (message) => {
      return openModal((finish) => {
        const text = createElem('p', { className: 'text-sm text-slate-700 mb-4', textContent: message });
        const btnWrap = createElem('div', { className: 'flex justify-end gap-2' });
        const cancelBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const okBtn = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'OK', attrs: { type: 'button' } });
        cancelBtn.addEventListener('click', () => finish(false));
        okBtn.addEventListener('click', () => finish(true));
        btnWrap.append(cancelBtn, okBtn);
        return { content: createElem('div', { children: [text, btnWrap] }), focus: () => okBtn.focus() };
      }).then((value) => Boolean(value));
    };

    const pickFromList = (title, options) => {
      return openModal((finish) => {
        const header = createElem('div', { className: 'mb-3' });
        header.append(createElem('p', { className: 'text-sm font-semibold text-slate-800', textContent: title }));
        const list = createElem('div', { className: 'max-h-64 overflow-y-auto space-y-2' });
        options.forEach((opt) => {
          const btn = createElem('button', { className: 'w-full text-left px-3 py-2 rounded-lg border border-slate-200 hover:border-slate-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500', textContent: opt, attrs: { type: 'button' } });
          btn.addEventListener('click', () => finish(opt));
          list.append(btn);
        });
        const cancel = createElem('button', { className: 'mt-4 btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        cancel.addEventListener('click', () => finish(null));
        const firstButton = () => list.querySelector('button');
        const content = createElem('div', { children: [header, list, cancel] });
        return { content, focus: () => { const btn = firstButton(); if (btn) btn.focus(); else cancel.focus(); } };
      });
    };

    const promptText = (title) => {
      return openModal((finish) => {
        const label = createElem('label', { className: 'flex flex-col gap-2' });
        label.append(
          createElem('span', { className: 'text-sm font-semibold text-slate-800', textContent: title }),
          createElem('input', { className: 'input-base', attrs: { type: 'text' } })
        );
        const actions = createElem('div', { className: 'flex justify-end gap-2 mt-4' });
        const cancel = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'キャンセル', attrs: { type: 'button' } });
        const ok = createElem('button', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold', textContent: '決定', attrs: { type: 'button' } });
        cancel.addEventListener('click', () => finish(null));
        const input = label.querySelector('input');
        ok.addEventListener('click', () => finish(input.value.trim() || null));
        actions.append(cancel, ok);
        const content = createElem('div', { children: [label, actions] });
        return { content, focus: () => input.focus() };
      });
    };

    /*** data model ***/
    const STORAGE_KEYS = Object.freeze({
      DATA: 'data'
    });

    const createInitialData = () => ({
      workouts: [],
      currentWorkout: {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: []
      },
      settings: {
        unit: 'kg',
        exerciseCatalog: ['ベンチプレス', 'スクワット', 'デッドリフト']
      },
      historyView: {
        exerciseName: null
      }
    });

    const loadData = () => {
      const stored = storage.load(STORAGE_KEYS.DATA, createInitialData());
      const base = createInitialData();
      return { ...base, ...stored };
    };

    let appData = loadData();

    const persist = () => {
      storage.save(STORAGE_KEYS.DATA, appData);
    };

    const resetData = () => {
      appData = createInitialData();
      oneRmMemo.clear();
      persist();
    };

    /*** 1RM memoization ***/
    const oneRmMemo = new Map();
    const compute1RM = (weight, reps) => {
      const w = safeNumber(weight);
      const r = safeNumber(reps);
      if (w === null || r === null || r <= 0 || w <= 0) return null;
      return Number((w * (1 + r / 30)).toFixed(2));
    };

    const getExerciseKey = (workoutId, exerciseId) => `${workoutId}:${exerciseId}`;

    const recomputeExercise = (workoutId, exercise) => {
      const key = getExerciseKey(workoutId, exercise.id);
      const signature = exercise.sets.map((set) => `${set.weight ?? ''}|${set.reps ?? ''}`).join('::');
      const cached = oneRmMemo.get(key);
      if (cached && cached.signature === signature) {
        cached.values.forEach((val, idx) => {
          exercise.sets[idx].oneRM = val;
        });
        return;
      }
      const values = exercise.sets.map((set) => compute1RM(set.weight, set.reps));
      values.forEach((val, idx) => {
        exercise.sets[idx].oneRM = val;
      });
      oneRmMemo.set(key, { signature, values });
    };

    const recomputeAll = () => {
      appData.workouts.forEach((workout) => {
        workout.exercises.forEach((exercise) => recomputeExercise(workout.id, exercise));
      });
      appData.currentWorkout.exercises.forEach((exercise) => recomputeExercise(appData.currentWorkout.id, exercise));
    };
    recomputeAll();

    /*** router ***/
    let currentRoute = ROUTES.HOME;

    const parseHash = (hash) => {
      const normalized = (hash || '').replace(/^#/, '').trim().toLowerCase();
      if (!normalized) return ROUTES.HOME;
      if (!ROUTE_VALUES.has(normalized)) return ROUTES.HOME;
      return normalized;
    };

    const navigate = (route) => {
      currentRoute = route;
      renderRoute();
      updateTabState();
    };

    window.addEventListener('hashchange', () => {
      const route = parseHash(location.hash);
      navigate(route);
    });

    /*** chart manager ***/
    const createChartManager = (canvas) => {
      const chart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: '推定1RM',
            data: [],
            borderColor: '#1d4ed8',
            backgroundColor: 'rgba(29, 78, 216, 0.15)',
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { color: '#1f2937' } },
            y: {
              ticks: { color: '#1f2937' },
              beginAtZero: true
            }
          },
          plugins: {
            legend: { labels: { color: '#1f2937', font: { weight: '600' } } }
          }
        }
      });
      return {
        update(labels, values) {
          chart.data.labels = labels;
          chart.data.datasets[0].data = values;
          chart.update();
        }
      };
    };

    let historyChartCanvas = null;
    let historyChartManager = null;

    /*** render helpers ***/
    const appRoot = document.getElementById('app');

    const updateTabState = () => {
      document.querySelectorAll('.tab-button').forEach((tab) => {
        const route = tab.getAttribute('data-route');
        if (route === currentRoute) {
          tab.classList.add('text-blue-600');
        } else {
          tab.classList.remove('text-blue-600');
        }
      });
    };

    const setHash = (route) => {
      if (location.hash.replace('#', '') !== route) {
        location.hash = route;
      } else {
        navigate(route);
      }
    };

    const bindTabs = () => {
      document.querySelectorAll('.tab-button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const route = btn.getAttribute('data-route');
          if (ROUTE_VALUES.has(route)) setHash(route);
        });
      });
    };

    const renderRoute = () => {
      if (!appRoot) return;
      appRoot.replaceChildren();
      if (currentRoute === ROUTES.HOME) renderHome();
      else if (currentRoute === ROUTES.HISTORY) renderHistory();
      else if (currentRoute === ROUTES.SETTINGS) renderSettings();
      else if (currentRoute === ROUTES.WORKOUT) renderWorkout();
      else renderHome();
    };

    const createCard = (titleText, body) => {
      return createElem('section', {
        className: 'bg-white rounded-2xl shadow-sm border border-slate-200/70 p-5 mb-6',
        children: [
          createElem('header', { className: 'flex items-center justify-between mb-4', children: [
            createElem('h2', { className: 'text-lg font-bold text-slate-800', textContent: titleText })
          ] }),
          body
        ]
      });
    };

    /*** actions ***/
    const ensureExerciseCatalog = (name) => {
      if (!name) return;
      if (!appData.settings.exerciseCatalog.includes(name)) {
        appData.settings.exerciseCatalog.push(name);
      }
    };

    const addExercise = async () => {
      const catalog = [...appData.settings.exerciseCatalog];
      catalog.sort((a, b) => a.localeCompare(b, 'ja'));
      const choice = await pickFromList('種目を選択', [...catalog, '新規追加']);
      if (!choice) return;
      let exerciseName = choice;
      if (choice === '新規追加') {
        exerciseName = await promptText('新しい種目名');
        if (!exerciseName) return;
      }
      ensureExerciseCatalog(exerciseName);
      const newExercise = {
        id: `ex-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`,
        name: exerciseName,
        sets: [createEmptySet()]
      };
      appData.currentWorkout.exercises.push(newExercise);
      recomputeExercise(appData.currentWorkout.id, newExercise);
      persist();
      renderRoute();
    };

    const createEmptySet = () => ({ weight: null, reps: null, oneRM: null, note: '' });

    const addSet = (exerciseId) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      exercise.sets.push(createEmptySet());
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
      renderRoute();
    };

    const updateSetField = (exerciseId, setIndex, field, value) => {
      const exercise = appData.currentWorkout.exercises.find((ex) => ex.id === exerciseId);
      if (!exercise) return;
      const set = exercise.sets[setIndex];
      if (!set) return;
      if (field === 'weight' || field === 'reps') {
        const num = safeNumber(value);
        set[field] = num === null ? null : num;
      } else if (field === 'note') {
        set[field] = value;
      }
      recomputeExercise(appData.currentWorkout.id, exercise);
      persist();
    };

    const deleteExercise = async (exerciseId) => {
      if (!(await confirmAction('この種目を削除しますか？'))) return;
      appData.currentWorkout.exercises = appData.currentWorkout.exercises.filter((ex) => ex.id !== exerciseId);
      persist();
      renderRoute();
    };

    const finishWorkout = async () => {
      if (!appData.currentWorkout.exercises.length) return;
      const confirmed = await confirmAction('現在のワークアウトを完了として保存しますか？');
      if (!confirmed) return;
      const workoutCopy = cloneDeep(appData.currentWorkout);
      workoutCopy.id = `wo-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`;
      workoutCopy.completedAt = Date.now();
      workoutCopy.exercises.forEach((exercise) => recomputeExercise(workoutCopy.id, exercise));
      appData.workouts.unshift(workoutCopy);
      appData.currentWorkout = {
        id: `current-${Date.now()}`,
        startedAt: Date.now(),
        exercises: []
      };
      persist();
      renderRoute();
    };

    const deleteWorkout = async (workoutId) => {
      const ok = await confirmAction('選択した履歴を削除しますか？');
      if (!ok) return;
      appData.workouts = appData.workouts.filter((wk) => wk.id !== workoutId);
      persist();
      renderRoute();
    };

    const clearAllData = async () => {
      const ok = await confirmAction('すべてのデータを初期化します。よろしいですか？');
      if (!ok) return;
      storage.clearNamespace();
      resetData();
      renderRoute();
    };

    const changeUnit = (unit) => {
      appData.settings.unit = unit;
      persist();
      renderRoute();
    };

    const exportData = () => {
      const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = createElem('a', { attrs: { href: url, download: 'muscle-app-backup.json' } });
      document.body.append(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    };

    const importData = async (file) => {
      if (!file) return;
      const text = await file.text();
      try {
        const parsed = JSON.parse(text);
        if (!parsed || typeof parsed !== 'object') throw new Error('形式が正しくありません');
        appData = { ...createInitialData(), ...parsed };
        recomputeAll();
        persist();
        renderRoute();
      } catch (err) {
        pushError(`読み込みに失敗しました: ${err.message}`);
      }
    };

    /*** route renderers ***/
    const renderHome = () => {
      const workout = appData.currentWorkout;
      const cardBody = createElem('div');
      const headerInfo = createElem('div', { className: 'text-sm text-slate-600 mb-4', textContent: `開始: ${formatDate(workout.startedAt)}` });
      cardBody.append(headerInfo);
      if (!workout.exercises.length) {
        cardBody.append(createElem('p', { className: 'text-slate-600 text-sm', textContent: '種目を追加して記録を開始しましょう。' }));
      } else {
        workout.exercises.forEach((exercise) => {
          const exCard = createElem('div', { className: 'border border-slate-200 rounded-xl p-4 mb-4 bg-slate-50/60' });
          const exHeader = createElem('div', { className: 'flex items-center justify-between mb-3' });
          const deleteBtn = createElem('button', { className: 'text-xs font-semibold text-red-600 underline decoration-dotted', textContent: '削除', attrs: { type: 'button' } });
          deleteBtn.addEventListener('click', () => deleteExercise(exercise.id));
          exHeader.append(
            createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: exercise.name }),
            deleteBtn
          );
          exCard.append(exHeader);
          const table = createElem('div', { className: 'space-y-3' });
          exercise.sets.forEach((set, index) => {
            const row = createElem('div', { className: 'grid grid-cols-1 sm:grid-cols-4 gap-3 items-end' });
            const weightWrap = createElem('label', { className: 'flex flex-col text-sm font-semibold text-slate-700 gap-1' });
            const weightInput = createElem('input', { className: 'input-base', attrs: { type: 'number', inputmode: 'decimal', min: '0' }, value: set.weight ?? '' });
            weightInput.addEventListener('input', (event) => {
              updateSetField(exercise.id, index, 'weight', event.target.value);
              renderRoute();
            });
            weightWrap.append(createElem('span', { textContent: `重量 (${appData.settings.unit})` }), weightInput);
            const repsWrap = createElem('label', { className: 'flex flex-col text-sm font-semibold text-slate-700 gap-1' });
            const repsInput = createElem('input', { className: 'input-base', attrs: { type: 'number', inputmode: 'numeric', min: '0' }, value: set.reps ?? '' });
            repsInput.addEventListener('input', (event) => {
              updateSetField(exercise.id, index, 'reps', event.target.value);
              renderRoute();
            });
            repsWrap.append(createElem('span', { textContent: '回数' }), repsInput);
            const noteWrap = createElem('label', { className: 'flex flex-col text-sm font-semibold text-slate-700 gap-1 sm:col-span-2' });
            const noteInput = createElem('textarea', { className: 'input-base min-h-[2.5rem]', attrs: { rows: '2' }, textContent: set.note || '' });
            noteInput.addEventListener('input', (event) => {
              updateSetField(exercise.id, index, 'note', event.target.value);
            });
            noteWrap.append(createElem('span', { textContent: 'メモ' }), noteInput);
            const oneRmLabel = createElem('p', { className: 'text-sm text-slate-600 sm:col-span-4', textContent: set.oneRM ? `推定1RM: ${set.oneRM} ${appData.settings.unit}` : '推定1RM: -' });
            row.append(weightWrap, repsWrap, noteWrap, oneRmLabel);
            table.append(row);
          });
          const addSetBtn = createElem('button', { className: 'btn-muted mt-3 px-3 py-2 rounded-lg text-sm font-semibold', textContent: 'セットを追加', attrs: { type: 'button' } });
          addSetBtn.addEventListener('click', () => addSet(exercise.id));
          exCard.append(table, addSetBtn);
          cardBody.append(exCard);
        });
      }
      const actions = createElem('div', { className: 'flex flex-col sm:flex-row gap-3 mt-4' });
      const addExerciseBtn = createElem('button', { className: 'btn-primary px-4 py-3 rounded-xl text-sm font-semibold flex-1', textContent: '種目を追加', attrs: { type: 'button' } });
      addExerciseBtn.addEventListener('click', addExercise);
      const finishBtn = createElem('button', { className: 'btn-muted px-4 py-3 rounded-xl text-sm font-semibold flex-1', textContent: '完了して履歴へ', attrs: { type: 'button' } });
      finishBtn.addEventListener('click', finishWorkout);
      actions.append(addExerciseBtn, finishBtn);
      cardBody.append(actions);
      appRoot.append(createCard('現在のワークアウト', cardBody));
    };

    const renderHistory = () => {
      const cardBody = createElem('div');
      if (!appData.workouts.length) {
        cardBody.append(createElem('p', { className: 'text-sm text-slate-600', textContent: '履歴はまだありません。' }));
      } else {
        const list = createElem('div', { className: 'space-y-4' });
        appData.workouts.forEach((workout) => {
          const item = createElem('article', { className: 'border border-slate-200 rounded-xl p-4 bg-white/60' });
          const header = createElem('div', { className: 'flex items-center justify-between mb-3' });
          const deleteBtn = createElem('button', { className: 'text-xs text-red-600 font-semibold underline decoration-dotted', textContent: '削除', attrs: { type: 'button' } });
          deleteBtn.addEventListener('click', () => deleteWorkout(workout.id));
          header.append(
            createElem('div', { className: 'text-sm text-slate-700', textContent: formatDate(workout.completedAt || workout.startedAt) }),
            deleteBtn
          );
          item.append(header);
          workout.exercises.forEach((exercise) => {
            const exerciseBlock = createElem('div', { className: 'mb-3' });
            exerciseBlock.append(createElem('h4', { className: 'text-base font-semibold text-slate-800', textContent: exercise.name }));
            const setsList = createElem('ul', { className: 'mt-2 space-y-2' });
            exercise.sets.forEach((set, index) => {
              const info = `#${index + 1} 重量: ${set.weight ?? '-'}${appData.settings.unit} / 回数: ${set.reps ?? '-'} / 推定1RM: ${set.oneRM ?? '-'}${set.note ? ' / ' + set.note : ''}`;
              setsList.append(createElem('li', { className: 'text-sm text-slate-700 bg-slate-100 rounded-lg px-3 py-2', textContent: info }));
            });
            const trendBtn = createElem('button', { className: 'mt-1 text-xs text-blue-700 underline decoration-dotted', textContent: '推移を表示', attrs: { type: 'button' } });
            trendBtn.addEventListener('click', () => {
              appData.historyView.exerciseName = exercise.name;
              renderRoute();
            });
            exerciseBlock.append(setsList, trendBtn);
            item.append(exerciseBlock);
          });
          list.append(item);
        });
        cardBody.append(list);
      }
      if (!historyChartCanvas) {
        historyChartCanvas = createElem('canvas');
        historyChartManager = createChartManager(historyChartCanvas);
      }
      const chartContainer = createElem('div', { className: 'mt-6 h-64 relative' });
      chartContainer.append(historyChartCanvas);
      cardBody.append(chartContainer);
      appRoot.append(createCard('ワークアウト履歴', cardBody));
      const exerciseName = appData.historyView.exerciseName;
      if (exerciseName) {
        const dataset = [];
        appData.workouts.slice().reverse().forEach((workout) => {
          workout.exercises.filter((ex) => ex.name === exerciseName).forEach((exercise) => {
            const best = Math.max(...exercise.sets.map((set) => Number(set.oneRM) || 0));
            dataset.push({ date: workout.completedAt || workout.startedAt, value: best });
          });
        });
        const labels = dataset.map((d) => formatDate(d.date));
        const values = dataset.map((d) => d.value);
        historyChartManager.update(labels, values);
      } else {
        historyChartManager.update([], []);
      }
    };

    const renderWorkout = () => {
      const cardBody = createElem('div');
      if (!appData.workouts.length) {
        cardBody.append(createElem('p', { className: 'text-sm text-slate-600', textContent: '保存済みのワークアウトはありません。' }));
      } else {
        const latest = appData.workouts[0];
        cardBody.append(createElem('p', { className: 'text-sm text-slate-600 mb-3', textContent: `最新の完了日時: ${formatDate(latest.completedAt || latest.startedAt)}` }));
        latest.exercises.forEach((exercise) => {
          const block = createElem('div', { className: 'border border-slate-200 rounded-xl p-4 mb-3 bg-slate-50/60' });
          block.append(createElem('h3', { className: 'text-base font-semibold text-slate-800 mb-2', textContent: exercise.name }));
          const list = createElem('ul', { className: 'space-y-2' });
          exercise.sets.forEach((set, idx) => {
            list.append(createElem('li', { className: 'text-sm text-slate-700 bg-white rounded-lg px-3 py-2 border border-slate-200', textContent: `#${idx + 1} 重量:${set.weight ?? '-'}${appData.settings.unit} / 回数:${set.reps ?? '-'} / 推定1RM:${set.oneRM ?? '-'}` }));
          });
          block.append(list);
          cardBody.append(block);
        });
      }
      appRoot.append(createCard('最新のワークアウト', cardBody));
    };

    const renderSettings = () => {
      const cardBody = createElem('div', { className: 'space-y-6' });
      const unitSection = createElem('div', { className: 'space-y-3' });
      unitSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '単位設定' }));
      const unitOptions = ['kg', 'lb'];
      const unitWrap = createElem('div', { className: 'flex gap-3' });
      unitOptions.forEach((unit) => {
        const label = createElem('label', { className: 'inline-flex items-center gap-2 text-sm text-slate-700 font-semibold' });
        const input = createElem('input', { attrs: { type: 'radio', name: 'unit', value: unit } });
        if (appData.settings.unit === unit) input.checked = true;
        input.addEventListener('change', () => changeUnit(unit));
        label.append(input, createElem('span', { textContent: unit }));
        unitWrap.append(label);
      });
      unitSection.append(unitWrap);
      cardBody.append(unitSection);

      const catalogSection = createElem('div', { className: 'space-y-3' });
      catalogSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: '登録済み種目' }));
      const list = createElem('ul', { className: 'space-y-2' });
      appData.settings.exerciseCatalog.forEach((name) => {
        list.append(createElem('li', { className: 'text-sm text-slate-700 px-3 py-2 bg-slate-100 rounded-lg border border-slate-200', textContent: name }));
      });
      catalogSection.append(list);
      cardBody.append(catalogSection);

      const importExportSection = createElem('div', { className: 'space-y-3' });
      importExportSection.append(createElem('h3', { className: 'text-base font-semibold text-slate-800', textContent: 'バックアップ' }));
      const exportBtn = createElem('button', { className: 'btn-muted px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'エクスポート', attrs: { type: 'button' } });
      exportBtn.addEventListener('click', exportData);
      const importLabel = createElem('label', { className: 'btn-primary px-4 py-2 rounded-lg text-sm font-semibold inline-flex items-center justify-center gap-2 w-fit cursor-pointer' });
      importLabel.append(createElem('span', { textContent: 'インポート' }));
      const input = createElem('input', { attrs: { type: 'file', accept: 'application/json' } });
      input.classList.add('hidden');
      input.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        importData(file);
        event.target.value = '';
      });
      importLabel.append(input);
      importExportSection.append(createElem('div', { className: 'flex gap-3', children: [exportBtn, importLabel] }));
      cardBody.append(importExportSection);

      const dangerSection = createElem('div', { className: 'space-y-3' });
      dangerSection.append(createElem('h3', { className: 'text-base font-semibold text-red-700', textContent: 'データ初期化' }));
      const clearBtn = createElem('button', { className: 'bg-red-700 hover:bg-red-800 text-white px-4 py-2 rounded-lg text-sm font-semibold', textContent: 'すべて削除', attrs: { type: 'button' } });
      clearBtn.addEventListener('click', clearAllData);
      dangerSection.append(clearBtn);
      cardBody.append(dangerSection);

      appRoot.append(createCard('設定', cardBody));
    };

    /*** bootstrap ***/
    bindTabs();
    setHash(parseHash(location.hash));
  })();
  </script>
</body>
</html>
